<!DOCTYPE html>
<html lang=zh-CN>
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta property="og:description" content="">
    <meta property="og:type" content="website">
    <meta name="description" content="">
    <meta name="keyword"  content="">
    <link rel="shortcut icon" href="/img/favicon.ico">

    <title>
        
        高性能计算学习导航 - Vicczyq | 记录学习和生活
        
    </title>

    <!-- Custom CSS -->
    
<link rel="stylesheet" href="/css/aircloud.css">

    
<link rel="stylesheet" href="/css/gitment.css">

    <!--<link rel="stylesheet" href="https://imsun.github.io/gitment/style/default.css">-->
    <link href="//at.alicdn.com/t/font_620856_28hi1hpxx24.css" rel="stylesheet" type="text/css">
    <!-- ga & ba script hoook -->
    <script></script>

    









<meta name="generator" content="Hexo 7.1.0"></head>

<body>

<div class="site-nav-toggle" id="site-nav-toggle">
    <button>
        <span class="btn-bar"></span>
        <span class="btn-bar"></span>
        <span class="btn-bar"></span>
    </button>
</div>

<div class="index-about">
    <i> 好好生活，保持热爱，无惧无畏，奔赴山海 </i>
</div>

<div class="index-container">
    
    <div class="index-left">
        
<div class="nav" id="nav">
    <div class="avatar-name">
        <div class="avatar radius">
            <img src="//q2.qlogo.cn/headimg_dl?dst_uin=1740674168&amp;spec=140" />
        </div>
        <div class="name">
            <i>Vicczyq | 长木乔</i>
        </div>
    </div>
    <div class="contents" id="nav-content">
        <ul>
            <li >
                <a href="/">
                    <i class="iconfont icon-shouye1"></i>
                    <span>主页</span>
                </a>
            </li>
            <li >
                <a href="/tags">
                    <i class="iconfont icon-biaoqian1"></i>
                    <span>标签</span>
                </a>
            </li>
            <li >
                <a href="/archives">
                    <i class="iconfont icon-guidang2"></i>
                    <span>存档</span>
                </a>
            </li>
            <li >
                <a href="/collect/">
                    <i class="iconfont icon-shoucang1"></i>
                    <span>收藏</span>
                </a>
            </li>
            <li >
                <a href="/about/">
                    <i class="iconfont icon-guanyu2"></i>
                    <span>关于</span>
                </a>
            </li>
            
            <li>
                <a id="search">
                    <i class="iconfont icon-sousuo1"></i>
                    <span>搜索</span>
                </a>
            </li>
            
        </ul>
    </div>
    
        <div id="toc" class="toc-article">
    <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%BA%90"><span class="toc-text">学习资源</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86"><span class="toc-text">一、基础知识</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-1-%E5%B9%B6%E8%A1%8C%E8%AE%A1%E7%AE%97"><span class="toc-text">1.1 并行计算</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-1-%E5%88%86%E7%B1%BB%EF%BC%9A"><span class="toc-text">1.1.1 分类：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-3-%E5%B9%B6%E8%A1%8C%E5%92%8C%E5%B9%B6%E5%8F%91%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">1.1.3 并行和并发的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-3-%E5%BC%82%E6%9E%84%E5%B9%B6%E8%A1%8C%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="toc-text">1.1.3 异构并行的概念</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-2-%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B"><span class="toc-text">1.2 进程和线程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-3-CPU%E5%86%85%E9%83%A8%E6%9E%B6%E6%9E%84"><span class="toc-text">1.3 CPU内部架构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3-1-%E6%8C%87%E4%BB%A4%E6%B5%81%E6%B0%B4%E7%BA%BF%EF%BC%88pipeline%EF%BC%89"><span class="toc-text">1.3.1 指令流水线（pipeline）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3-2-%E8%B6%85%E6%A0%87%E9%87%8F%EF%BC%88Superscalar%EF%BC%89"><span class="toc-text">1.3.2 超标量（Superscalar）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3-3-%E6%B5%81%E6%B0%B4%E7%BA%BF%E5%86%B2%E7%AA%81"><span class="toc-text">1.3.3 流水线冲突</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%881%EF%BC%89%E6%95%B0%E6%8D%AE%E5%86%B2%E7%AA%81"><span class="toc-text">（1）数据冲突</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%882%EF%BC%89%E6%8E%A7%E5%88%B6%E5%86%B2%E7%AA%81"><span class="toc-text">（2）控制冲突</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%883%EF%BC%89%E7%BB%93%E6%9E%84%E5%86%B2%E7%AA%81"><span class="toc-text">（3）结构冲突</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-4-%E9%AB%98%E6%80%A7%E8%83%BD%E6%95%B0%E5%AD%A6%E7%AE%97%E6%B3%95%E5%BA%93"><span class="toc-text">1.4 高性能数学算法库</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-4-1-BLAS-LAPACK"><span class="toc-text">1.4.1 BLAS&#x2F;LAPACK</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-4-2-PETSc"><span class="toc-text">1.4.2 PETSc</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E5%85%A5%E9%97%A8%E7%AF%87"><span class="toc-text">二、入门篇</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#2-1-Pthread"><span class="toc-text">2.1 Pthread</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-2-OpenMP"><span class="toc-text">2.2 OpenMP</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%89%E3%80%81%E5%9F%BA%E7%A1%80%E7%AF%87"><span class="toc-text">三、基础篇</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#3-1-MPI"><span class="toc-text">3.1 MPI</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-2-CUDA"><span class="toc-text">3.2 CUDA</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-3-%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90"><span class="toc-text">3.3 性能分析</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-1-%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7"><span class="toc-text">3.3.1 静态分析工具</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-2-%E5%8A%A8%E6%80%81%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7"><span class="toc-text">3.3.2 动态分析工具</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Perf"><span class="toc-text">Perf</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#gprof%EF%BC%88GNU-profile%EF%BC%89"><span class="toc-text">gprof（GNU profile）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#intel-vtune-profiler"><span class="toc-text">intel vtune profiler</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-4-SIMD"><span class="toc-text">3.4 SIMD</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%9B%9B%E3%80%81%E5%85%B6%E4%BB%96%E5%B8%B8%E7%94%A8%E4%BC%98%E5%8C%96%E6%89%8B%E6%AE%B5"><span class="toc-text">四、其他常用优化手段</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#4-1-%E5%B8%B8%E7%94%A8%E5%BE%AA%E7%8E%AF%E4%BC%98%E5%8C%96%E6%8A%80%E6%9C%AF"><span class="toc-text">4.1 常用循环优化技术</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%EF%BC%881%EF%BC%89%E8%BE%93%E5%85%A5%E5%80%BC%E5%B5%8C%E5%85%A5"><span class="toc-text">（1）输入值嵌入</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%EF%BC%882%EF%BC%89%E5%88%86%E6%94%AF%E6%B6%88%E9%99%A4"><span class="toc-text">（2）分支消除</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%EF%BC%883%EF%BC%89%E5%BE%AA%E7%8E%AF%E5%90%88%E5%B9%B6"><span class="toc-text">（3）循环合并</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%EF%BC%884%EF%BC%89%E6%AC%A1%E5%BA%8F%E4%BA%A4%E6%8D%A2"><span class="toc-text">（4）次序交换</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%EF%BC%885%EF%BC%89%E5%BE%AA%E7%8E%AF%E5%88%86%E5%9D%97"><span class="toc-text">（5）循环分块</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%EF%BC%886%EF%BC%89%E5%BE%AA%E7%8E%AF%E5%B1%95%E5%BC%80"><span class="toc-text">（6）循环展开</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A1%A5%E5%85%85%EF%BC%9A%E4%BC%98%E5%8C%96%E7%83%AD%E7%82%B9%E8%B7%AF%E5%BE%84%E5%86%85%E5%AD%98%E8%AE%BF%E9%97%AE"><span class="toc-text">补充：优化热点路径内存访问</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-2-cache%E4%BC%98%E5%8C%96"><span class="toc-text">4.2 cache优化</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-1-%E6%8C%87%E4%BB%A4cache%E4%BC%98%E5%8C%96"><span class="toc-text">4.2.1 指令cache优化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-2-%E6%95%B0%E6%8D%AEcache%E4%BC%98%E5%8C%96"><span class="toc-text">4.2.2 数据cache优化</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-3-%E9%80%BB%E8%BE%91%E4%BC%98%E5%8C%96"><span class="toc-text">4.3 逻辑优化</span></a></li></ol></li></ol>
</div>
    
</div>


<div class="search-field" id="search-field">
    <div class="search-bg" id="search-bg"></div>
    <div class="search-container">
        <div class="search-input">
            <span id="esc-search"> <i class="icon-fanhui iconfont"></i></span>
            <input id="search-input"/>
            <span id="begin-search">搜索</span>
        </div>
        <div class="search-result-container" id="search-result-container">

        </div>
    </div>
</div>

        <div class="index-about-mobile">
            <i> 好好生活，保持热爱，无惧无畏，奔赴山海 </i>
        </div>
    </div>
    
    <div class="index-middle">
        <!-- Main Content -->
        


<div class="post-container">
    <div class="post-title">
        高性能计算学习导航
    </div>

    <div class="post-meta">
        <span class="attr">发布于：<span>2024-05-26 09:54:09</span></span>
        
        <span class="attr">标签：/
        
        <a class="tag" href="/tags/#超算" title="超算">超算</a>
        <span>/</span>
        
        
        </span>
        <span class="attr">访问：<span id="busuanzi_value_page_pv"></span>
</span>
</span>
    </div>
    <div class="post-content ">
        <p><strong>高性能程序</strong> = 数据结构 + 算法 + <strong>体系结构</strong></p>
<p>优化效果 = 深入思考 + 敢于尝试 + <strong>时间累积</strong></p>
<h1 id="学习资源"><a href="#学习资源" class="headerlink" title="学习资源"></a>学习资源</h1><ul>
<li><a target="_blank" rel="noopener" href="https://software.intel.com/sites/landingpage/IntrinsicsGuide/#cats=Arithmetic&amp;expand=3904,3913,4011,4014,4602,4011&amp;techs=MMX,SSE,SSE2,SSE3,SSSE3,SSE4_1,SSE4_2,AVX,AVX2,FMA,AVX_512,AMX,SVML,Other">intel Intrinsics Guide (opens new window)</a></li>
<li>OpenMP 和 MPI ：《<a target="_blank" rel="noopener" href="https://kaywu-images.oss-cn-beijing.aliyuncs.com/book/code/%E5%B9%B6%E8%A1%8C%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E5%AF%BC%E8%AE%BA.pdf">并行程序设计导论</a>》</li>
<li><a target="_blank" rel="noopener" href="https://www.starduster.me/2020/11/05/modern-microprocessors-a-90-minute-guide/">现代微处理器架构 90分钟指南</a></li>
<li><a target="_blank" rel="noopener" href="https://heptagonhust.github.io/HPC-roadmap/">高性能计算学习路线</a></li>
<li><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV14L4y157Bv/">shell 脚本学习-bilibili</a></li>
<li><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/571973164">快速入门：Slurm资源管理与作业调度系统</a></li>
<li><a href="https://vicczyq.github.io/2024/03/06/Makefile%E5%92%8CCMake/">CMake和Makefile</a></li>
</ul>
<h1 id="一、基础知识"><a href="#一、基础知识" class="headerlink" title="一、基础知识"></a>一、基础知识</h1><h2 id="1-1-并行计算"><a href="#1-1-并行计算" class="headerlink" title="1.1 并行计算"></a>1.1 并行计算</h2><p><strong>并行计算</strong>是指在计算过程中同时执行多个任务或操作，以提高计算效率的技术。与传统的串行计算相比，它能够利用多个处理单元或计算资源同时进行计算，从而更快地完成任务。</p>
<h3 id="1-1-1-分类："><a href="#1-1-1-分类：" class="headerlink" title="1.1.1 分类："></a>1.1.1 分类：</h3><ul>
<li><strong>指令级并行：</strong>CPU流水线</li>
<li><strong>分布式并行：</strong>MPI</li>
<li><strong>共享存储式并行：</strong>OpenMP、OpenACC、OpenCL</li>
</ul>
<h3 id="1-1-3-并行和并发的区别"><a href="#1-1-3-并行和并发的区别" class="headerlink" title="1.1.3 并行和并发的区别"></a>1.1.3 并行和并发的区别</h3><p><strong>并行：</strong>在<strong>同一时刻真正地并行处理多个任务</strong>，依赖于多处理器或多核心系统</p>
<p><strong>并发</strong>：是指多个任务在同一时间段内<strong>交替执行</strong>，但不一定是同时执行的。</p>
<h3 id="1-1-3-异构并行的概念"><a href="#1-1-3-异构并行的概念" class="headerlink" title="1.1.3 异构并行的概念"></a>1.1.3 异构并行的概念</h3><p>计算任务中使用具有不同架构的多种计算资源（例如CPU、GPU、神威主从核等）进行并行计算。</p>
<p><img src="/2024/05/26/%E9%AB%98%E6%80%A7%E8%83%BD%E8%AE%A1%E7%AE%97%E5%AD%A6%E4%B9%A0%E6%80%BB%E5%B8%96/image-20240523203637666.png" alt="image-20240523203637666"></p>
<h2 id="1-2-进程和线程"><a href="#1-2-进程和线程" class="headerlink" title="1.2 进程和线程"></a>1.2 进程和线程</h2><p><strong>进程：</strong><u>资源分配的最小单位</u>。是并发执行的程序在执行过程中分配和管理资源的基本单位，是一个动态概念，竞争计算机系统资源的基本单位。（资源分配）<br><strong>线程：</strong><u>CPU调度的最小单位</u>。是进程的一个执行单元，是进程内可调度实体。比进程更小的独立运行的基本单位。线程也被称为轻量级进程。（执行体）</p>
<ul>
<li>一个程序至少有一个进程，一个进程至少有一个线程</li>
<li>线程的划分尺度小于进程，使得多线程程序的并发性高</li>
<li>进程在执行过程中有独立的内存单元，而多线程之间是共享内存</li>
</ul>
<p><strong>OpenMP</strong></p>
<ol>
<li>并行粒度：线程级</li>
<li>数据分配方式：隐式（系统或编译器自动处理数据分配和管理）</li>
<li>共享存储，可扩展性差</li>
</ol>
<p><strong>MPI</strong></p>
<ol>
<li>并行粒度：进程级</li>
<li>数据分配方式：显式（由程序员自主分配）</li>
<li>分布式存储，可扩展性好</li>
</ol>
<h2 id="1-3-CPU内部架构"><a href="#1-3-CPU内部架构" class="headerlink" title="1.3 CPU内部架构"></a>1.3 CPU内部架构</h2><h3 id="1-3-1-指令流水线（pipeline）"><a href="#1-3-1-指令流水线（pipeline）" class="headerlink" title="1.3.1 指令流水线（pipeline）"></a>1.3.1 指令流水线（pipeline）</h3><p>以经典的5级流水线为例，一条指令的执行被分为5个阶段：</p>
<ul>
<li>取指（IF）：从内存中取出一条指令</li>
<li>译码（ID）：对指令进行解码，确定指令要执行的操作</li>
<li>执行（EX）：执行指令操作</li>
<li>访存（MEM）：内存访问操作</li>
<li>写回（WB）：执行结果写回寄存器或内存</li>
</ul>
<p><img src="/2024/05/26/%E9%AB%98%E6%80%A7%E8%83%BD%E8%AE%A1%E7%AE%97%E5%AD%A6%E4%B9%A0%E6%80%BB%E5%B8%96/2efd9ec72267748ff315f95e4959d13a.png" alt="img"></p>
<p>在CPU内部，执行每个阶段使用的是不同的硬件资源，从而可以让多条指令的执行时间相互重叠。</p>
<p><img src="/2024/05/26/%E9%AB%98%E6%80%A7%E8%83%BD%E8%AE%A1%E7%AE%97%E5%AD%A6%E4%B9%A0%E6%80%BB%E5%B8%96/d7e26bf2bf7f955559e36abee7a66c59.png" alt="img"></p>
<p>有了流水线技术，理想情况下，每个时钟周期，CPU可以完成一条指令的执行。那有没有什么方法，可以让CPU在每个时钟周期，完成多条指令的执行呢，这岂不是会大大提高CPU整体性能吗？这就是Superscalar技术！（还有VLIW技术）</p>
<h3 id="1-3-2-超标量（Superscalar）"><a href="#1-3-2-超标量（Superscalar）" class="headerlink" title="1.3.2 超标量（Superscalar）"></a>1.3.2 超标量（Superscalar）</h3><p>通过在CPU内部实现多条指令流水线，可以真正实现多条命令并行执行，也被称为<strong>多发射数据通路技术</strong></p>
<p><img src="/2024/05/26/%E9%AB%98%E6%80%A7%E8%83%BD%E8%AE%A1%E7%AE%97%E5%AD%A6%E4%B9%A0%E6%80%BB%E5%B8%96/438dfd2c0f9f9b798b403063f5858f88.png" alt="img"></p>
<h3 id="1-3-3-流水线冲突"><a href="#1-3-3-流水线冲突" class="headerlink" title="1.3.3 流水线冲突"></a>1.3.3 流水线冲突</h3><p>在理想情况下，上述设计十分完美，但是现实中程序的指令序列之间往往存在各种各样的<strong>依赖和相关性</strong>，而CPU为了解决这种指令间的依赖和相关性，有时候不得不“<strong>停顿</strong>”下来，直到这些依赖得到解决，这就导致CPU指令流水线无法总是保持“全速运行”。</p>
<h4 id="（1）数据冲突"><a href="#（1）数据冲突" class="headerlink" title="（1）数据冲突"></a>（1）数据冲突</h4><p>两条在流水线中并行执行的指令，<strong>第二条指令需要用到第一条指令的执行结果</strong>，因此第二条指令的执行不得不暂停，一直到可以获取到第一条指令的执行结果为止。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">x = 某些计算;</span><br><span class="line">y = x;</span><br></pre></td></tr></table></figure>
<h4 id="（2）控制冲突"><a href="#（2）控制冲突" class="headerlink" title="（2）控制冲突"></a>（2）控制冲突</h4><p>CPU在执行<strong>分支跳转时，无法预知下一条要执行的指令。</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(a &gt; <span class="number">100</span>) &#123;</span><br><span class="line">    x = <span class="number">1</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    y = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="（3）结构冲突"><a href="#（3）结构冲突" class="headerlink" title="（3）结构冲突"></a>（3）结构冲突</h4><p><strong>多条指令同时竞争同一个硬件资源</strong>，由于硬件资源短缺，无法同时满足所有指令的执行请求。如两条并行执行的命令需要同时访问内存，而内存地址译码单元可能只有一个，这就产生了结构冲突。</p>
<h2 id="1-4-高性能数学算法库"><a href="#1-4-高性能数学算法库" class="headerlink" title="1.4 高性能数学算法库"></a>1.4 高性能数学算法库</h2><p>基本概念：计算领域的基础软件库，是发挥硬件算力的基石，提高效率</p>
<p><img src="/2024/05/26/%E9%AB%98%E6%80%A7%E8%83%BD%E8%AE%A1%E7%AE%97%E5%AD%A6%E4%B9%A0%E6%80%BB%E5%B8%96/image-20240523180934242.png" alt="image-20240523180934242"></p>
<p>主流的硬件厂商都会为自身硬件提供优化了的算法库</p>
<ul>
<li><strong>Intel</strong> MKL</li>
<li><strong>IBM</strong> ESSL/PESSL</li>
<li><strong>AMD</strong> AOCL</li>
<li><strong>Nvidia</strong> CUDA-X</li>
</ul>
<h3 id="1-4-1-BLAS-LAPACK"><a href="#1-4-1-BLAS-LAPACK" class="headerlink" title="1.4.1 BLAS/LAPACK"></a>1.4.1 BLAS/LAPACK</h3><p><strong>BLAS：</strong>基础线性代数子程序，是一系列初级操作的规范，如向量之间的乘法，矩阵乘法等</p>
<p><strong>LAPACK：</strong>线性代数库，底层是BLAS，在此基础上定义了很多矩阵和高级运算函数，如矩阵分解、求逆等，运算效率比BLAS高</p>
<h3 id="1-4-2-PETSc"><a href="#1-4-2-PETSc" class="headerlink" title="1.4.2 PETSc"></a>1.4.2 PETSc</h3><p>底层为BLAS/LAPACK，用于高性能求解偏微积分方程组相关问题，目前PETSc所有消息传递均采用MPI实现。</p>
<p>支持Fortran 77/90、C/C++编写的串行和并行代码</p>
<h1 id="二、入门篇"><a href="#二、入门篇" class="headerlink" title="二、入门篇"></a>二、入门篇</h1><p>PS：在这之前最好学好C++的相关知识</p>
<h2 id="2-1-Pthread"><a href="#2-1-Pthread" class="headerlink" title="2.1 Pthread"></a>2.1 Pthread</h2><p><img src="/2024/05/26/%E9%AB%98%E6%80%A7%E8%83%BD%E8%AE%A1%E7%AE%97%E5%AD%A6%E4%B9%A0%E6%80%BB%E5%B8%96/image-20240521112131105.png" alt="image-20240521112131105"></p>
<p>pthread是许多并行模型的底层实现</p>
<p><strong>具体内容：</strong><a href="https://vicczyq.github.io/2024/05/21/Pthread">https://vicczyq.github.io/2024/05/21/Pthread</a></p>
<h2 id="2-2-OpenMP"><a href="#2-2-OpenMP" class="headerlink" title="2.2 OpenMP"></a>2.2 OpenMP</h2><p>以Pthread为基础开发的，面向多线程并行编程模型，极大简化了多线程编码，支持Fortran、C/C++</p>
<p>详细内容：<a href="https://vicczyq.github.io/2022/02/05/OpenMP学习">https://vicczyq.github.io/2022/02/05/OpenMP学习)</a></p>
<h1 id="三、基础篇"><a href="#三、基础篇" class="headerlink" title="三、基础篇"></a>三、基础篇</h1><h2 id="3-1-MPI"><a href="#3-1-MPI" class="headerlink" title="3.1 MPI"></a>3.1 MPI</h2><p>详细内容：<a href="https://vicczyq.github.io/2022/02/05/MPI%E5%AD%A6%E4%B9%A0/">https://vicczyq.github.io/2022/02/05/MPI%E5%AD%A6%E4%B9%A0/</a></p>
<h2 id="3-2-CUDA"><a href="#3-2-CUDA" class="headerlink" title="3.2 CUDA"></a>3.2 CUDA</h2><p>（内容不是很完善，待更……）</p>
<p>详细内容：<a href="https://vicczyq.github.io/2022/02/05/CUDA%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/">https://vicczyq.github.io/2022/02/05/CUDA%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/</a></p>
<h2 id="3-3-性能分析"><a href="#3-3-性能分析" class="headerlink" title="3.3 性能分析"></a>3.3 性能分析</h2><h3 id="3-3-1-静态分析工具"><a href="#3-3-1-静态分析工具" class="headerlink" title="3.3.1 静态分析工具"></a>3.3.1 静态分析工具</h3><p>利用代码静态分析，对代码进行数据对象、函数接口封装和调用分析</p>
<p>主流的工具：<strong>Understand</strong>、SourceInsight、DeepScan、deepsource、VERACODE</p>
<p>以Understand为例：<a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_40513792/article/details/111991978">https://blog.csdn.net/qq_40513792/article/details/111991978</a></p>
<h3 id="3-3-2-动态分析工具"><a href="#3-3-2-动态分析工具" class="headerlink" title="3.3.2 动态分析工具"></a>3.3.2 动态分析工具</h3><p>实际运行过程中调用了哪些函数。</p>
<p>主流的工具：gprof、intel vtune profiler、Perf等</p>
<h4 id="Perf"><a href="#Perf" class="headerlink" title="Perf"></a>Perf</h4><p>使用教程：<a target="_blank" rel="noopener" href="https://xingyuanjie.top/2022/01/19/tool003/">Amicoyuan-perf-系统级性能分析工具</a></p>
<h4 id="gprof（GNU-profile）"><a href="#gprof（GNU-profile）" class="headerlink" title="gprof（GNU profile）"></a>gprof（GNU profile）</h4><p><strong>注意：</strong><u>不适用于多线程程序，只会记录主线程。</u></p>
<p>用gcc、g++等编译程序时，使用-pg参数，编译器会在原代码中插入用于性能测试的代码片断</p>
<p>如：<code>g++ -pg -o test test.cpp</code></p>
<p>执行编译后的可执行程序，如：<code>./test</code></p>
<p>程序运行结束后，会在程序所在路径下生成一个缺省文件名为gmon.out的文件</p>
<p>最后使用<code>gprof test gmon.out &gt; output.txt</code>即可</p>
<p><img src="/2024/05/26/%E9%AB%98%E6%80%A7%E8%83%BD%E8%AE%A1%E7%AE%97%E5%AD%A6%E4%B9%A0%E6%80%BB%E5%B8%96/image-20240523190516990.png" alt="image-20240523190516990"></p>
<h4 id="intel-vtune-profiler"><a href="#intel-vtune-profiler" class="headerlink" title="intel vtune profiler"></a>intel vtune profiler</h4><p>针对于英特尔处理器。</p>
<h2 id="3-4-SIMD"><a href="#3-4-SIMD" class="headerlink" title="3.4 SIMD"></a>3.4 SIMD</h2><p>AVX：Advanced Vector Extension 高级向量扩展</p>
<p>AVX是SIMD（单指令多数据）指令，可以用一条指令产生多个并行操作。</p>
<p><strong>寄存器位宽：</strong></p>
<ul>
<li>SSE：128bit</li>
<li>AVX/AVX2：256bit</li>
<li>AVX512：512bit</li>
</ul>
<p>因为AVX/AVX2都支持256bit，所以可以统称为AVX256</p>
<p>更多内容见：<a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_17075011/article/details/130555559">https://blog.csdn.net/qq_17075011/article/details/130555559</a></p>
<h1 id="四、其他常用优化手段"><a href="#四、其他常用优化手段" class="headerlink" title="四、其他常用优化手段"></a>四、其他常用优化手段</h1><h2 id="4-1-常用循环优化技术"><a href="#4-1-常用循环优化技术" class="headerlink" title="4.1 常用循环优化技术"></a>4.1 常用循环优化技术</h2><h3 id="（1）输入值嵌入"><a href="#（1）输入值嵌入" class="headerlink" title="（1）输入值嵌入"></a><strong>（1）输入值嵌入</strong></h3><p>将运行时需要从文件读入的关键数据转换为编译时的静态可知数据</p>
<p>例子如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    FILE *file;</span><br><span class="line">    <span class="type">int</span> value;</span><br><span class="line">    file = <span class="built_in">fopen</span>(<span class="string">&quot;data.txt&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (file == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;Error opening file&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">fscanf</span>(file, <span class="string">&quot;%d&quot;</span>, &amp;value) != <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;Error reading integer from file&quot;</span>);</span><br><span class="line">        <span class="built_in">fclose</span>(file);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">fclose</span>(file);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Read value: %d\n&quot;</span>, value);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果我已经知道需要读入的数据value的值为0，就可以直接采用宏定义或者静态变量的方法，不需要去读入</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> value 3</span></span><br></pre></td></tr></table></figure>
<h3 id="（2）分支消除"><a href="#（2）分支消除" class="headerlink" title="（2）分支消除"></a><strong>（2）分支消除</strong></h3><p>消除循环中的分支，减少分支判断和跳转</p>
<p>也可以用补码/位运算</p>
<p>例如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++)&#123;</span><br><span class="line">	<span class="keyword">if</span>(i&lt;<span class="number">30</span>)&#123; <span class="comment">//执行A操作 &#125;</span></span><br><span class="line">	<span class="keyword">else</span>&#123; <span class="comment">//执行B操作 &#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>修改为：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">30</span>; i++)&#123;</span><br><span class="line"><span class="comment">//执行A操作</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">30</span>; j &lt; <span class="number">100</span>; j++)&#123;</span><br><span class="line"><span class="comment">//执行B操作</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="（3）循环合并"><a href="#（3）循环合并" class="headerlink" title="（3）循环合并"></a><strong>（3）循环合并</strong></h3><p>每次循环需要对循环条件进行判断（i&lt;N?）循环合并可以减少判断次数。</p>
<p>如果A，B操作数据有关联，甚至可以减少IO</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; i++)&#123;</span><br><span class="line">	<span class="comment">//执行A操作</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; N; j++)&#123;</span><br><span class="line">	<span class="comment">//执行B操作</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>修改为</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; i++)&#123;</span><br><span class="line">	<span class="comment">//执行A操作</span></span><br><span class="line">	<span class="comment">//执行B操作</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="（4）次序交换"><a href="#（4）次序交换" class="headerlink" title="（4）次序交换"></a><strong>（4）次序交换</strong></h3><p>C/C++存储是按<strong>行优先</strong>存储，Fortran是<strong>列优先</strong>存储</p>
<p>在对数据进行访问时，最好按照顺序进行访问。</p>
<p>原理是最大化利用高速缓存Cache</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; i++)&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; N; j++)&#123;</span><br><span class="line">		cout &lt;&lt; array[j][i]; <span class="comment">//列优先顺序访问</span></span><br><span class="line">        cout &lt;&lt; array[i][j]; <span class="comment">//行优先顺序访问</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="（5）循环分块"><a href="#（5）循环分块" class="headerlink" title="（5）循环分块"></a>（5）循环分块</h3><p>目的是<strong>提高Cache的命中率</strong>，</p>
<p>一个<code>Cache line</code>被使用过之后，后面可能还会使用，但是默认循环的方式，到下次要使用的时候<code>Cache line</code>已经被替换。</p>
<p>于是我们就把循环重新排一下，使得一个<code>Cache line</code>在被替换之前就能被再次使用</p>
<p><strong>例：</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; N; i++)&#123;</span><br><span class="line">	<span class="keyword">for</span>(j = <span class="number">0</span>; j &lt; M; j++)&#123;</span><br><span class="line">		A[i] = A[i] + B[j];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果当前<code>Cache Line</code>的大小为 <strong>b</strong> ，A的cache miss次数就为<code>N/b</code>，B的cache miss次数为<code>N*M/b</code></p>
<p><img src="/2024/05/26/%E9%AB%98%E6%80%A7%E8%83%BD%E8%AE%A1%E7%AE%97%E5%AD%A6%E4%B9%A0%E6%80%BB%E5%B8%96/image-20240523163713301.png" alt="image-20240523163713301"></p>
<p>因此就可以划分块，令块大小为<strong>T</strong>（一般是b的整数倍，也要足够小）</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(jj = <span class="number">0</span>; jj &lt; M; jj += T)&#123;</span><br><span class="line">	<span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; N; i++)&#123;</span><br><span class="line">		<span class="keyword">for</span>(j = <span class="number">0</span>; j &lt; jj+T; j++)&#123;</span><br><span class="line">			A[i] = A[i] + B[j];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="（6）循环展开"><a href="#（6）循环展开" class="headerlink" title="（6）循环展开"></a>（6）循环展开</h3><p>循环条件判断次数减少，更大的代码块有更多优化手段</p>
<p>现在有一个代码</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">calc</span><span class="params">(<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> fact = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++)&#123;</span><br><span class="line">		fact *= i;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> fact;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对代码进行循环展开，假设n是4的倍数（如果不是4的倍数要边界处理）</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//test_1</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">calc</span><span class="params">(<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> fact0 = <span class="number">1</span>, fact1 = <span class="number">1</span>, fact2 = <span class="number">1</span>, fact3 = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i+=<span class="number">4</span>)&#123;</span><br><span class="line">		fact0 *= i;</span><br><span class="line">        fact1 *= i+<span class="number">1</span>;</span><br><span class="line">        fact2 *= i+<span class="number">2</span>;</span><br><span class="line">        fact3 *= i+<span class="number">3</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> fact0 * fact1 * fact2 * fact3;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//test_2</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">calc</span><span class="params">(<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> fact = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i+=<span class="number">4</span>)&#123;</span><br><span class="line">		fact *= i;</span><br><span class="line">        fact *= i+<span class="number">1</span>;</span><br><span class="line">        fact *= i+<span class="number">2</span>;</span><br><span class="line">        fact *= i+<span class="number">3</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> fact;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>test_2和test_1都属于循环展开，但是test_1效果更好</p>
<p><strong>内容前提补充：</strong><a href="#1.3 CPU内部架构">流水线</a>，见 1.3</p>
<p>test_1是这样展开的</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">fact0 *= i;</span><br><span class="line">fact1 *= i+<span class="number">1</span>;</span><br><span class="line">fact2 *= i+<span class="number">2</span>;</span><br><span class="line">fact3 *= i+<span class="number">3</span>;</span><br></pre></td></tr></table></figure>
<p>test_2是这样展开的</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">fact *= i;</span><br><span class="line">fact *= i+<span class="number">1</span>;</span><br><span class="line">fact *= i+<span class="number">2</span>;</span><br><span class="line">fact *= i+<span class="number">3</span>;</span><br></pre></td></tr></table></figure>
<p>很明显，test_2的后一条指令执行前，必须知道前一条指令的计算结果，这也就是<strong>数据依赖</strong>，造成流水线冲突。</p>
<p>虽然通过循环展开，减少了无用指令，也减少了热点路径上分支跳转引起的流水线控制冲突，但它同时引入了数据依赖，进而导致流水线冲突，仍然无法发挥流水线和superscalar的指令级并行执行的能力！</p>
<h4 id="补充：优化热点路径内存访问"><a href="#补充：优化热点路径内存访问" class="headerlink" title="补充：优化热点路径内存访问"></a>补充：优化热点路径内存访问</h4><p>定义局部变量时加上<code>register</code>关键字即可，</p>
<p>作用是建议编译器尽可能把变量放在寄存器中，以求更快的访问速度</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">calc</span><span class="params">(<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">	<span class="keyword">register</span> <span class="type">int</span> fact0 = <span class="number">1</span>, fact1 = <span class="number">1</span>, fact2 = <span class="number">1</span>, fact3 = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">register</span> <span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i+=<span class="number">4</span>)&#123;</span><br><span class="line">		fact0 *= i;</span><br><span class="line">        fact1 *= i+<span class="number">1</span>;</span><br><span class="line">        fact2 *= i+<span class="number">2</span>;</span><br><span class="line">        fact3 *= i+<span class="number">3</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> fact0 * fact1 * fact2 * fact3;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="4-2-cache优化"><a href="#4-2-cache优化" class="headerlink" title="4.2 cache优化"></a>4.2 cache优化</h2><h3 id="4-2-1-指令cache优化"><a href="#4-2-1-指令cache优化" class="headerlink" title="4.2.1 指令cache优化"></a>4.2.1 指令cache优化</h3><p>将需要多次调用的函数设置为内联函数<code>inline</code>，减少函数调用开销</p>
<p> <code>inline</code> 关键字可以建议编译器在调用该函数的地方直接插入函数代码，而不是执行正常的函数调用。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> result = <span class="built_in">add</span>(<span class="number">3</span>, <span class="number">4</span>);  <span class="comment">// 此处展开为 int result = 3 + 4;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="4-2-2-数据cache优化"><a href="#4-2-2-数据cache优化" class="headerlink" title="4.2.2 数据cache优化"></a>4.2.2 数据cache优化</h3><p><strong>数据预取：</strong>在本次计算中，预取下一次需要的数据。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用GCC内置函数实现</span></span><br><span class="line"><span class="type">void</span> __builtin_prefetch(<span class="type">const</span> <span class="type">void</span> *addr, <span class="type">int</span> rw, <span class="type">int</span> locality);</span><br><span class="line"><span class="comment">//addr：指向预取数据的地址。</span></span><br><span class="line"><span class="comment">//rw：预取的意图，0 表示预取用于读取（默认），1 表示预取用于写入。</span></span><br><span class="line"><span class="comment">//locality：数据的局部性提示，范围是 0 到 3，数值越高表示数据将被频繁访问，因此应尽量保持在缓存中。</span></span><br></pre></td></tr></table></figure>
<p><strong>数据重排：</strong>把数据重新排列（行优先或列优先），使其对Cache访问更为友好，减少Cache miss</p>
<h2 id="4-3-逻辑优化"><a href="#4-3-逻辑优化" class="headerlink" title="4.3 逻辑优化"></a>4.3 逻辑优化</h2><p>选择合适编译级别（O0\O1\O2\O3\Ofast）</p>
<p>使用register关键字，将常访问变量放入寄存器</p>
<p>使用快速数学计算（-ffast-math）等</p>

        
        <br />
        <div id="comment-container">
        </div>
        <div id="disqus_thread"></div>
        <div id="lv-container"></div>
        <div class="giscus"></div>
    </div>
</div>

    </div>
</div>


<footer class="footer">
    <ul class="list-inline text-center">
        
        

        

        

        

        

    </ul>
    

<p id="hitokoto">加载中...</p>

<script>
    fetch('https://tenapi.cn/v2/yiyan')
        .then(response => response.text())
        .then(text => {
            document.getElementById('hitokoto').innerText = text;
        })
        .catch(error => {
            console.error('请求失败:', error);
        });
</script>
 <p>
        <span id="busuanzi_container_site_pv">
            <span id="busuanzi_value_site_pv"></span>PV
        </span>
        <span id="busuanzi_container_site_uv">
            <span id="busuanzi_value_site_uv"></span>UV
        </span>
        Created By <a target="_blank" rel="noopener" href="https://hexo.io/">Hexo</a>
 </p>
</footer>




<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        tex2jax: {
            inlineMath: [ ["$","$"], ["\\(","\\)"] ],
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
            processEscapes: true
        }
    });
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax();
        for (var i = 0; i < all.length; ++i)
            all[i].SourceElement().parentNode.className += ' has-jax';
    });
</script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-MML-AM_CHTML"></script>
</body>

<script>
    // We expose some of the variables needed by the front end
    window.hexo_search_path = "search.json"
    window.hexo_root = "/"
    window.isPost = true
</script>
<script src="https://cdn.bootcss.com/jquery/3.3.1/jquery.min.js"></script>

<script src="/js/index.js"></script>

<!-- <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script> -->






</html>
