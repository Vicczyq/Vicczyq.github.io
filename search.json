[{"title":"C++","url":"/2024/02/29/C/"},{"title":"一刻","url":"/2024/02/07/一刻/","content":"\n## 生日\n\n高思雨：正月初八\n\n阿姨：正月十四\n\n姐姐：七月十四\n\n余泓材：七月廿二\n\n爸爸：八月初六\n\n爷爷：八月十四\n\n奶奶：腊月初二\n\n妈妈：腊月初三\n\n陈臣：腊月初八\n\n## 纪念日\n\n周年：21年11月9日\n\n1th约会：22年1月21日\n","tags":["重要"]},{"title":"计算机组成原理-(2)","url":"/2024/02/06/计算机组成原理二/","content":"\n# 一、存储系统\n\n## 1.1数据存储和排列\n\n### 1.1.1大小端模式\n\n若有4字节的 int：01 23 45 67 H\n\n多字节数据在内存里一定是占**连续的**几个字节，01为最高有效字节(MSB)，67为最低有效字节(LSB)\n\n**大端方式：**便于人类阅读\n\n![image-20240206163512612](计算机组成原理二/image-20240206163512612.png)\n\n**小端方式：**便于机器处理\n\n![image-20240206163632872](计算机组成原理二/image-20240206163632872.png)\n\n### 1.1.2边界对齐\n\n假设存储字长为32位，则1个字=32bit，半字=16bit。每次访存只能读/写1个字\n\n**边界对齐的方式：**\n\n![image-20240206170756798](计算机组成原理二/image-20240206170756798.png)\n\n**边界不对齐方式：**\n\n![image-20240206170910990](计算机组成原理二/image-20240206170910990.png)\n\n由于边界不对齐，若要读取半字1，则先要读取第一个字(第一行)，再读取第二个字(第二行)，最后将半字1-1和半字1-2拼接。所以访问**一个字/半字**可能需要**两次访存**\n\n采用边界对齐的方式，访问**一个字/半字**都只需要一次访存即可。牺牲掉部分空间，但是能加快访存效率。\n\n## 1.2浮点数的表示和运算\n\n### 1.2.1前言\n\n**定点数的局限性：**定点数可以表示的数字范围有限，但我们不能无限制的增加数据长度\n\n### 1.2.2浮点数的表示\n\n$$\n可以类似于科学计数法，+3.026×10^{+21}\n\\\\+/-表示小数点后移/前移多少位\n\\\\浮点数的真值:N=r^E×M\n\\\\r为阶码的底，通常为2（二进制）\n\\\\E反应浮点数表示范围以及小数点的真是位置\n\\\\M数值部分的位数反应浮点数的精度\n\\\\阶码:常用补码或移码表示的定点整数\n\\\\尾数:常用原码或补码表示的定点小数\n$$\n\n![image-20240206171958125](计算机组成原理二/image-20240206171958125.png)\n\n\n\n### 1.2.3浮点数尾数规格化\n\n![image-20240206174421304](计算机组成原理二/image-20240206174421304.png)\n\n## 1.3存储器\n\n### 1.3.1存储器的层次结构\n\n![image-20240208143405738](计算机组成原理二/image-20240208143405738.png)\n\n**辅存：**磁盘、可移动介质\n\n辅存中的数据要调入到主存中才能被CPU访问\n\n![image-20240208145434194](计算机组成原理二/image-20240208145434194.png)\n\n**缓存：**高速缓冲存储器Cache\n\n**主存-辅存：**实现了虚拟存储系统，解决了主存容量不足的问题\n\n**Cache-主存：**解决了主存与CPU速度不匹配的问题\n\n### 1.3.2存储器的分类\n\n#### 1.3.2.1按计算机中的层次分类\n\n(1)主存储器。简称**主存**，又称为**内存**。用来存放计算机**运行期间**所需的程序和数据，CPU可以直接随机的对其进行访问，也可以利用Cache间接访问。\n\n(2)辅助存储器。简称**辅存**，又称**外存**。用来存放暂时不用的程序和数据，以及一些永久性保存的信息。辅存的内容要调入主存后才能被CPU访问。\n\n(3)高数缓冲存储器。简称**Cache**，用来存放CPU经常使用的指令和数据，CPU可以高速访问他们。\n\n#### 1.3.2.2按存储介质分类\n\n磁表面存储器(磁盘、磁带)、磁芯存储器、半导体存储器(MOS型存储器、双极型存储器)和光存储器(光盘)\n\n#### 1.3.2.3按信息的可保存性分类\n\n易失性存储器：RAM\n\n非易失性存储器：ROM\n\n### 1.3.3存储器芯片的基本原理\n\n ![image-20240209152642087](计算机组成原理二/image-20240209152642087.png)\n$$\n控制电路：等待MAR稳定后才进行译码操作，等待MDR稳定后才进行读写操作\n\\\\片选线 (\\overline{CS}或\\overline{CE})：一个内存条上可能包含多块存储芯片,用于选择芯片(Chip Select或Chip Enable)\n\\\\读控制线(\\overline{WE})：允许写\n\\\\写控制线(\\overline{OE})：允许读\n$$\n\n### 1.3.4DRAM和SRAM\n\nDynamic Random Access Memory，即**动态RAM**\n\nStatic Random Access Memory，即**静态RAM**\n\nDRAM用于主存，SRAM用于Cache\n\n\n\nDRAM依靠<font color=red>栅极电容</font>实现，SRAM依靠<font color=green>双稳态触发器</font>实现\n\n![image-20240225134448490](计算机组成原理二/image-20240225134448490.png)\n\n```\n栅极电容放电信息会被破坏，是破坏性读出。读出后需要“重写”操作，也成为“再生”。\n双稳态触发器无需重写，是非破坏性读出。\n```\n\n由于SRAM不需要重新所以读出速度更快，但是成本更高。并且由于存储元制造更复杂，集成度就更低。\n\n**注意：**DRAM和SRAM都是易失性的（断电后信息会消失）\n\n#### 1.3.4.1 DRAM的刷新\n\n由于DRAM电容内的电荷只能维持2ms。即便不断电，2ms后信息也会消失，所以要不断的进行刷新(充电)\n\n### 1.3.5 ROM\n\nROM芯片--非易失，断电后数据仍然可以保存\n\n```\nMROM:掩模式只读存储器(厂家按客户需求在生产过程中写入，之后不可重写)\nPROM:可编程只读存储器(用户可以用专门的写入器写入信息，之后不可重写)\nEPROM:可擦除可编程只读存储器(允许用户写入，之后擦除，可以多次重写)\nUVEPROM:紫外线照射可擦除所有信息\nEEPROM:电擦除，可擦除特定的字\n\nFlash Memory:闪速存储器(U盘，SD卡)\n注意：闪存需要先擦除再写入，因此\"写\"速度比\"读\"速度更慢\nSSD：固态硬盘(由控制单元和Flash芯片构成)\n```\n\n计算机启动时，主存RAM没有任何指令，所以需要主板上的BIOS芯片(ROM)存储了\"自举装入程序\"，负责引导装入操作系统\n\n### 1.3.6 内存扩展\n\n#### 1.3.6.1 位扩展-增加主存的存储字长\n\n![image-20240229103326507](计算机组成原理二/image-20240229103326507.png)\n\n以此类推，拓展为8位，连接方式如下：\n\n![image-20240229103815314](计算机组成原理二/image-20240229103815314.png)\n\n8片8Kx1位的存储芯片 -> 8Kx8位的存储器，容量为8KB(64Kbit)\n\n#### 1.3.6.2 字扩展-增加主存的存储字数\n\n利用片选使能线进行，(1-2译码器)，利用A13的两种状态进行选择\n\n![image-20240229105813018](计算机组成原理二/image-20240229105813018.png)\n\n利用2-4译码器进行扩展：\n\n![image-20240229110201046](计算机组成原理二/image-20240229110201046.png)\n\n#### 1.3.6.3 字位同时扩展\n\n![image-20240229110325854](计算机组成原理二/image-20240229110325854.png)\n\n## 1.4 Cache\n\n### 1.4.1 Cache的基本概念和原理\n\nCPU需要从主存一条一条地读取指令，CPU处理速度很快，内存(主存)的读写速度很慢，导致速度不匹配，执行效率就会很低，因此引入Cache\n\n![image-20240229111235187](计算机组成原理二/image-20240229111235187.png)Cache的读写速度很快，可以缓和速度矛盾\n\n<font color=red>空间局限性：</font>在最近的未来要用到的信息(指令和数据)，很可能与现在正在使用的信息在存储空间上是相邻的\n\n<font color=red>时间局限性：</font>在最近的未来要用到的信息，很可能是现在正在使用的信息\n\n根据两个原理可以发现，可以把CPU目前访问地址\"周围\"的部分数据放到Cache中\n\n#### 1.4.1.1性能分析\n\n$$\n设t_c为访问一次Cache所需时间，t_m为访问一次主存锁需要的时间\\\\\n命中率H：CPU访问的信息已在Cache中的概率\\\\\n缺失率M=1-H\\\\\n系统的平均访问时间t为:\\\\\nt=Ht_c+(1-H)(t_c+t_m)\n$$\n\n上述例子CPU会优先访问Cache，若Cache missed(未命中)再访问主存\n\n还存在一种CPU<font color=red>同时访问</font>Cache和主存，若Cache命中则立即停止访问主存的方式\n$$\nt=Ht_c+(1-H)t_m\\\\\n$$\n\n因此存在两种方式\n\n\n\n#### 1.4.1.2数据交换\n\n将主存的存储空间进行\"分块\"，如：每1KB为一块，主存和Cache之间以\"<font color=green>块</font>\"为单位进行数据交换\n\n![image-20240229113716226](计算机组成原理二/image-20240229113716226.png)\n\n注意：每次被访问的主存块，一定会被立即调入Cache\n\n#### 1.4.1.3Cache和主存的映射方式\n\n**(1)全相联映射(随意放)**\n\n标记：记录主存块的索引\n\n![image-20240229122754368](计算机组成原理二/image-20240229122754368.png)\n$$\n假设某个计算机内存地址空间大小为256MB，按字节编址，其数据Cache有8个Cache行(即Cache块)，行长为64B\\\\\n256MB=2^{28}B\\\\\n默认一个存储单元为1字节(1B)因此有2^{28}个地址\\\\\n因此，块内地址为6位，主存块号有22位\n$$\n访存过程：\n\n- ①主存地址的前22位对比Cache中所有块的标记\n- ②若标记匹配且有效位为1，则Cache命中，访问块内地址单元\n- ③若未命中则正常进行访问主存\n\n**(2)直接映射**\n\n每个主存块只能放到一个特定的位置：\n$$\nCache块号=主存块号\\%Cache总块数\n$$\n![image-20240229123419792](计算机组成原理二/image-20240229123419792.png)\n\n**(3)组相联映射**\n\nCache块氛围若干组，每个主存块可以存放到特定分组的任意一个位置\n$$\n组号=主存块号\\%分组数\n$$\n![image-20240229123614460](计算机组成原理二/image-20240229123614460.png)\n\n\n\n### 1.4.2 替换算法\n\n#### 1.4.2.1随机算法(RAND)\n\n若Cache已满，则随机选择一块进行替换\n\n![image-20240229125852091](计算机组成原理二/image-20240229125852091.png)\n\n随机算法实现简单，但是没考虑局部性，命中率低，实际效果很不稳定\n\n#### 1.4.2.2先进先出算法(FIFO)\n\n若Cache已满，则替换最先被调入的Cache块\n\n![image-20240229130033994](计算机组成原理二/image-20240229130033994.png)\n\n实现简单，但依然没有考虑局部性，最先被调入Cache的块也有可能是被频繁访问的\n\n#### 1.4.2.3近期最少使用算法(LRU,Least Recently Used)\n\n为每一个Cache块设置一个\"计数器\"，用于记录每个块已经多久没有被访问，当Cache满后替换\"计数器\"最大的\n\n![image-20240229130404308](计算机组成原理二/image-20240229130404308.png)\n\n- 命中时，所命中的块的计数器要<font color=red>清零</font>，其余不变\n- 未命中且还有空闲块时候，新装入的块的计数器<font color=red>置零</font>，其余非空闲块全加1\n- 未命中且无空闲块时，计数值最大的块被淘汰，新装入的块的计数器置零，其余加1\n\n#### 1.4.2.4最不经常使用算法(LFU,Least Frequently Used)\n\n为每一个Cache块设置一个\"计数器\"，用于记录每个Cache块被访问了几次，当Cache满后替换\"计数器\"最小的\n\nPS：若有多个最小的块，可按行号递增或FIFO策略进行替换\n\n![image-20240229131139169](计算机组成原理二/image-20240229131139169.png)\n\n### 1.4.3 Cache写策略(数据一致性)\n\n#### 1.4.3.1写命中\n\n(**1)写回法**\n\n![image-20240229132354989](计算机组成原理二/image-20240229132354989.png)\n\n**(2)全写法**\n\n![image-20240229132301833](计算机组成原理二/image-20240229132301833-1709184184141-1.png)\n\n使用写缓冲，CPU的写速度很快，若写操作很频繁，可能回因为写缓冲饱和而发生阻塞，此时CPU就要等待。\n\n#### 1.4.3.2写不命中\n\n**（1）写分配法(write-allocate)**\n\n当CPU对Cache写不命中时，把主存的块调入Cache，再在Cache中修改，最后采用<font color=red>写回法</font>\n\n**（2）非写分配法**\n\n当CPU对Cache写不命中时，只写入主存，不调入Cache，搭配<font color=red>全写法</font>使用\n\n## 1.5页式存储器\n\n一个程序(进程)在逻辑上被分为若干个大小相等的\"页面\"，\"页面\"大小与\"块\"的大小相等，每个页面可以离散的放在不同的主存块中。\n\n背景解析：如果不这样做，就需要在主存中寻找到连续的空间，导致主存利用率不高。\n\n### 1.5.1地址变换方式\n\n![image-20240229134940178](计算机组成原理二/image-20240229134940178.png)\n\n### 1.5.2引入快表(TLB)的变换\n\n![image-20240229135553300](计算机组成原理二/image-20240229135553300.png)\n\n","tags":["计算机基础"]},{"title":"hexo博客文章加密","url":"/2024/01/29/hexo博客文章加密/","content":"\n静态博客加密插件：[hexo-blog-encrypt](https://www.npmjs.com/package/hexo-blog-encrypt)，搭配此插件你可以写一些私密博客，通过密码验证的方式让人不能随意浏览。\n\n### 安装：\n\n```shell\nnpm install hexo-blog-encrtpt\n```\n\n### 用法：\n\n文章头添加关键字<font color=red>password</font>即可设置文章访问密码\n\n```c\n---\ntitle: Hello World\ndate: 2016-03-30 21:18:02\npassword: hello\n---\n```\n\n高级用法：\n\n```c\n---\ntitle: Hello World\ndate: 2016-03-30 21:12:21\npassword: hello\nabstract: Here's something encrypted, password is required to continue reading.\nmessage: Hey, password is required here.\nwrong_pass_message: Oh, this is an invalid password. Check and try again, please.\n---\n```\n\n- `abstract`：用于设置加密文章显示的摘要。\n- `message`：输入密码提示。\n- `wrong_pass_message`: 输入错误提示。\n","tags":["hexo"]},{"title":"HPCGame记录","url":"/2024/01/23/HPCGame记录/","content":"\n前言：参加完ASC，回家两天，看到HPCGame开赛心痒痒\n\n## A.欢迎参赛！\n\n这个题就是介绍一下比赛的相关内容，直接提交后就会返回提供的集群账号密码\n\n## B.流量席卷土豆\n\n  [流量席卷土豆.mhtml](流量席卷土豆.mhtml) \n\n这个题挺有意思的，刚开始看到题的时候说实话我人有点慌了(好多字)冷静下来认真读题后发现，就是一个作业提交和软件使用而已。\n\n**解题步骤如下：**\n\n1、srun提交命令提取 SSH 流量：\n\n（赛题中提供的路径有问题，找了一下还有一层子目录pcaps）\n\n```\nsrun -p C064M0256G -N4 --ntasks-per-node=4 bash -c 'tshark -r /lustre/shared_data/potato_kingdom_univ_trad_cluster/pcaps/$SLURM_PROCID.pcap -Y ssh -w $SLURM_PROCID.ssh.pcap'\n```\n\n当前路径就会得到如下文件\n\n![image-20240123134122253](HPCGame记录/image-20240123134122253.png)\n\n2、合并 PCAP 文件：\n\n```\nmergecap -w merged.pcap *.ssh.pcap\n```\n\n![image-20240123134322241](HPCGame记录/image-20240123134322241.png)\n\n3、破解密码：\n\n```\nquantum-cracker merged.pcap\n```\n\n![image-20240123134517990](HPCGame记录/image-20240123134517990.png)\n\n4、获取 Slurm JobID\n\n```\nsacct -u $(whoami) --format JobID | tail\n```\n\n![image-20240123134612339](HPCGame记录/image-20240123134612339.png)\n\n取最后一个的整数，提交即可。\n\n## C.简单的编译\n\n [简单编译.mhtml](简单编译.mhtml) \n\n这道题就是写Makefile和CMakeLists.txt\n\n```\n在本题中，你需要写一个简单的Makefile文件，和一个简单的CMakeLists.txt文件，来编译 Handout 中所提供的三个简单程序。\n\n其中，hello_cuda.cu是一个简单的cuda程序，hello_mpi.cpp是一个简单的mpi程序，hello_omp.cpp是一个简单的 OpenMP 程序。它们都做了同一个简单的事情：从文件中读取一个向量并求和。\n\n你需要上传Makefile和CMakeLists.txt文件。我们会根据以下策略来评测你所写的配置文件的正确性。\n\n对于Makefile文件，我们会在项目根目录下执行make命令。然后在项目根目录下检查程序是否被生成，并运行以检测正确性。\n对于CMakeLists.txt文件，我们会在项目根目录下执行mkdir build; cd build; cmake ..; make。然后我们会在build目录下检查程序是否被正确生成，并运行以检测正确性。\n对于所有类型的文件，hello_cuda.cu所编译出的文件名应为hello_cuda；hello_mpi.cpp所编译出的文件名应为hello_mpi；hello_omp.cpp所编译出的文件名应为hello_omp。\n```\n\n集群GPU节点连不上，用记事板手搓了一下，提交上去Makefile一直报错，\n\n查了一下是tab缩进的问题，后来在终端里面用vim编写，复制，完美解决\n\n（长记性了，用vim来编辑才能正常识别tab）\n\n```makefile\n.PHONY: all clean\n\nall: hello_cuda hello_mpi hello_omp\n\nhello_cuda: hello_cuda.cu\n\tnvcc -o hello_cuda hello_cuda.cu\n\nhello_mpi: hello_mpi.cpp\n\tmpic++ -o hello_mpi hello_mpi.cpp\n\nhello_omp: hello_omp.cpp\n\tg++ -fopenmp -o hello_omp hello_omp.cpp\n\nclean:\n\trm -f hello_cuda hello_mpi hello_omp\n```\n\n```cmake\ncmake_minimum_required(VERSION 3.10)\nproject(test)\n\nenable_language(CUDA)\nadd_executable(hello_cuda hello_cuda.cu)\n\nfind_package(MPI REQUIRED)\nadd_executable(hello_mpi hello_mpi.cpp)\ntarget_link_libraries(hello_mpi MPI::MPI_CXX)\n\nfind_package(OpenMP REQUIRED)\nadd_executable(hello_omp hello_omp.cpp)\ntarget_link_libraries(hello_omp OpenMP::OpenMP_CXX)\n```\n\n## D.小北问答 Classic\n\n [小北问答 Classic.mhtml](小北问答.mhtml) \n\n![image-20240123135107256](HPCGame记录/image-20240123135107256.png)\n\n```\n答案：{\"t1\":\"65.396\",\"t2.1\":\"105.26\",\"t2.2\":\"107.14\",\"t3\":\"iv. GCC\",\"t4.1\":\"ii. 进程\",\"t4.2\":\"i. 线程\",\"t4.3\":\"i. 线程\",\"t5.1\":\"8\",\"t5.2\":\"i. 在 CPU 中设计独立的 AVX512 运算单元，但有可能导致调用 AVX512 指令集时因功耗过大而降频\",\"t5.3\":\"ii. 复用两个 AVX2 运算单元执行 AVX512 运算\",\"t6\":\"iv. OpenGL\",\"t8\":\"iv. PCIe\",\"t9\":\"ii. Slurm\",\"t10\":\"i. 缓存未命中\",\"t7\":\"iii,iv\"}\n```\n\n## E.齐心协力\n\n [齐心协力.mhtml](齐心协力.mhtml) \n\n这道题卡了两天，Ray集群老是出错，后来偶然交了一发过了\n\n后来发现提示里有放置组的概念，学习了一下，改了一下代码，111.6/120分，满足了\n\n```python\nimport ray\nimport numpy as np\nimport os\n\n@ray.remote(num_cpus=1)\nclass Counter:\n    def __init__(self, flag_index):\n        self.weight_matrix = np.load(f\"weights/weight_{flag_index}.npy\")\n    \n    def process(self, input_matrix):\n        return np.maximum(0, np.dot(input_matrix, self.weight_matrix))\n\nif __name__ == \"__main__\":\n    ray.init(address=os.environ['RAY_CLUSTER_ADDR'])\n\n    # 创建放置组，每组有 4 个 CPU\n    placement_groups = [ray.util.placement_group([{\"CPU\": 4}], strategy=\"STRICT_PACK\") for _ in range(4)]\n    ray.get([pg.ready() for pg in placement_groups])  # 等待放置组就绪\n\n    if not os.path.exists(\"outputs\"):\n        os.makedirs(\"outputs\")\n\n    # 在每个放置组中创建 Counter 实例\n    counters = [[Counter.options(placement_group=placement_groups[i], placement_group_bundle_index=0).remote(j) for j in range(4)] for i in range(4)]\n\n    output_results = []\n    for i in range(100):\n        input_matrix = np.load(f\"inputs/input_{i}.npy\")\n        result = input_matrix\n        for counter in counters[i % 4]:\n            result = counter.process.remote(result)\n        output_results.append(result)\n\n    # 收集和保存结果\n    for i, result in enumerate(output_results):\n        output = ray.get(result)\n        np.save(f\"outputs/output_{i}.npy\", output)\n```\n\n\n\n## F.高性能数据校验\n\n [高性能数据校验.mhtml](高性能数据校验.mhtml) \n\n这道题一开始随便开了个MPI竟然就有80多分，而且我题都没认真看，后来随便改改卡到了90（没错，是卡bug到了90）题目重测后直接回归0分，着急！\n\n仔细读了一下题，看到提升里的SHA512函数，就想着用SHA512替换原来的一堆函数（没有认真去看那几个函数），然后就陷入了死循环里，SHA512没法进行并行计算，第i个块的计算依赖于第i-1个。\n\n后来偶然的仔细看了一下代码，发baseline代码中的函数完全解决了上面的问题，可以拆开做，只需要用更多的数组来记录一下就行了![image-20240125213452456](HPCGame记录/image-20240125213452456.png)\n\n修改了一下代码：\n\n```cpp\nvoid checksum(uint8_t *data, size_t len, uint8_t *obuf) {\n  int num_block = (len + BLOCK_SIZE - 1) / BLOCK_SIZE;\n  \n  EVP_MD *sha512 = EVP_MD_fetch(nullptr, \"SHA512\", nullptr);\n  EVP_MD_CTX *ctx[num_block];\n  for(int i=0; i<num_block; i++)//多创建一点ctx让记录数据和校验位分开计算\n  {\n    ctx[i]=EVP_MD_CTX_new();\n    EVP_DigestInit_ex(ctx[i], sha512, nullptr);\n  }\n  uint8_t prev_md[SHA512_DIGEST_LENGTH];\n  SHA512(nullptr, 0, prev_md);\n  for (int i = 0; i < num_block; i++) {\n    uint8_t buffer[BLOCK_SIZE]{};\n    EVP_DigestInit_ex(ctx[i], sha512, nullptr);\n    std::memcpy(buffer, data + i * BLOCK_SIZE, std::min(BLOCK_SIZE, len - i * BLOCK_SIZE));\n    EVP_DigestUpdate(ctx[i], buffer, BLOCK_SIZE);\n  }\n  for(int i=0;i<num_block;i++)\n  {\n    EVP_DigestUpdate(ctx[i], prev_md, SHA512_DIGEST_LENGTH);\n    unsigned int len = 0;\n    EVP_DigestFinal_ex(ctx[i], prev_md, &len);\n    EVP_MD_CTX_free(ctx[i]);\n  }\n  std::memcpy(obuf, prev_md, SHA512_DIGEST_LENGTH);\n  EVP_MD_free(sha512);\n}\n```\n\n就这一改，run了一下，成了！思路正确！测试了一下几个for循环的耗时，中间数据处理的循环占比最高![image-20240125213808760](HPCGame记录/image-20240125213808760.png)\n\n那就没问题了，开始修改MPI并行程序：\n\n```cpp\n#include <algorithm>\n#include <chrono>\n#include <cstring>\n#include <filesystem>\n#include <fstream>\n#include <iostream>\n#include <mpi.h>\n#include <openssl/evp.h>\n#include <openssl/sha.h>\n\nnamespace fs = std::filesystem;\n\nconstexpr size_t BLOCK_SIZE = 1024 * 1024;\n\nvoid print_checksum(std::ostream &os, uint8_t *md, size_t len);\n\nint main(int argc, char *argv[]) {\n\n  MPI_Init(&argc, &argv);\n\n  int rank, nprocs;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &nprocs);\n\n  if (rank == 0) {\n    if (argc < 3) {\n      std::cout << \"Usage: \" << argv[0] << \" <input_file> <output_file>\"\n                << std::endl;\n      MPI_Abort(MPI_COMM_WORLD, 1);\n    }\n  }\n    fs::path input_path = argv[1];\n    fs::path output_path = argv[2];\n\n    auto total_begin_time = std::chrono::high_resolution_clock::now();\n\n    auto file_size = fs::file_size(input_path);\n    std::cout << input_path << \" size: \" << file_size << std::endl;\n    int num_block = (file_size + BLOCK_SIZE - 1) / BLOCK_SIZE;\n    int proc_num_block = num_block / 8;\n    auto len = file_size / 8;\n    uint8_t *buffer = nullptr;\n    if (file_size != 0) {\n      buffer = new uint8_t[len];\n      std::ifstream istrm(input_path, std::ios::binary);\n      istrm.seekg(rank*len);\n      istrm.read(reinterpret_cast<char *>(buffer), len);\n    }\n\n    auto begin_time = std::chrono::high_resolution_clock::now();\n    \n    EVP_MD *sha512 = EVP_MD_fetch(nullptr, \"SHA512\", nullptr);\n    EVP_MD_CTX *ctx[proc_num_block];\n    for(int i=0; i<proc_num_block; i++)\n    {\n      ctx[i]=EVP_MD_CTX_new();\n      EVP_DigestInit_ex(ctx[i], sha512, nullptr);\n    }\n\n    uint8_t prev_md[SHA512_DIGEST_LENGTH];\n    \n    for (int i = 0; i < proc_num_block; i++) {\n      uint8_t buffer_temp[BLOCK_SIZE]{};\n      std::memcpy(buffer_temp, buffer + i * BLOCK_SIZE, std::min(BLOCK_SIZE, len - i * BLOCK_SIZE));\n      EVP_DigestUpdate(ctx[i], buffer_temp, BLOCK_SIZE);\n    }\n    delete[] buffer;\n\n    if(rank==0){\n      SHA512(nullptr, 0, prev_md);\n      for(int i=0;i<proc_num_block;i++)\n      {\n        EVP_DigestUpdate(ctx[i], prev_md, SHA512_DIGEST_LENGTH);\n        unsigned int len_ex = 0;\n        EVP_DigestFinal_ex(ctx[i], prev_md, &len_ex);\n        EVP_MD_CTX_free(ctx[i]);\n      }\n      MPI_Send(prev_md, SHA512_DIGEST_LENGTH, MPI_UINT8_T, 1, 0, MPI_COMM_WORLD);\n    }else if(rank>0 && rank<7)\n    {\n      MPI_Recv(prev_md, SHA512_DIGEST_LENGTH, MPI_UINT8_T, rank - 1, 0, MPI_COMM_WORLD, MPI_STATUS_IGNORE);\n      for(int i=0;i<proc_num_block;i++)\n      {\n        EVP_DigestUpdate(ctx[i], prev_md, SHA512_DIGEST_LENGTH);\n        unsigned int len_ex = 0;\n        EVP_DigestFinal_ex(ctx[i], prev_md, &len_ex);\n        EVP_MD_CTX_free(ctx[i]);\n      }\n      MPI_Send(prev_md, SHA512_DIGEST_LENGTH, MPI_UINT8_T, rank + 1, 0, MPI_COMM_WORLD);      \n    }else if(rank==7){\n      MPI_Recv(prev_md, SHA512_DIGEST_LENGTH, MPI_UINT8_T, rank - 1, 0, MPI_COMM_WORLD, MPI_STATUS_IGNORE);\n      for(int i=0;i<proc_num_block;i++)\n      {\n        EVP_DigestUpdate(ctx[i], prev_md, SHA512_DIGEST_LENGTH);\n        unsigned int len_ex = 0;\n        EVP_DigestFinal_ex(ctx[i], prev_md, &len_ex);\n        EVP_MD_CTX_free(ctx[i]);\n      }\n    }\n\n    EVP_MD_free(sha512);\n  \n  if(rank==7)\n  {\n    auto end_time = std::chrono::high_resolution_clock::now();\n\n    // print debug information\n    std::cout << \"checksum: \";\n    print_checksum(std::cout, prev_md, SHA512_DIGEST_LENGTH);\n    std::cout << std::endl;\n\n    auto duration = std::chrono::duration_cast<std::chrono::milliseconds>(\n        end_time - begin_time);\n\n    std::cout << \"checksum time cost: \" << std::dec << duration.count() << \"ms\"\n              << std::endl;\n\n    // write checksum to output file\n    std::ofstream output_file(output_path);\n\n    print_checksum(output_file, prev_md, SHA512_DIGEST_LENGTH);\n  \n    auto total_end_time = std::chrono::high_resolution_clock::now();\n\n    auto total_duration = std::chrono::duration_cast<std::chrono::milliseconds>(\n        total_end_time - total_begin_time);\n\n    std::cout << \"total time cost: \" << total_duration.count() << \"ms\"\n              << std::endl;\n  \n  }\n\n  MPI_Finalize();\n  return 0;\n}\n\nvoid print_checksum(std::ostream &os, uint8_t *md, size_t len) {\n  for (int i = 0; i < len; i++) {\n    os << std::setw(2) << std::setfill('0') << std::hex\n       << static_cast<int>(md[i]);\n  }\n}\n```\n\n效果不算特别好，90/120分，检查了一下，发现读取占用时间太长，\n\n偶然想到可以不用一次性读入全部数据，让IO和CPU形成流水线即可\n\n```c\n#include <algorithm>\n#include <chrono>\n#include <cstring>\n#include <filesystem>\n#include <fstream>\n#include <iostream>\n#include <mpi.h>\n#include <openssl/evp.h>\n#include <openssl/sha.h>\n\nnamespace fs = std::filesystem;\n\nconstexpr size_t BLOCK_SIZE = 1024 * 1024;\n\nvoid print_checksum(std::ostream &os, uint8_t *md, size_t len);\n\nint main(int argc, char *argv[]) {\n\n  MPI_Init(&argc, &argv);\n\n  int rank, nprocs;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &nprocs);\n\n  if (rank == 0) {\n    if (argc < 3) {\n      std::cout << \"Usage: \" << argv[0] << \" <input_file> <output_file>\"\n                << std::endl;\n      MPI_Abort(MPI_COMM_WORLD, 1);\n    }\n  }\n    fs::path input_path = argv[1];\n    fs::path output_path = argv[2];\n\n    auto total_begin_time = std::chrono::high_resolution_clock::now();\n\n    auto file_size = fs::file_size(input_path);\n    std::cout << input_path << \" size: \" << file_size << std::endl;\n    int num_block = (file_size + BLOCK_SIZE - 1) / BLOCK_SIZE;\n    int proc_num_block = num_block / 8;\n    auto len = file_size / 8;\n\n    auto begin_time = std::chrono::high_resolution_clock::now();\n    \n    EVP_MD *sha512 = EVP_MD_fetch(nullptr, \"SHA512\", nullptr);\n    EVP_MD_CTX *ctx[proc_num_block];\n    for(int i=0; i<proc_num_block; i++)\n    {\n      ctx[i]=EVP_MD_CTX_new();\n      EVP_DigestInit_ex(ctx[i], sha512, nullptr);\n    }\n\n    uint8_t prev_md[SHA512_DIGEST_LENGTH];\n    std::ifstream istrm(input_path, std::ios::binary);\n    uint8_t buffer_temp[BLOCK_SIZE];\n    for (int i = 0; i < proc_num_block; i++) {\n      istrm.seekg(rank*len + i*BLOCK_SIZE);\n      istrm.read(reinterpret_cast<char *>(buffer_temp),BLOCK_SIZE);\n        //IO和CPU流水线\n      EVP_DigestUpdate(ctx[i], buffer_temp, BLOCK_SIZE);\n    }\n\n    if(rank==0){\n      SHA512(nullptr, 0, prev_md);\n      for(int i=0;i<proc_num_block;i++)\n      {\n        EVP_DigestUpdate(ctx[i], prev_md, SHA512_DIGEST_LENGTH);\n        unsigned int len_ex = 0;\n        EVP_DigestFinal_ex(ctx[i], prev_md, &len_ex);\n        EVP_MD_CTX_free(ctx[i]);\n      }\n      MPI_Send(prev_md, SHA512_DIGEST_LENGTH, MPI_UINT8_T, 1, 0, MPI_COMM_WORLD);\n    }else if(rank>0 && rank<7)\n    {\n      MPI_Recv(prev_md, SHA512_DIGEST_LENGTH, MPI_UINT8_T, rank - 1, 0, MPI_COMM_WORLD, MPI_STATUS_IGNORE);\n      for(int i=0;i<proc_num_block;i++)\n      {\n        EVP_DigestUpdate(ctx[i], prev_md, SHA512_DIGEST_LENGTH);\n        unsigned int len_ex = 0;\n        EVP_DigestFinal_ex(ctx[i], prev_md, &len_ex);\n        EVP_MD_CTX_free(ctx[i]);\n      }\n      MPI_Send(prev_md, SHA512_DIGEST_LENGTH, MPI_UINT8_T, rank + 1, 0, MPI_COMM_WORLD);      \n    }else if(rank==7){\n      MPI_Recv(prev_md, SHA512_DIGEST_LENGTH, MPI_UINT8_T, rank - 1, 0, MPI_COMM_WORLD, MPI_STATUS_IGNORE);\n      for(int i=0;i<proc_num_block;i++)\n      {\n        EVP_DigestUpdate(ctx[i], prev_md, SHA512_DIGEST_LENGTH);\n        unsigned int len_ex = 0;\n        EVP_DigestFinal_ex(ctx[i], prev_md, &len_ex);\n        EVP_MD_CTX_free(ctx[i]);\n      }\n    }\n\n    EVP_MD_free(sha512);\n  \n  if(rank==7)\n  {\n    auto end_time = std::chrono::high_resolution_clock::now();\n\n    // print debug information\n    std::cout << \"checksum: \";\n    print_checksum(std::cout, prev_md, SHA512_DIGEST_LENGTH);\n    std::cout << std::endl;\n\n    auto duration = std::chrono::duration_cast<std::chrono::milliseconds>(\n        end_time - begin_time);\n\n    std::cout << \"checksum time cost: \" << std::dec << duration.count() << \"ms\"\n              << std::endl;\n\n    // write checksum to output file\n    std::ofstream output_file(output_path);\n\n    print_checksum(output_file, prev_md, SHA512_DIGEST_LENGTH);\n  \n    auto total_end_time = std::chrono::high_resolution_clock::now();\n\n    auto total_duration = std::chrono::duration_cast<std::chrono::milliseconds>(\n        total_end_time - total_begin_time);\n\n    std::cout << \"total time cost: \" << total_duration.count() << \"ms\"\n              << std::endl;\n  \n  }\n  MPI_Finalize();\n  return 0;\n}\n\nvoid print_checksum(std::ostream &os, uint8_t *md, size_t len) {\n  for (int i = 0; i < len; i++) {\n    os << std::setw(2) << std::setfill('0') << std::hex\n       << static_cast<int>(md[i]);\n  }\n}\n```\n\n速度得到了非常显著的提升，get满分\n\n## H.矩阵乘法\n\n [矩阵乘法.mhtml](矩阵乘法.mhtml) \n\n经典题目，同样的配方，用AVX512+Openmp+分块计算基本就能有不错的效果，不过我也只拿到了73/100分（菜就该多练），直接把printf去掉了都拿不到高分┭┮﹏┭┮\n\n```cpp\n#include <iostream>\n#include <chrono>\n#include <immintrin.h>\n#include <omp.h>\n#include <cmath>\n#define BLOCKSIZE 128\n#define AVX_F_CAPACITY 8\n\nvoid mul(double* a, double* b, double* c, uint64_t n1, uint64_t n2, uint64_t n3) {\n#pragma omp parallel for\n    for (uint64_t i = 0; i < n1; i+=BLOCKSIZE) {\n        for (uint64_t j = 0; j < n2; j+=BLOCKSIZE) {\n            for (uint64_t k = 0; k < n3; k+=BLOCKSIZE) {\n\n                for(uint64_t ii=i; ii<i+BLOCKSIZE; ii+=AVX_F_CAPACITY)\n                {\n                    for(uint64_t kk=k; kk<k+BLOCKSIZE; kk+=16)\n                    {\n                        __m512d vc0,vc1,vc2,vc3,vc4,vc5,vc6,vc7,vc8,vc9,vc10,vc11,vc12,vc13,vc14,vc15,vb,vb1;\n                        vc0 = _mm512_load_pd(&c[ii*n3+kk]);\n                        vc8 = _mm512_load_pd(&c[ii*n3+kk+8]);\n                        vc1 = _mm512_load_pd(&c[(ii+1)*n3+kk]);\n                        vc9 = _mm512_load_pd(&c[(ii+1)*n3+kk+8]);\n                        vc2 = _mm512_load_pd(&c[(ii+2)*n3+kk]);\n                        vc10 = _mm512_load_pd(&c[(ii+2)*n3+kk+8]);\n                        vc3 = _mm512_load_pd(&c[(ii+3)*n3+kk]);\n                        vc11 = _mm512_load_pd(&c[(ii+3)*n3+kk+8]);\n                        vc4 = _mm512_load_pd(&c[(ii+4)*n3+kk]);\n                        vc12 = _mm512_load_pd(&c[(ii+4)*n3+kk+8]);\n                        vc5 = _mm512_load_pd(&c[(ii+5)*n3+kk]);\n                        vc13 = _mm512_load_pd(&c[(ii+5)*n3+kk+8]);\n                        vc6 = _mm512_load_pd(&c[(ii+6)*n3+kk]);\n                        vc14 = _mm512_load_pd(&c[(ii+6)*n3+kk+8]);\n                        vc7 = _mm512_load_pd(&c[(ii+7)*n3+kk]);\n                        vc15 = _mm512_load_pd(&c[(ii+7)*n3+kk+8]);\n\n                        for(uint64_t jj=j; jj<j+BLOCKSIZE; jj+=AVX_F_CAPACITY)\n                        {\n                            vb=_mm512_load_pd(&b[jj*n3 + kk]);\n                            vb1=_mm512_load_pd(&b[jj*n3 + kk+8]);\n                            vc0 = _mm512_fmadd_pd(_mm512_set1_pd(a[ii*n2+jj]),vb,vc0);\n                            vc8 = _mm512_fmadd_pd(_mm512_set1_pd(a[ii*n2+jj]),vb1,vc8);\n                            vc1 = _mm512_fmadd_pd(_mm512_set1_pd(a[(ii+1)*n2+jj]),vb,vc1);\n                            vc9 = _mm512_fmadd_pd(_mm512_set1_pd(a[(ii+1)*n2+jj]),vb1,vc9);\n                            vc2 = _mm512_fmadd_pd(_mm512_set1_pd(a[(ii+2)*n2+jj]),vb,vc2);\n                            vc10 = _mm512_fmadd_pd(_mm512_set1_pd(a[(ii+2)*n2+jj]),vb1,vc10);\n                            vc3 = _mm512_fmadd_pd(_mm512_set1_pd(a[(ii+3)*n2+jj]),vb,vc3);\n                            vc11 = _mm512_fmadd_pd(_mm512_set1_pd(a[(ii+3)*n2+jj]),vb1,vc11);\n                            vc4 = _mm512_fmadd_pd(_mm512_set1_pd(a[(ii+4)*n2+jj]),vb,vc4);\n                            vc12 = _mm512_fmadd_pd(_mm512_set1_pd(a[(ii+4)*n2+jj]),vb1,vc12);\n                            vc5 = _mm512_fmadd_pd(_mm512_set1_pd(a[(ii+5)*n2+jj]),vb,vc5);\n                            vc13 = _mm512_fmadd_pd(_mm512_set1_pd(a[(ii+5)*n2+jj]),vb1,vc13);\n                            vc6 = _mm512_fmadd_pd(_mm512_set1_pd(a[(ii+6)*n2+jj]),vb,vc6);\n                            vc14 = _mm512_fmadd_pd(_mm512_set1_pd(a[(ii+6)*n2+jj]),vb1,vc14);\n                            vc7 = _mm512_fmadd_pd(_mm512_set1_pd(a[(ii+7)*n2+jj]),vb,vc7);\n                            vc15 = _mm512_fmadd_pd(_mm512_set1_pd(a[(ii+7)*n2+jj]),vb1,vc15);\n                        \n\n                            vb=_mm512_load_pd(&b[(jj+1)*n3 + kk]);\n                            vb1=_mm512_load_pd(&b[(jj+1)*n3 + kk+8]);\n                            vc0 = _mm512_fmadd_pd(_mm512_set1_pd(a[ii*n2+jj+1]),vb,vc0);\n                            vc8 = _mm512_fmadd_pd(_mm512_set1_pd(a[ii*n2+jj+1]),vb1,vc8);\n                            vc1 = _mm512_fmadd_pd(_mm512_set1_pd(a[(ii+1)*n2+jj+1]),vb,vc1);\n                            vc9 = _mm512_fmadd_pd(_mm512_set1_pd(a[(ii+1)*n2+jj+1]),vb1,vc9);\n                            vc2 = _mm512_fmadd_pd(_mm512_set1_pd(a[(ii+2)*n2+jj+1]),vb,vc2);\n                            vc10 = _mm512_fmadd_pd(_mm512_set1_pd(a[(ii+2)*n2+jj+1]),vb1,vc10);\n                            vc3 = _mm512_fmadd_pd(_mm512_set1_pd(a[(ii+3)*n2+jj+1]),vb,vc3);\n                            vc11 = _mm512_fmadd_pd(_mm512_set1_pd(a[(ii+3)*n2+jj+1]),vb1,vc11);\n                            vc4 = _mm512_fmadd_pd(_mm512_set1_pd(a[(ii+4)*n2+jj+1]),vb,vc4);\n                            vc12 = _mm512_fmadd_pd(_mm512_set1_pd(a[(ii+4)*n2+jj+1]),vb1,vc12);\n                            vc5 = _mm512_fmadd_pd(_mm512_set1_pd(a[(ii+5)*n2+jj+1]),vb,vc5);\n                            vc13 = _mm512_fmadd_pd(_mm512_set1_pd(a[(ii+5)*n2+jj+1]),vb1,vc13);\n                            vc6 = _mm512_fmadd_pd(_mm512_set1_pd(a[(ii+6)*n2+jj+1]),vb,vc6);\n                            vc14 = _mm512_fmadd_pd(_mm512_set1_pd(a[(ii+6)*n2+jj+1]),vb1,vc14);\n                            vc7 = _mm512_fmadd_pd(_mm512_set1_pd(a[(ii+7)*n2+jj+1]),vb,vc7);\n                            vc15 = _mm512_fmadd_pd(_mm512_set1_pd(a[(ii+7)*n2+jj+1]),vb1,vc15);\n\n                            vb=_mm512_load_pd(&b[(jj+2)*n3 + kk]);\n                            vb1=_mm512_load_pd(&b[(jj+2)*n3 + kk+8]);\n                            vc0 = _mm512_fmadd_pd(_mm512_set1_pd(a[ii*n2+jj+2]),vb,vc0);\n                            vc8 = _mm512_fmadd_pd(_mm512_set1_pd(a[ii*n2+jj+2]),vb1,vc8);\n                            vc1 = _mm512_fmadd_pd(_mm512_set1_pd(a[(ii+1)*n2+jj+2]),vb,vc1);\n                            vc9 = _mm512_fmadd_pd(_mm512_set1_pd(a[(ii+1)*n2+jj+2]),vb1,vc9);\n                            vc2 = _mm512_fmadd_pd(_mm512_set1_pd(a[(ii+2)*n2+jj+2]),vb,vc2);\n                            vc10 = _mm512_fmadd_pd(_mm512_set1_pd(a[(ii+2)*n2+jj+2]),vb1,vc10);\n                            vc3 = _mm512_fmadd_pd(_mm512_set1_pd(a[(ii+3)*n2+jj+2]),vb,vc3);\n                            vc11 = _mm512_fmadd_pd(_mm512_set1_pd(a[(ii+3)*n2+jj+2]),vb1,vc11);\n                            vc4 = _mm512_fmadd_pd(_mm512_set1_pd(a[(ii+4)*n2+jj+2]),vb,vc4);\n                            vc12 = _mm512_fmadd_pd(_mm512_set1_pd(a[(ii+4)*n2+jj+2]),vb1,vc12);\n                            vc5 = _mm512_fmadd_pd(_mm512_set1_pd(a[(ii+5)*n2+jj+2]),vb,vc5);\n                            vc13 = _mm512_fmadd_pd(_mm512_set1_pd(a[(ii+5)*n2+jj+2]),vb1,vc13);\n                            vc6 = _mm512_fmadd_pd(_mm512_set1_pd(a[(ii+6)*n2+jj+2]),vb,vc6);\n                            vc14 = _mm512_fmadd_pd(_mm512_set1_pd(a[(ii+6)*n2+jj+2]),vb1,vc14);\n                            vc7 = _mm512_fmadd_pd(_mm512_set1_pd(a[(ii+7)*n2+jj+2]),vb,vc7);\n                            vc15 = _mm512_fmadd_pd(_mm512_set1_pd(a[(ii+7)*n2+jj+2]),vb1,vc15);\n\n                            vb=_mm512_load_pd(&b[(jj+3)*n3 + kk]);\n                            vb1=_mm512_load_pd(&b[(jj+3)*n3 + kk+8]);\n                            vc0 = _mm512_fmadd_pd(_mm512_set1_pd(a[ii*n2+jj+3]),vb,vc0);\n                            vc8 = _mm512_fmadd_pd(_mm512_set1_pd(a[ii*n2+jj+3]),vb1,vc8);\n                            vc1 = _mm512_fmadd_pd(_mm512_set1_pd(a[(ii+1)*n2+jj+3]),vb,vc1);\n                            vc9 = _mm512_fmadd_pd(_mm512_set1_pd(a[(ii+1)*n2+jj+3]),vb1,vc9);\n                            vc2 = _mm512_fmadd_pd(_mm512_set1_pd(a[(ii+2)*n2+jj+3]),vb,vc2);\n                            vc10 = _mm512_fmadd_pd(_mm512_set1_pd(a[(ii+2)*n2+jj+3]),vb1,vc10);\n                            vc3 = _mm512_fmadd_pd(_mm512_set1_pd(a[(ii+3)*n2+jj+3]),vb,vc3);\n                            vc11 = _mm512_fmadd_pd(_mm512_set1_pd(a[(ii+3)*n2+jj+3]),vb1,vc11);\n                            vc4 = _mm512_fmadd_pd(_mm512_set1_pd(a[(ii+4)*n2+jj+3]),vb,vc4);\n                            vc12 = _mm512_fmadd_pd(_mm512_set1_pd(a[(ii+4)*n2+jj+3]),vb1,vc12);\n                            vc5 = _mm512_fmadd_pd(_mm512_set1_pd(a[(ii+5)*n2+jj+3]),vb,vc5);\n                            vc13 = _mm512_fmadd_pd(_mm512_set1_pd(a[(ii+5)*n2+jj+3]),vb1,vc13);\n                            vc6 = _mm512_fmadd_pd(_mm512_set1_pd(a[(ii+6)*n2+jj+3]),vb,vc6);\n                            vc14 = _mm512_fmadd_pd(_mm512_set1_pd(a[(ii+6)*n2+jj+3]),vb1,vc14);\n                            vc7 = _mm512_fmadd_pd(_mm512_set1_pd(a[(ii+7)*n2+jj+3]),vb,vc7);\n                            vc15 = _mm512_fmadd_pd(_mm512_set1_pd(a[(ii+7)*n2+jj+3]),vb1,vc15);\n                            \n                            vb=_mm512_load_pd(&b[(jj+4)*n3 + kk]);\n                            vb1=_mm512_load_pd(&b[(jj+4)*n3 + kk+8]);\n                            vc0 = _mm512_fmadd_pd(_mm512_set1_pd(a[ii*n2+jj+4]),vb,vc0);\n                            vc8 = _mm512_fmadd_pd(_mm512_set1_pd(a[ii*n2+jj+4]),vb1,vc8);\n                            vc1 = _mm512_fmadd_pd(_mm512_set1_pd(a[(ii+1)*n2+jj+4]),vb,vc1);\n                            vc9 = _mm512_fmadd_pd(_mm512_set1_pd(a[(ii+1)*n2+jj+4]),vb1,vc9);\n                            vc2 = _mm512_fmadd_pd(_mm512_set1_pd(a[(ii+2)*n2+jj+4]),vb,vc2);\n                            vc10 = _mm512_fmadd_pd(_mm512_set1_pd(a[(ii+2)*n2+jj+4]),vb1,vc10);\n                            vc3 = _mm512_fmadd_pd(_mm512_set1_pd(a[(ii+3)*n2+jj+4]),vb,vc3);\n                            vc11 = _mm512_fmadd_pd(_mm512_set1_pd(a[(ii+3)*n2+jj+4]),vb1,vc11);\n                            vc4 = _mm512_fmadd_pd(_mm512_set1_pd(a[(ii+4)*n2+jj+4]),vb,vc4);\n                            vc12 = _mm512_fmadd_pd(_mm512_set1_pd(a[(ii+4)*n2+jj+4]),vb1,vc12);\n                            vc5 = _mm512_fmadd_pd(_mm512_set1_pd(a[(ii+5)*n2+jj+4]),vb,vc5);\n                            vc13 = _mm512_fmadd_pd(_mm512_set1_pd(a[(ii+5)*n2+jj+4]),vb1,vc13);\n                            vc6 = _mm512_fmadd_pd(_mm512_set1_pd(a[(ii+6)*n2+jj+4]),vb,vc6);\n                            vc14 = _mm512_fmadd_pd(_mm512_set1_pd(a[(ii+6)*n2+jj+4]),vb1,vc14);\n                            vc7 = _mm512_fmadd_pd(_mm512_set1_pd(a[(ii+7)*n2+jj+4]),vb,vc7);\n                            vc15 = _mm512_fmadd_pd(_mm512_set1_pd(a[(ii+7)*n2+jj+4]),vb1,vc15);\n\n                            vb=_mm512_load_pd(&b[(jj+5)*n3 + kk]);\n                            vb1=_mm512_load_pd(&b[(jj+5)*n3 + kk+8]);\n                            vc0 = _mm512_fmadd_pd(_mm512_set1_pd(a[ii*n2+jj+5]),vb,vc0);\n                            vc8 = _mm512_fmadd_pd(_mm512_set1_pd(a[ii*n2+jj+5]),vb1,vc8);\n                            vc1 = _mm512_fmadd_pd(_mm512_set1_pd(a[(ii+1)*n2+jj+5]),vb,vc1);\n                            vc9 = _mm512_fmadd_pd(_mm512_set1_pd(a[(ii+1)*n2+jj+5]),vb1,vc9);\n                            vc2 = _mm512_fmadd_pd(_mm512_set1_pd(a[(ii+2)*n2+jj+5]),vb,vc2);\n                            vc10 = _mm512_fmadd_pd(_mm512_set1_pd(a[(ii+2)*n2+jj+5]),vb1,vc10);\n                            vc3 = _mm512_fmadd_pd(_mm512_set1_pd(a[(ii+3)*n2+jj+5]),vb,vc3);\n                            vc11 = _mm512_fmadd_pd(_mm512_set1_pd(a[(ii+3)*n2+jj+5]),vb1,vc11);\n                            vc4 = _mm512_fmadd_pd(_mm512_set1_pd(a[(ii+4)*n2+jj+5]),vb,vc4);\n                            vc12 = _mm512_fmadd_pd(_mm512_set1_pd(a[(ii+4)*n2+jj+5]),vb1,vc12);\n                            vc5 = _mm512_fmadd_pd(_mm512_set1_pd(a[(ii+5)*n2+jj+5]),vb,vc5);\n                            vc13 = _mm512_fmadd_pd(_mm512_set1_pd(a[(ii+5)*n2+jj+5]),vb1,vc13);\n                            vc6 = _mm512_fmadd_pd(_mm512_set1_pd(a[(ii+6)*n2+jj+5]),vb,vc6);\n                            vc14 = _mm512_fmadd_pd(_mm512_set1_pd(a[(ii+6)*n2+jj+5]),vb1,vc14);\n                            vc7 = _mm512_fmadd_pd(_mm512_set1_pd(a[(ii+7)*n2+jj+5]),vb,vc7);\n                            vc15 = _mm512_fmadd_pd(_mm512_set1_pd(a[(ii+7)*n2+jj+5]),vb1,vc15);\n                            \n\n                            vb=_mm512_load_pd(&b[(jj+6)*n3 + kk]);\n                            vb1=_mm512_load_pd(&b[(jj+6)*n3 + kk+8]);\n                            vc0 = _mm512_fmadd_pd(_mm512_set1_pd(a[ii*n2+jj+6]),vb,vc0);\n                            vc8 = _mm512_fmadd_pd(_mm512_set1_pd(a[ii*n2+jj+6]),vb1,vc8);\n                            vc1 = _mm512_fmadd_pd(_mm512_set1_pd(a[(ii+1)*n2+jj+6]),vb,vc1);\n                            vc9 = _mm512_fmadd_pd(_mm512_set1_pd(a[(ii+1)*n2+jj+6]),vb1,vc9);\n                            vc2 = _mm512_fmadd_pd(_mm512_set1_pd(a[(ii+2)*n2+jj+6]),vb,vc2);\n                            vc10 = _mm512_fmadd_pd(_mm512_set1_pd(a[(ii+2)*n2+jj+6]),vb1,vc10);\n                            vc3 = _mm512_fmadd_pd(_mm512_set1_pd(a[(ii+3)*n2+jj+6]),vb,vc3);\n                            vc11 = _mm512_fmadd_pd(_mm512_set1_pd(a[(ii+3)*n2+jj+6]),vb1,vc11);\n                            vc4 = _mm512_fmadd_pd(_mm512_set1_pd(a[(ii+4)*n2+jj+6]),vb,vc4);\n                            vc12 = _mm512_fmadd_pd(_mm512_set1_pd(a[(ii+4)*n2+jj+6]),vb1,vc12);\n                            vc5 = _mm512_fmadd_pd(_mm512_set1_pd(a[(ii+5)*n2+jj+6]),vb,vc5);\n                            vc13 = _mm512_fmadd_pd(_mm512_set1_pd(a[(ii+5)*n2+jj+6]),vb1,vc13);\n                            vc6 = _mm512_fmadd_pd(_mm512_set1_pd(a[(ii+6)*n2+jj+6]),vb,vc6);\n                            vc14 = _mm512_fmadd_pd(_mm512_set1_pd(a[(ii+6)*n2+jj+6]),vb1,vc14);\n                            vc7 = _mm512_fmadd_pd(_mm512_set1_pd(a[(ii+7)*n2+jj+6]),vb,vc7);\n                            vc15 = _mm512_fmadd_pd(_mm512_set1_pd(a[(ii+7)*n2+jj+6]),vb1,vc15);\n\n                            vb=_mm512_load_pd(&b[(jj+7)*n3 + kk]);\n                            vb1=_mm512_load_pd(&b[(jj+7)*n3 + kk+8]);\n                            vc0 = _mm512_fmadd_pd(_mm512_set1_pd(a[ii*n2+jj+7]),vb,vc0);\n                            vc8 = _mm512_fmadd_pd(_mm512_set1_pd(a[ii*n2+jj+7]),vb1,vc8);\n                            vc1 = _mm512_fmadd_pd(_mm512_set1_pd(a[(ii+1)*n2+jj+7]),vb,vc1);\n                            vc9 = _mm512_fmadd_pd(_mm512_set1_pd(a[(ii+1)*n2+jj+7]),vb1,vc9);\n                            vc2 = _mm512_fmadd_pd(_mm512_set1_pd(a[(ii+2)*n2+jj+7]),vb,vc2);\n                            vc10 = _mm512_fmadd_pd(_mm512_set1_pd(a[(ii+2)*n2+jj+7]),vb1,vc10);\n                            vc3 = _mm512_fmadd_pd(_mm512_set1_pd(a[(ii+3)*n2+jj+7]),vb,vc3);\n                            vc11 = _mm512_fmadd_pd(_mm512_set1_pd(a[(ii+3)*n2+jj+7]),vb1,vc11);\n                            vc4 = _mm512_fmadd_pd(_mm512_set1_pd(a[(ii+4)*n2+jj+7]),vb,vc4);\n                            vc12 = _mm512_fmadd_pd(_mm512_set1_pd(a[(ii+4)*n2+jj+7]),vb1,vc12);\n                            vc5 = _mm512_fmadd_pd(_mm512_set1_pd(a[(ii+5)*n2+jj+7]),vb,vc5);\n                            vc13 = _mm512_fmadd_pd(_mm512_set1_pd(a[(ii+5)*n2+jj+7]),vb1,vc13);\n                            vc6 = _mm512_fmadd_pd(_mm512_set1_pd(a[(ii+6)*n2+jj+7]),vb,vc6);\n                            vc14 = _mm512_fmadd_pd(_mm512_set1_pd(a[(ii+6)*n2+jj+7]),vb1,vc14);\n                            vc7 = _mm512_fmadd_pd(_mm512_set1_pd(a[(ii+7)*n2+jj+7]),vb,vc7);                            \n                            vc15 = _mm512_fmadd_pd(_mm512_set1_pd(a[(ii+7)*n2+jj+7]),vb1,vc15);\n                        }\n                        _mm512_store_pd(&c[ii*n3 + kk],vc0);\n                        _mm512_store_pd(&c[ii*n3 + kk+8],vc8);\n                        _mm512_store_pd(&c[(ii+1)*n3 + kk],vc1);\n                        _mm512_store_pd(&c[(ii+1)*n3 + kk+8],vc9);\n                        _mm512_store_pd(&c[(ii+2)*n3 + kk],vc2);\n                        _mm512_store_pd(&c[(ii+2)*n3 + kk+8],vc10);\n                        _mm512_store_pd(&c[(ii+3)*n3 + kk],vc3);\n                        _mm512_store_pd(&c[(ii+3)*n3 + kk+8],vc11);\n                        _mm512_store_pd(&c[(ii+4)*n3 + kk],vc4);\n                        _mm512_store_pd(&c[(ii+4)*n3 + kk+8],vc12);\n                        _mm512_store_pd(&c[(ii+5)*n3 + kk],vc5);\n                        _mm512_store_pd(&c[(ii+5)*n3 + kk+8],vc13);\n                        _mm512_store_pd(&c[(ii+6)*n3 + kk],vc6);\n                        _mm512_store_pd(&c[(ii+6)*n3 + kk+8],vc14);\n                        _mm512_store_pd(&c[(ii+7)*n3 + kk],vc7);\n                        _mm512_store_pd(&c[(ii+7)*n3 + kk+8],vc15);\n                    }\n                }\n            \n            }\n        }\n    }\n}\nint main() {\n uint64_t n1, n2, n3;\n FILE* fi;\n\n fi = fopen(\"conf.data\", \"rb\");\n fread(&n1, 1, 8, fi);\n fread(&n2, 1, 8, fi);\n fread(&n3, 1, 8, fi);\n\n double* a = (double*)_mm_malloc(n1 * n2 * 8,64);\n double* b = (double*)_mm_malloc(n2 * n3 * 8,64);\n double* c = (double*)_mm_malloc(n1 * n3 * 8,64);\n\n fread(a, 1, n1 * n2 * 8, fi);\n fread(b, 1, n2 * n3 * 8, fi);\n fclose(fi);\n\n for (uint64_t i = 0; i < n1; i++) {\n  for (uint64_t k = 0; k < n3; k++) {\n   c[i * n3 + k] = 0;\n  }\n }\n\n\n auto t1 = std::chrono::steady_clock::now();\n mul(a, b, c, n1, n2, n3);\n auto t2 = std::chrono::steady_clock::now();\n int d1 = std::chrono::duration_cast<std::chrono::milliseconds>(t2 - t1).count();\n printf(\"%d\\n\", d1);\n// printf(\"c:%.4lf\\n\",c[202]);\n\n fi = fopen(\"out.data\", \"wb\");\n fwrite(c, 1, n1 * n3 * 8, fi);\n fclose(fi);\n\n return 0;\n}\n```\n\n\n\n## I.logistic 方程\n\n [Logistic方程.mhtml](Logistic方程.mhtml) \n\n这题卡了一下午，分数一直是20多分，实在看不下去\n\n一开始只是对it、itv函数进行简单的AVX和openmp处理，出来的结果实在不让人满意，后来经过对函数结构的观察，发现两个循环可以换位置，于是交换了一下，再在内部开openmp，确实还是差点意思，想到这道题反复强调向量化，就尝试将迭代次数减少一部分，放进内部循环，此时发现效果还可以。代码如下：\n\n```cpp\n#define N 8\ndouble count_itv(double r, double x) {\n    return r * x * (1.0 - x);\n}\n\nvoid itv(double r, double* x, int64_t n, int64_t itn) {\n    #pragma omp parallel\n    {\n        for (int64_t j = 0; j < itn/N; j++) {\n            #pragma omp for\n            for (int64_t i = 0; i < n; i++) {\n                for (int64_t k = 0; k <N; k++) {\n                    x[i] = count_itv(r, x[i]);\n                }\n            }\n        }\n    }\n}\n```\n\n数字16是经过反复尝试，调整出来的最好结果，因为itn=32768，所以必须选择可以除尽的数\n\n![image-20240124010147362](HPCGame记录/image-20240124010147362.png)\n\n还差4分，难受，改了一下手动向量化，代码如下：\n\n```cpp\n    __m512d avx_one = _mm512_set1_pd(1.0);\n    __m512d avx_r = _mm512_set1_pd(r);\n    #pragma omp parallel\n    {\n        for (short i=0; i<itn/N; ++i) {\n            #pragma omp for\n            for (int64_t j=0; j<n; j+=8) {\n                __m512d avx_x = _mm512_load_pd(&x[j]);\n                for (short k=0; k<N; ++k) {\n                    __m512d avx_tmp = _mm512_mul_pd(avx_r, avx_x);\n                    avx_x = _mm512_mul_pd(avx_tmp, _mm512_sub_pd(avx_one, avx_x));\n                }\n                _mm512_store_pd(&x[j], avx_x);\n            }\n        }\n    }\n```\n\n![image-20240124013348557](HPCGame记录/image-20240124013348557.png)\n\n额(⊙o⊙)…毁灭吧，我累了\n\n后期突然注意到，openmp开错了，这道题还是openmp+向量化，但是我神奇般的过了...卡了个bug\n\n来自一位学长的**修正：**\n\n```cpp\n#include <iostream>\n#include <chrono>\n#include <omp.h>\n#include <immintrin.h>\n\n// Define macro for aligning memory to 64 bytes for AVX-512\n#define ALIGNMENT 64\n\ndouble it(double r, double x, int64_t itn) {\n    for (int64_t i = 0; i < itn; i++) {\n        x = r * x * (1.0 - x);\n    }\n    return x;\n}\n\nvoid itv(double r, double* x, int64_t n, int64_t itn) {\n    __builtin_assume_aligned(x, 64);\n    __m512d r_vec=_mm512_set1_pd(r);\n    __m512d vec_1=_mm512_set1_pd(1.0);\n    #pragma omp parallel for collapse(1) \n    #pragma vector aligned\n    for (int64_t i = 0; i < n; i += 64) {\n        __m512d x_vec1 = _mm512_loadu_pd(&x[i]);\n        __m512d x_vec2 = _mm512_loadu_pd(&x[i+8]);\n        __m512d x_vec3 = _mm512_loadu_pd(&x[i+16]);\n        __m512d x_vec4 = _mm512_loadu_pd(&x[i+24]);\n        __m512d x_vec5 = _mm512_loadu_pd(&x[i+32]);\n        __m512d x_vec6 = _mm512_loadu_pd(&x[i+40]);\n        __m512d x_vec7 = _mm512_loadu_pd(&x[i+48]);\n        __m512d x_vec8 = _mm512_loadu_pd(&x[i+56]);\n        for (int64_t j = 0; j < itn; j++) {\n            x_vec1 = _mm512_mul_pd(_mm512_mul_pd(r_vec, x_vec1),\n                                   _mm512_sub_pd(vec_1, x_vec1));\n            x_vec2 = _mm512_mul_pd(_mm512_mul_pd(r_vec, x_vec2),\n                       \t\t\t   _mm512_sub_pd(vec_1, x_vec2));\n            x_vec3 = _mm512_mul_pd(_mm512_mul_pd(r_vec, x_vec3),\n                       \t\t\t   _mm512_sub_pd(vec_1, x_vec3));\n            x_vec4 = _mm512_mul_pd(_mm512_mul_pd(r_vec, x_vec4),\n                       \t\t\t   _mm512_sub_pd(vec_1, x_vec4));\n            x_vec5 = _mm512_mul_pd(_mm512_mul_pd(r_vec, x_vec5),\n                       \t\t\t   _mm512_sub_pd(vec_1, x_vec5));\n            x_vec6 = _mm512_mul_pd(_mm512_mul_pd(r_vec, x_vec6),\n                       \t\t\t   _mm512_sub_pd(vec_1, x_vec6));\n            x_vec7 = _mm512_mul_pd(_mm512_mul_pd(r_vec, x_vec7),\n                       \t\t\t   _mm512_sub_pd(vec_1, x_vec7));\n            x_vec8 = _mm512_mul_pd(_mm512_mul_pd(r_vec, x_vec8),\n           \t\t\t   \t\t\t   _mm512_sub_pd(vec_1, x_vec8));\n        }\n        _mm512_storeu_pd(&x[i], x_vec1);\n        _mm512_storeu_pd(&x[i+8], x_vec2);\n        _mm512_storeu_pd(&x[i+16], x_vec3);\n        _mm512_storeu_pd(&x[i+24], x_vec4);\n        _mm512_storeu_pd(&x[i+32], x_vec5);\n        _mm512_storeu_pd(&x[i+40], x_vec6);\n        _mm512_storeu_pd(&x[i+48], x_vec7);\n        _mm512_storeu_pd(&x[i+56], x_vec8);\n    }\n}\n\nint main(){\n    FILE* fi;\n    fi = fopen(\"conf.data\", \"rb\");\n\n    int64_t itn;\n    double r;\n    int64_t n;\n    double* x;\n\n    fread(&itn, 1, 8, fi);\n    fread(&r, 1, 8, fi);\n    fread(&n, 1, 8, fi);\n\n    // Allocate aligned memory for better AVX-512 performance\n    x = (double*)_mm_malloc(n * 8, ALIGNMENT);\n\n    fread(x, 1, n * 8, fi);\n    fclose(fi);\n\n    auto t1 = std::chrono::steady_clock::now();\n\n    // Use OpenMP for parallelization and AVX-512 for vectorization\n    itv(r, x, n, itn);\n\n    auto t2 = std::chrono::steady_clock::now();\n    int d1 = std::chrono::duration_cast<std::chrono::milliseconds>(t2 - t1).count();\n    printf(\"%d\\n\", d1);\n\n    fi = fopen(\"out.data\", \"wb\");\n    fwrite(x, 1, n * 8, fi);\n    fclose(fi);\n\n    // Free aligned memory\n    _mm_free(x);\n\n    return 0;\n}\n```\n\n\n\n## J.H-66\n\n [H-66.mhtml](H-66.mhtml) \n\n先用了gprof进行了热点分析，结果如下：\n\n![image-20240124102831082](HPCGame记录/image-20240124102831082.png)\n\n可以看到，大部分时间都是花费在了getsp函数上，act函数也是个小热点，\n\n先拿getsp开刀，\n\n1月29日：“遗憾，玩不动这道题”\n\n## L.洪水困兽\n\n [洪水困兽.mhtml](洪水困兽.mhtml) \n\n签到送分题，OpenMP直接过\n\n```cpp\n#include <array>\n#include <fstream>\n#include <iostream>\n#include <omp.h>\n#include <vector>\n#include <cmath>\n#include <tuple>\n\nusing std::vector, std::array, std::tuple, std::string;\n\nvoid particle2grid(int resolution, int numparticle,\n                   const vector<double> &particle_position,\n                   const vector<double> &particle_velocity,\n                   vector<double> &velocityu, vector<double> &velocityv,\n                   vector<double> &weightu, vector<double> &weightv) {\n    double grid_spacing = 1.0 / resolution;\n    double inv_grid_spacing = 1.0 / grid_spacing;\n    auto get_frac = [&inv_grid_spacing](double x, double y) {\n        int xidx = floor(x * inv_grid_spacing);\n        int yidx = floor(y * inv_grid_spacing);\n        double fracx = x * inv_grid_spacing - xidx;\n        double fracy = y * inv_grid_spacing - yidx;\n        return tuple(array<int, 2>{xidx, yidx},\n                     array<double, 4>{fracx * fracy, (1 - fracx) * fracy,\n                                      fracx * (1 - fracy),\n                                      (1 - fracx) * (1 - fracy)});\n    };\n\n    #pragma omp parallel for\n    for (int i = 0; i < numparticle; i++) {\n        array<int, 4> offsetx = {0, 1, 0, 1};\n        array<int, 4> offsety = {0, 0, 1, 1};\n\n        auto [idxu, fracu] =\n            get_frac(particle_position[i * 2 + 0],\n                     particle_position[i * 2 + 1] - 0.5 * grid_spacing);\n        auto [idxv, fracv] =\n            get_frac(particle_position[i * 2 + 0] - 0.5 * grid_spacing,\n                     particle_position[i * 2 + 1]);\n\n        for (int j = 0; j < 4; j++) {\n            int tmpidx_u = (idxu[0] + offsetx[j]) * resolution + (idxu[1] + offsety[j]);\n            int tmpidx_v = (idxv[0] + offsetx[j]) * (resolution + 1) + (idxv[1] + offsety[j]);\n//关键点就在这里,知道有这个操作就能签到成功，但看到有人手写锁好像也成功了\n            #pragma omp atomic\n            velocityu[tmpidx_u] += particle_velocity[i * 2 + 0] * fracu[j];\n\n            #pragma omp atomic\n            weightu[tmpidx_u] += fracu[j];\n\n            #pragma omp atomic\n            velocityv[tmpidx_v] += particle_velocity[i * 2 + 1] * fracv[j];\n\n            #pragma omp atomic\n            weightv[tmpidx_v] += fracv[j];\n        }\n    }\n}\n\nint main(int argc, char *argv[]) {\n    if (argc < 2) {\n        printf(\"Usage: %s inputfile\\n\", argv[0]);\n        return -1;\n    }\n\n    string inputfile(argv[1]);\n    std::ifstream fin(inputfile, std::ios::binary);\n    if (!fin) {\n        printf(\"Error opening file\");\n        return -1;\n    }\n    \n    int resolution;\n    int numparticle;\n    vector<double> particle_position;\n    vector<double> particle_velocity;\n\n    fin.read((char *)(&resolution), sizeof(int));\n    fin.read((char *)(&numparticle), sizeof(int));\n    \n    particle_position.resize(numparticle * 2);\n    particle_velocity.resize(numparticle * 2);\n    \n    printf(\"resolution: %d\\n\", resolution);\n    printf(\"numparticle: %d\\n\", numparticle);\n    \n    fin.read((char *)(particle_position.data()),\n             sizeof(double) * particle_position.size());\n    fin.read((char *)(particle_velocity.data()),\n             sizeof(double) * particle_velocity.size());\n\n    vector<double> velocityu((resolution + 1) * resolution, 0.0);\n    vector<double> velocityv((resolution + 1) * resolution, 0.0);\n    vector<double> weightu((resolution + 1) * resolution, 0.0);\n    vector<double> weightv((resolution + 1) * resolution, 0.0);\n\n\n    string outputfile;\n\n    particle2grid(resolution, numparticle, particle_position,\n                    particle_velocity, velocityu, velocityv, weightu,\n                    weightv);\n    outputfile = \"output.dat\";\n\n    std::ofstream fout(outputfile, std::ios::binary);\n    if (!fout) {\n        printf(\"Error output file\");\n        return -1;\n    }\n    fout.write((char *)(&resolution), sizeof(int));\n    fout.write(reinterpret_cast<char *>(velocityu.data()),\n               sizeof(double) * velocityu.size());\n    fout.write(reinterpret_cast<char *>(velocityv.data()),\n               sizeof(double) * velocityv.size());\n    fout.write(reinterpret_cast<char *>(weightu.data()),\n               sizeof(double) * weightu.size());\n    fout.write(reinterpret_cast<char *>(weightv.data()),\n               sizeof(double) * weightv.size());\n\n    return 0;\n}\n```\n\n## 其余题：\n\n [光之游戏.mhtml](光之游戏.mhtml) \n\n [3D生命游戏.mhtml](3D生命游戏.mhtml) \n\nRISC-V的题没有放\n","tags":["比赛"]},{"title":"计算机组成原理-(1)","url":"/2024/01/22/计算机组成原理一/","content":"\n# 前言知识：\n\n等差数列公式：\n$$\na_n=a_1+(n-1)d\\\\\nS_n=\\frac {n(a_1+a_n)}{2}=na_1+\\frac {n(n-1)}{2}d\n$$\n等比数列公式：\n$$\na_n=a_1q^{n-1}(q\\neq0)\\\\\nS_n=\\frac {a_1(1-q^n)}{1-q}=\\frac{a_1-a_nq}{1-q}\n$$\n\n\n# 一、计算机系统概论\n\n## 1.1计算机系统简介\n\n**物联网：**把<font color=red>传感器</font>嵌入和装备到各种物体中，并且被普遍连接\n\n计算机系统由<u>**硬件**</u>和<u>**软件**</u>组成\n\n- 硬件：计算机的实体，如主机、外设等\n\n- 软件：由具有各类特殊功能的程序组成 \n\n  ```\n  系统软件：用来管理整个计算机系统，如语言处理程序、操作系统、服务性程序、数据库管理系统、网络软件(如tcp/ip协议的模块)\n  应用软件：按任务需要贬值的各种程序\n  ```\n\n## 1.2计算机硬件基本组成\n\n### 1.2.1冯诺依曼机\n\n第一台计算机ENIAC(埃尼亚克)通过手动接线的方式进行控制计算，效率受到接线的限制\n\n冯诺依曼提出“**存储程序**”：将指令以二进制代码的形式实现输入到计算机的主存储器，然后从首地址开始按序执行指令\n\n**早期冯诺依曼体系结构：**\n\n![image-20240122152233293](计算机组成原理一/image-20240122152233293.png)\n\n<img src=\"计算机组成原理一/image-20240122152116407.png\" alt=\"image-20240122152116407\" style=\"zoom:80%;\" />\n\n步骤：\n\n```\n数据或程序先进入输入设备，将信息转换为机器能识别的形式\n数据通过运算器进行中转到存储器中\n控制器读入存储器中的运算指令（加、乘等）控制运算器做算术运算或逻辑运算\n经过运算后的数据通过输出设备转换为人们能识别的结果\n```\n\n冯诺依曼计算机的特点：\n\n```\n计算机由五大部分组成：输入设备、输出设备、控制器、运算器、存储器\n指令和数据以同等地位存于存储器，可按址寻访\n指令和数据用二进制表示\n指令由操作码和地址码组成\n存储程序：提前把指令和数据存储到存储器中\n以运算器为中心（输入/输出与存储器之间的数据传输通过运算器完成）\n```\n\n### 1.2.2现代计算机的结构\n\n以<font color=red>**存储器**</font>为中心\n\n<img src=\"计算机组成原理一/image-20240122154625927.png\" alt=\"image-20240122154625927\" style=\"zoom:80%;\" />\n\nCPU=运算器+控制器\n\n![image-20240122154923848](计算机组成原理一/image-20240122154923848.png)\n\n<img src=\"计算机组成原理一/image-20240122192046146.png\" alt=\"image-20240122192046146\" style=\"zoom:80%;\" />\n\n**主存：**RAM运行内存\n\n**辅存：**ROM存储大小\n\n### 1.2.3主存储器\n\n![image-20240122210202202](计算机组成原理一/image-20240122210202202.png)\n\n**读取：**CPU将地址传入MAR，从MDR获得数据，控制器控制主存储器执行\"读\"操作\n\n**写入：**CPU将地址传入MAR，数据传入MDR，控制器控制主存储器进行\"写\"操作\n\n**【存储体】：**\n\n数据都在存储体内按<font color=red>地址</font>存储\n\n![image-20240203175618433](计算机组成原理一/image-20240203175618433.png)\n\n存储单元：存储器最小的存储单位，是一串存放二进制代码的空间\n\n存储字（word）：存储单元中二进制代码的组合\n\n存储字长：存储单元中二进制代码的位数（通常为8bit的整数倍）\n\n存储元：用于存储二进制的的电子元件（电容），每个存储元可以存1bit\n\n因此，MAR位数可以反映存储单元的个数，MDR的位数等于存储字长\n\n### 1.2.4运算器\n\n用于实现算术运算（加减乘除），逻辑运算（布尔运算）\n\n![image-20240203175555484](计算机组成原理一/image-20240203175555484.png)\n\n```\nACC:累加器。用于存放操作数或运算结果。\nMQ:乘商寄存器，在乘除运算时，用于存放操作数或运算结果。\nX：通用操作数寄存器，用于存放操作数\nALU：算术逻辑单元，通过内部电路实现算数运算，逻辑运算。\n```\n\n![image-20240203151052252](计算机组成原理一/image-20240203151052252.png)\n\n### 1.2.5控制器\n\n![image-20240203175515496](计算机组成原理一/image-20240203175515496.png)\n\n```\nCU(Control Unit):控制单元，分析指令，给出控制信号\nIR(Instruction Register):指令寄存器，存放当前执行的指令\nPC(Program Counter):存放下一跳指令的地址，有自动加1的功能\n```\n\n完成一条指令需要：\n\n从PC取指令放入IR中，CU分析IR中的指令，从而控制其他配件进行指令执行\n\n![image-20240203153331340](计算机组成原理一/image-20240203153331340.png)\n\n[bilibili视频直达](https://www.bilibili.com/video/BV1ps4y1d73V/?p=5&spm_id_from=333.1007.top_right_bar_window_history.content.click&vd_source=10960c964c9089624e6f92b8d20ed3e0)\n\n## 1.3计算机系统的层次结构\n\n![image-20240203155707352](计算机组成原理一/image-20240203155707352.png)\n\n下层是上层的基础，上层是下层的拓展。\n\n\n\n**编译程序：**将高级语言编写的源程序全部语句一次性翻译成机器语言程序，而后直接执行机器语言程序(.exe)，如C/C++，Java\n\n**解释程序：**将源程序的一条语句翻译成对应的机器语言的雨具，并立即执行，紧接着翻译下一句（每次执行都要翻译）如Python、JavaScript、shell\n\n![image-20240203160113764](计算机组成原理一/image-20240203160113764.png)\n\n## 1.4计算机性能指标\n\n### 1.4.1存储器的性能指标\n\n**总容量：**\n\n- 存储单元个数*存储字长 bit\n- 存储单元个数*存储字长/8 Byte\n\nEg：MAR为32位，MDR为8位\n$$\n总容量 = 2^{32}*8=32Gbit=4GB\n$$\nMAR位数反映存储单元的个数，MDR位数反映每个存储单元的大小\n\n### 1.4.2CPU的性能指标\n\n$$\nK=Kilo=千=10^3\\\\\nM=Milion=百万=10^6\\\\\nG=Giga=十亿=10^9\\\\\nT=Tera=万亿=10^{12}\n$$\n\nK、M、G 和 T 在不同上下文中可以表示不同的含义，具体取决于是以 2 的 10 次方（1024 的倍数）还是以 10 的 3 次方（1000 的倍数）为基础。\n\n1. **二进制（以 2 为基础）：**\n\n   - K 表示 2^10，即 1024。\n   - M 表示 2^20，即 1024 * 1024。\n   - G 表示 2^30，即 1024 * 1024 * 1024。\n   - T 表示 2^40，即 1024 * 1024 * 1024 * 1024。\n\n   在计算机领域，通常使用二进制定义存储容量，如硬盘容量、内存大小等。\n\n2. **十进制（以 10 为基础）：**\n\n   - K 表示 10^3，即 1000。\n   - M 表示 10^6，即 1000 * 1000。\n   - G 表示 10^9，即 1000 * 1000 * 1000。\n   - T 表示 10^12，即 1000 * 1000 * 1000 * 1000。\n\n   在一些其他上下文，如国际制度和网络速度，通常使用十进制定义单位，表示文件大小、带宽等。\n\n**(1)CPU主频：**\n\nCPU内数字脉冲信号振荡的频率\n$$\nCPU主频（时钟频率）=1/CPU时钟周期\n$$\n**(2)CPI（Clock cycle Per Instruction）**\n\n执行一条指令所需要的时钟周期（不同的指令CPI不同，甚至相同的指令CPI也会有变化）\n\n<font color=red>执行一条指令的耗时</font>=CPI*CPU时钟周期\n\nEg：某CPU主频为1000Hz，某程序包含100条指令，平均来看指令的CPI=3，则该程序要在该CPU上执行完成需要多久？\n$$\n100*3*(1/1000)=0.3s\n$$\n**(3)IPS  (Instructions Per Second)**\n\n每秒执行多少条指令\n\nIPS = 1/(CPI*时钟周期)= 主频/CPI\n\n**(4)FLOPS (Floating-point Operations Per Second)**\n\n每秒执行多少次浮点运算\n\n### 1.4.3系统整体性能指标\n\n(1)数据通路带宽：数据总线一次能并行传送的位数\n\n(2)吞吐量：系统在单位时间内处理请求的数量\n\n(3)响应时间：指的是用户向计算机发送一个请求到系统对该请求做出响应并获得所需要的结果的等待时间\n\n# 二、数据的表示和运算\n\n## 2.1 进位计数制\n\n$$\n二进制:0,1\\\\\n八进制:0,1,2,3,4,5,6,7\\\\\n十进制:0,1,2,3,4,5,6,7,8,9\\\\\n十六进制:0,1,2,3,4,5,6,7,8,9,A,B,C,D,E,F\\\\\n$$\n\n\n$$\n二进制：101.1->1*2^2+2*2^1+1*2^0+1*2^{-1}=5.5 \\\\\n八进制：5.4->5*8^0+4*8^{-1}=5.5\\\\\n十进制：5.5->5*10^1+5*10^{-1}=5.5\\\\\n十六进制：5.8->5*16^0+8*16^{-1}=5.5\n$$\n类推：r进制计数法\n$$\n(K_nK_{n-1}...K_2K_1K_0K_{-1}K_{-2}...K_{-m})整体的一个数转十进制  \\\\\n=K_n*r^n+K_{n-1}*r^{n-1}+...+K_2*r^2+K_1*r^1+K_0*r_0+K_{-1}*r^{-1}+K_{-2}*r^{-2}+...+K_{-m}*r^{-m}\n$$\n**十进制转换任意进制**\n\n![image-20240203192543394](计算机组成原理一/image-20240203192543394.png)\n\n![image-20240203193019989](计算机组成原理一/image-20240203193019989.png)\n\n[二进快速制转换八进制和十六进制](https://cooc.cqmu.edu.cn/Course/KnowledgePoint/14960.aspx?AspxAutoDetectCookieSupport=1)\n\n```\n真值：人类习惯的数字\n机器数：数字实际存在机器里的形式（正负号需要被“数字化”，0表示正，1表示负）\n\n+15  0 1111\n-8\t 1 1000\n```\n\n## 2.2 BCD码\n\n### 2.2.1 8421码\n\n![image-20240203193932518](计算机组成原理一/image-20240203193932518.png)\n\n每4bit表示一个数字，如12就可以表示为“0001 0010”的形式\n$$\n十进制:5+8=13\\\\\n8421码:0101+1000=1101(不在映射表中)\\\\\n如果不在映射表内，8421中1010~1111没有意义\\\\\n+6(0110)修正即可\\\\\n0101+1000=1101+0110=0001\\quad0011\n$$\n注意：如果在映射表中就无需修正。\n\n### 2.2.2 余3码\n\n余3码：8421码+(0011)\n\n![image-20240203194903126](计算机组成原理一/image-20240203194903126.png)\n\n### 2.2.3 2421码\n\n![image-20240203195017632](计算机组成原理一/image-20240203195017632.png)\n\n前五个数字第一位都为0，后五个数字第一位都为1\n\n## 2.3无符号整数的加减法运算\n\n- ![image-20240205144647536](计算机组成原理一/image-20240205144647536.png)\n\n### 2.3.1无符号整数的加法运算\n\n**计算机硬件：**从最低位开始，按位相加，并往更高位进位\n\n![image-20240205144805187](计算机组成原理一/image-20240205144805187.png)\n\n### 2.3.2无符号整数的减法运算\n\n**计算机硬件：**\"被减数\"不变，\"减数\"全部按位取反，末尾+1，减法变加法（加法电路造价便宜）---数论\n\n![image-20240205145050472](计算机组成原理一/image-20240205145050472.png)\n\n\n\n## 2.4带符号整数(定点整数)在计算机中的应用\n\n带符号整数的表示：原码、补码、反码\n\n（同一个含义，只是编码方式不同，不同的编码方式有不同的优缺点）\n\n![image-20240205181042323](计算机组成原理一/image-20240205181042323.png)\n\n### 2.4.1原码\n\n![image-20240205145757764](计算机组成原理一/image-20240205145757764.png)\n\n符号位\"0\"表示正，\"1\"表示负，剩余的为数值位\n\n若机器字长为**n+1**位，则原码表示范围为\n$$\n-(2^{n}-1)\\leq x \\leq 2^n-1\n$$\n真值0有两种形式，+0和-0, [+0]原=0 0000000，[-0]原=1 0000000\n\n#### 原码的缺点\n\n符号位不能参与运算，需要设计复杂的硬件电路才能处理\n\n![image-20240205150427986](计算机组成原理一/image-20240205150427986.png)\n\n### 2.4.2补码\n\n![image-20240205150537453](计算机组成原理一/image-20240205150537453.png)\n\n补码转反码只需要末位-1即可，但是操作麻烦，所以可以先用补码算出原码，再转反码，以下为方法2：\n\n此为手算快速转换技巧，计算机中并不是这样实现的\n\n![image-20240205151427416](计算机组成原理一/image-20240205151427416.png)\n\n#### 补码的加法运算\n\n计算机硬件从最低位开始，按位相加（符号位参与运算），并往更高位进位\n\n![image-20240205154907313](计算机组成原理一/image-20240205154907313.png)\n\n#### 补码的减法运算\n\n![image-20240205155804452](计算机组成原理一/image-20240205155804452.png)\n\n注意：原码转补码符号位不用按位取反，补码转补码的负要全部位按位取反。\n\n无符号整数和有符号整数的减法都是全部位按位取反末位+1，所以可以用同一套电路\n\n![image-20240205180517867](计算机组成原理一/image-20240205180517867.png)\n\n### 2.4.3移码\n\n补码的基础上将符号位取反。注意：移码用于表示整数\n\n![image-20240205180910511](计算机组成原理一/image-20240205180910511.png)\n\n## 2.5定点小数\n\n<font color=green>定点整数</font>的编码表示：原码、反码、补码、移码\n\n<font color=red>定点小数</font>的编码表示：原码、反码、补码\n\n### 2.5.1定点小数原码、反码、移码\n\n![image-20240205181911503](计算机组成原理一/image-20240205181911503.png)\n\n![image-20240205182022160](计算机组成原理一/image-20240205182022160.png)\n\n![image-20240205184110792](计算机组成原理一/image-20240205184110792.png)\n\n## 2.6奇偶校验码\n\n**奇校验码：**整个校验码（有效信息位和校验位）中“1”的个数为奇数。\n\n**偶校验码：**整个校验码（有效信息位和校验位）中“1”的个数为偶数。\n\n![image-20240205185809301](计算机组成原理一/image-20240205185809301.png)\n\nEg：给出两个编码1001101和1010111\n\n奇校验：<font color=red>1</font>1001101\t\t<font color=red>0</font>1010111\n\n偶校验：<font color=green>0</font>1001101\t\t<font color=green>1</font>1010111\n\n**奇偶校验码的局限性：**如果发生了两个位置的错误，会出现校验不出的情况\n\n**硬件实现偶校验**通过异或（⊕）运算求得校验位\n\n1⊕0⊕0⊕1⊕1⊕0⊕1=0所以第一个编码的偶校验位为0\n\n## 2.7符号拓展\n\n![image-20240205234947265](计算机组成原理一/image-20240205234947265.png)\n\n注意负数反码和补码的拓展！\n\n# 三、电路的实现\n\n## 3.1算术逻辑单元（ALU）--Arithmetic and Logic Unit\n\n![image-20240205191909131](计算机组成原理一/image-20240205191909131.png)\n\n## 3.2门电路：\n\n![img](计算机组成原理一/u=3886467858,546682409&fm=253&fmt=auto&app=138&f=PNG.png)\n\n**<font color=red>运算优先级</font>**：与>或\n\n## 3.3布尔运算定律\n\n![image-20240205205622135](计算机组成原理一/image-20240205205622135.png)\n\n## 3.4一位全加器\n\n如同手算一样，从低位到高位进行加法运算\n\n![image-20240205211137735](计算机组成原理一/image-20240205211137735.png)\n\n### 3.4.1串行加法器\n\n#### 3.4.1.1单串行加法器\n\n只有一个全加器，数据逐位串行送入到加法器中进行计算，进位触发器用来寄存进位信号，以便下一次运算。\n\n如果操作数长位n位，则要进行n次运算，每次产生一位和，并且逐位送回寄存器中，这样效率不高。\n\n![image-20240205211809002](计算机组成原理一/image-20240205211809002.png)\n\n#### 3.4.1.2串行进位的加法器\n\n把n个全加器串接起来，可以进行两个n位数的相加。\n\n![image-20240205212245672](计算机组成原理一/image-20240205212245672.png)\n\n始终依赖于低位的进位信号，运算速度还是比较慢。\n\n### 3.4.2并行加法器\n\n$$\n对于每一位都要进行\\\\C_i=A_iB_i+(A_i⊕B_i)C_{i-1}\\\\S_i=A_i⊕B_i⊕C_{i-1}\n\\\\设G_i=A_iB_i \\quad P_i=A_0⊕B_0\n\\\\则原式=G_i+P_iC_{i-1}\n\\\\\n\\\\\n通过展开可得：\\\\\nC_1=G_1+P_1C_0\\\\\nC_2=G_2+P_2C_1=G_2+P_2G_1+P_2P_1C_0\\\\\nC_3=G_3+P_3C_2=G_3+P_3G_2+P_3P_2G_1+P_3P_2P_1C_0\n\\\\...\n\\\\C_i的值依赖于P、G、C_0，因此可以直接进行并行计算\n\\\\第i项中的P_iC_{i-1}在后续项中均存在，所以可以设计简化一下电路\n$$\n\n![image-20240205220840672](计算机组成原理一/image-20240205220840672.png)\n\n继续展开会导致电路越来越复杂，一般只展开4个(4个FA)形成4位的CLA加法器\n\n![image-20240205222133269](计算机组成原理一/image-20240205222133269.png)\n\n## 3.5补码加减运算器\n\n**基本（手算）方法：**\n\n```\nn bit的补码X+Y：按位相加即可\nn bit的补码X-Y：将补码Y全部按位取反，末位+1，得到[-Y]补，减法变为了加法\n```\n\n![image-20240205224540144](计算机组成原理一/image-20240205224540144.png)\n\nsub=1即采用减法操作，非门对Y进行按位取反，Cin=Sub=1即对Y的末尾+1得到[-Y]补\n\n**此电路同时也适合无符号数的加减法运算**\n\n## 3.6加减溢出判断\n\n$$\n[A+B]_补=A_补+B_补\\\\\n[A-B]_补=A_补+[-B]_补\n$$\n\n只有“正数+正数”才会<font color=red>**上溢**</font>--正+正=负\n\n只有“负数+负数”才会<font color=red>**下溢**</font>--负+负=正\n\n### 3.6.1溢出判断方法一\n\n可以根据上面的规律得到真值表\n\n![image-20240206002645564](计算机组成原理一/image-20240206002645564.png)\n\n$$\nV=A_sB_s\\overline S_s + \\overline A_s\\overline B_sS_s\\\\\nA_s表示第一个数的符号位，B_s表示第二个数的符号位，S_s表示最终结果符号位\n$$\n\n若V=0，表示无溢出；\n\n若V=1，表示有溢出。\n\n### 3.6.2溢出判断方法二\n\n采用符号位进位和最高数值位的进位进行异或⊕运算判断\n\n![image-20240206003024065](计算机组成原理一/image-20240206003024065.png)\n\n![image-20240206002710848](计算机组成原理一/image-20240206002710848.png)\n$$\nV=C_s⊕C_1\n$$\n\n### 3.6.3溢出判断方法三\n\n采用双符号位，正数的符号位为00，负数的符号位为11\n\n![image-20240205233933203](计算机组成原理一/image-20240205233933203.png)\n\n对两个符号位S1S2进行异或运算即可\n\n**<font color=red>拓展：</font>**\n\n1. 双符号位补码又称为模4补码，单符号位补码又称为模2补码\n2. 双符号位实际存储时只存储一个符号位，运算时会复制一个符号位，不会增加存储空间\n\n## 3.7标志位的生成\n\n![image-20240206002729636](计算机组成原理一/image-20240206002729636.png)\n\n<font color=red>**注意：**</font>OF(Overflow Flag)和SF(Sign Flag)只对**有符号数**加减运算有意义，CF(Carry Flag)只对**无符号数**加减运算有意义，ZF(Zero Flag)均有意义。\n\n![image-20240206000841222](计算机组成原理一/image-20240206000841222.png)\n\n## 3.8移位运算\n\n注意：由于原、反、补码的位数有限，因此某些时候移位操作不能精确等效于乘、除法。\n\n### 3.8.1算数移位\n\n**移位：**通过改变各个数值位和小数点的相对位置，改变各个数值位的位权，实现乘除法运算\n$$\nr进制数：K_nK_{n-1}...K_2K_1K_0K_{-1}K_{-2}...K{-n}\n\\\\小数点前移x位相当于÷r^x\n\\\\小数点后移相当于×r^x\n$$\n![image-20240206122447048](计算机组成原理一/image-20240206122447048.png)\n\n#### 3.8.1.1原码的算数移位\n\n符号位保持不变，仅对数值位进行位移。\n\n**右移：**高位补0，低位舍弃。若舍弃的位=0，则相当于÷r，若舍弃的位≠0，则丢失相应的精度\n\n![image-20240206121350996](计算机组成原理一/image-20240206121350996.png)\n\n**左移：**低位补0，高位舍弃。若舍弃的位=0，则相当于×r，若舍弃的位≠0，则会出现错误\n\n![image-20240206121305855](计算机组成原理一/image-20240206121305855.png)\n\n#### 3.8.1.2反码的算数移位\n\n反码<u>**正数**</u>的算数位移与原码的一样，\n\n负数由于反码数值位于原码相反，因此，\n\n**右移：**高位补1，低位舍弃。\n\n**左移：**低位补1，高位舍弃。\n\n#### 3.8.1.3补码的算数移位\n\n补码**<u>正数</u>**的算数移位与原码一样，\n\n**负数**规则如下：\n\n![image-20240206122220103](计算机组成原理一/image-20240206122220103.png)\n\n### 3.8.2逻辑移位\n\n**逻辑右移：**高位补0，低位舍弃\n\n**逻辑左移：**低位补0，高位舍弃。\n\n可以看做是对”无符号数“的算数移位\n\n![image-20240206122743175](计算机组成原理一/image-20240206122743175.png)\n\n### 3.8.3循环移位\n\n普通循环移位：\n\n![3](计算机组成原理一/3.gif)\n\n带进位位的循环移位：\n\n方法相同，只是要考虑进位位CF\n\n![image-20240206123754559](计算机组成原理一/image-20240206123754559.png)\n\n应用：大端和小端存储之间的转换\n\n## 3.9乘除法运算\n\n### 3.9.1原码的乘法运算\n\n**手算：**\n\n![image-20240206125053826](计算机组成原理一/image-20240206125053826.png)\n\n**机器实现：**\n$$\n设机器字长为n+1=5位(含1个符号位)，[x]_原=1.1101，[y]_原=0.1011，采用原码一位乘法求xy\n\\\\符号位单独处理:符号位=x_s⊕y_s\n\\\\数值位取绝对值进行乘法运算:[|x|]_原=0.1101，[|y|]_原=0.1011\n$$\n![image-20240206130607736](计算机组成原理一/image-20240206130607736.png)\n\n到最后一步，要处理符号位，\n\n![image-20240206130754825](计算机组成原理一/image-20240206130754825.png)\n\n小数点隐含在符号位后面，乘数的符号位不用参与真正的运算，只需要与被乘数的符号位进行异或运算\n\n**手算模拟方法：**\n\n![image-20240206131310285](计算机组成原理一/image-20240206131310285.png)\n\n### 3.9.2补码的乘法运算\n\n![image-20240206133738224](计算机组成原理一/image-20240206133738224.png)\n\n![image-20240206133643035](计算机组成原理一/image-20240206133643035.png)\n\n### 3.9.3定点数的除法运算\n\n[王道视频地址](https://www.bilibili.com/video/BV1ps4y1d73V/?p=24&spm_id_from=pageDriver&vd_source=10960c964c9089624e6f92b8d20ed3e0)\n\n#### **3.9.3.1原码除法：恢复余数法**\n\n$$\n设机器字长为5位（1位符号位,n=4），x=0.1011,y=0.1101，求x/y\n\\\\|x|=0.1011,|y|=0.1101,[|y|]_补=0.1101,[-|y|]_补=1.0011\n\\\\符号位单独处理:符号位=x_s⊕y_s\n\\\\数值位取绝对值进行除法计算。\n$$\n\n初始状态：\n\n![image-20240206150210054](计算机组成原理一/image-20240206150210054.png)\n\n计算机会默认**商1**，如果商1出现问题再进行商0，并“恢复余数”。\n\n![image-20240206150630659](计算机组成原理一/image-20240206150630659.png)\n\n此时发现ACC-(除数)得到的结果是一个**负数**，所以ACC是比除数小的，所以应该商0，于是：\n\n更改为商0，并将ACC+(除数)，将结果送回ACC，恢复原本余数\n\n![image-20240206151038661](计算机组成原理一/image-20240206151038661.png)\n\n此时这一位商已经计算完成，通过逻辑左移，末尾置零，计算下一位。\n\n根据机器字长进行计算，直到计算完成，注意，最后一位商的余数为负的话也需要恢复余数并商0\n\n![image-20240206151615123](计算机组成原理一/image-20240206151615123.png)\n\n最终答案的符号位用异或运算得到\n\n**手算模拟：**\n\n![image-20240206152008434](计算机组成原理一/image-20240206152008434.png)\n\n#### 3.9.3.2原码除法：加减交替法（不恢复余数法）\n\n![image-20240206154651802](计算机组成原理一/image-20240206154651802.png)\n\n符号位的确定还是需要异或运算，\n\n在最后一步如果余数为负，需商0，并+[|y|]补得到正确的余数\n\n### 3.9.4补码的除法运算\n\n采用加减交替法，要让符号位参与运算，被除数/余数，除数都采用双符号位\n\n![image-20240206155634184](计算机组成原理一/image-20240206155634184.png)\n\n## 补充：C语言强制类型转换\n\nC语言中定点整数是用“补码”存储的。\n\n\n\n无符号数与有符号数：不改变数据内容，只是改变解释方式\n\n```C\nvoid main(){\n\tshort x=-4321;//short类型占用2个字节\n    unsigned short y = (unsigned short)x;\n}\n```\n\n长整数便短等输，高位截断，保留低位\n\n```c\nvoid main(){\n\tint a=165537,b=-34991;\n\tshort c=(short)a,d=(short)b;\n    //a:0x000286a1 c:0x86a1 真值：-31071\n    //b:0xffff7751 d:0x7751 真值：30545\n}\n```\n\n短整数变长整数，符号拓展\n\n```c\nvoid main(){\n\tshort x=-4321;\n\tint m=x;\n\tunsigned short n=(unsigned short)x;\n\tunsigned int p=n;\n    //x:1110 1111 0001 1111  0xef1f\n    //m:1111 1111 1111 1111 1110 1111 0001 1111 0xffffef1f 真值:-4321\n    //n:1110 1111 0011 1111 0xef1f 真值：61215\n    //p:0000 0000 0000 0000 1110 1111 0001 1111 0x0000ef1f 真值:61215\n}\n```\n\n","tags":["计算机基础"]},{"title":"教务系统选课脚本(正方-urp)","url":"/2022/02/05/教务系统选课脚本正方-urp/","content":"\n共三个脚本，一个urp、一个正方教务、一个西南石油大学新版教务，代码都大同小异\n\n# urp教务系统\n\n第一次写爬虫相关的东西，也是第一次写UI界面，过于潦草，但功能没问题，使用tkinter实现的UI界面\n\n```python\nimport time\nimport tkinter.messagebox as messagebox\nimport tkinter as tk\nimport random\nimport winsound\nimport requests\nfrom PIL import Image, ImageTk\nimport threading\nimport os\nfrom lxml import etree\n\nheaders = {\n        'Content-Type': 'application/x-www-form-urlencoded',\n        'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:104.0) Gecko/20100101 Firefox/104.0',\n    }\ncookies = {}\nurp_url = '1'\nthread_class_flag = True #选课线程标志\nclass_inf = '2'\nclass LoginWindow:\n    def __init__(self):\n        self.window = tk.Tk()\n        self.window.title(\"登录\")\n        self.window.geometry(\"300x200\")\n        self.window.resizable(0,0)\n        self.window.iconbitmap('ic.ico')\n        start_url = set_urp_url()\n        self.username_label = tk.Label(self.window, text=\"当前登录网址：\" + urp_url)\n        self.username_label.place(x=30, y=0)\n        # 用户名输入框\n        self.username_label = tk.Label(self.window, text=\"用户名：\")\n        self.username_label.place(x=50, y=30)\n        self.username_entry = tk.Entry(self.window, width=20)\n        self.username_entry.place(x=110, y=30)\n\n        # 密码输入框\n        self.password_label = tk.Label(self.window, text=\"密码：\")\n        self.password_label.place(x=50, y=70)\n        self.password_entry = tk.Entry(self.window, width=20)\n        self.password_entry.place(x=110, y=70)\n\n        # 验证码输入框\n        self.verify_label = tk.Label(self.window, text=\"验证码：\")\n        self.verify_label.place(x=50, y=110)\n        self.verify_entry = tk.Entry(self.window, width=10)\n        self.verify_entry.place(x=110, y=110)\n\n        def on_enter(event):\n            event.widget.tk_focusNext().focus()\n        def on_enter_code(event):\n            self.login()\n        #绑定事件，回车换输入框\n        self.username_entry.bind(\"<Return>\",on_enter)\n        self.password_entry.bind(\"<Return>\",on_enter)\n        self.verify_entry.bind(\"<Return>\",on_enter_code)\n        # 验证码图片\n        def refresh_code():\n            start_url.getcode()\n            self.verify_image = Image.open(\"code.png\")\n            self.verify_image = ImageTk.PhotoImage(self.verify_image)\n            self.verify_button.config(image=self.verify_image)\n        start_url.getcode()\n        self.verify_image = Image.open(\"code.png\")\n        self.verify_image = ImageTk.PhotoImage(self.verify_image)\n        self.verify_button = tk.Button(self.window, command=refresh_code)\n        self.verify_button.config(image=self.verify_image)\n        self.verify_button.place(x=190, y=110)\n\n        # 登录按钮\n        self.login_button = tk.Button(self.window, width=10, text=\"登录\", command=self.login)\n        self.login_button.place(x=120, y=150)\n\n        try:\n            with open(\"user.txt\", \"r\") as file:\n                lines = file.readlines()\n                if len(lines) >= 1:\n                    self.username_entry.insert(0, lines[0].strip())  # 填充第一个输入框\n                if len(lines) >= 2:\n                    self.password_entry.insert(0, lines[1].strip())  # 填充第二个输入框\n        except FileNotFoundError:\n            print(\"找不到user.txt文件\")\n        self.window.mainloop()\n\n    def login(self):\n        url = urp_url + '/loginAction.do'\n        print(url)\n        while True:\n            data = {\n                'zjh1': '',\n                'tips': '',\n                'lx': '',\n                'evalue': '',\n                'eflag': '',\n                'fs': '',\n                'dzslh': '',\n                'zjh': self.username_entry.get(),\n                'mm': self.password_entry.get(),\n                'v_yzm': self.verify_entry.get(),\n            }\n\n            print(\"用户名：\", data[\"zjh\"])\n            print(\"密码：\", data['mm'])\n            print(\"验证码：\", data['v_yzm'])\n            try:\n                response = requests.session().post(url=url, headers=headers, cookies=cookies, data=data, timeout=90).text\n                tree = etree.HTML(response)\n                login_staut = tree.xpath('//head/title/text()')[0]\n                print(login_staut)\n                if login_staut != '学分制综合教务':\n                    login_staut = tree.xpath('//td[@class=\"errorTop\"]/strong/font/text()')[0]\n                    print(login_staut)\n                    messagebox.showinfo('错误',login_staut)\n                    raise Exception\n                break\n            except:\n                return\n        while True:\n            try:\n                requests.get(urp_url + '/xkAction.do', headers=headers, cookies=cookies, timeout=90)\n                break\n            except:\n                return\n        self.window.destroy()\n\n        # 打开\"user.txt\"文件以写入模式\n        with open(\"user.txt\", \"w\") as file:\n            file.write(data['zjh'] + \"\\n\")\n            file.write(data['mm'] + \"\\n\")\n        print(\"已将文本写入user.txt文件。\")\n        menu(data['zjh'])\n\nclass menu:\n    def __init__(self,user):\n        root = tk.Tk()\n        root.title(\"当前用户：\"+user)\n        root.geometry(\"400x300\")  # 设置窗口大小\n        root.resizable(0, 0)\n        root.iconbitmap('ic.ico')\n        # 添加标题\n        lbl_title = tk.Label(root, text=\"urp TOOL\", font=(\"Arial\", 20))\n        lbl_title.pack(pady=10)\n\n        # 添加按钮\n        def class_table():\n            url = urp_url + '/xkAction.do?actionType=6'\n            response = requests.get(url, headers=headers, cookies=cookies)\n            with open(\"cx.html\", 'wb') as fp:\n                fp.write(response.content)\n            os.system('cx.html')\n        btn_query = tk.Button(root, text=\"查询课表\", width=15, height=2,command=class_table)\n        btn_query.pack(pady=5)\n\n        def select_class():\n            root.withdraw()\n            class_window = tk.Toplevel(root)\n            class_window.title(\"选课:\"+user)\n            class_window.geometry(\"355x460\")\n            class_window.resizable(0, 0)\n            class_window.iconbitmap(\"ic.ico\")\n            def closing():\n                root.deiconify()\n                class_window.destroy()\n            class_window.protocol('WM_DELETE_WINDOW',closing)\n            label1 = tk.Label(class_window,text = \"课程号\")\n            label1.grid(row=0,column=0)\n            entry1 = tk.Entry(class_window)\n            entry1.grid(row=0,column=1)\n            label1 = tk.Label(class_window, text=\"课序号\")\n            label1.grid(row=1, column=0)\n            entry2 = tk.Entry(class_window)\n            entry2.grid(row=1, column=1)\n            def add_class():\n                input1 = entry1.get()\n                input2 = entry2.get()\n                if not (input1 == '' and input2==''):\n                    classbox.insert(tk.END, f\"{input1},{input2}\")\n            def delete_selected_class():\n                selected_class = classbox.curselection()\n                if selected_class:\n                    classbox.delete(selected_class)\n            button1 = tk.Button(class_window,text='添加课程',command=add_class)\n            button1.grid(row=0,column=2)\n            button2 = tk.Button(class_window, text='删除课程', command=delete_selected_class)\n            button2.grid(row=1, column=2)\n            classbox = tk.Listbox(class_window,width=50, height=5)\n            classbox.grid(row=2,column=0,columnspan=3)\n            try:\n                for line in open('kc.txt', 'r'):\n                    line = line.rstrip('\\n').split(\" \")\n                    classbox.insert(tk.END,f\"{line[0]},{line[1]}\")\n            except:\n                messagebox.showinfo(\"WARING\",\"检测到缺少课程文件，可手动添加课程\")\n                class_window.quit()\n\n            def selectthread():\n                len_class = classbox.size()\n                i = 0\n                global thread_class_flag\n                while len_class !=0 and thread_class_flag:\n                    i = i % len_class\n                    kcid = classbox.get(i).split(',')[0]\n                    kcnum = classbox.get(i).split(',')[1]\n                    print(kcid,kcnum)\n                    url = urp_url + '/xkAction.do'\n                    da = {}\n                    if class_inf == '5':\n                        da = {\n                            'kch': kcid,\n                            'cxkxh': kcnum,\n                            'kcm': \"\",\n                            'skjs': \"\",\n                            'kkxsjc': \"\",\n                            'skxq': \"\",\n                            'skjc': \"\",\n                            'pageNumber': \"-2\",\n                            'preActionType': \"3\",\n                            'actionType': \"5\",\n                        }\n                    elif class_inf == '2':\n                        da = {\n                            \"jhxn\": \"\",\n                            \"kcsxdm\": \"\",\n                            \"kch\": kcid,\n                            \"cxkxh\": kcnum,\n                            \"actionType\": \"2\",\n                            \"oper2\": \"gl\",\n                            \"pageNumber\": \"-1\"\n                        }\n                    while True:\n                        try:\n                            st = time.time()\n                            re = requests.post(urp_url + '/xkAction.do', headers=headers, cookies=cookies, data=da, timeout=90)\n                            cost_time = time.time()-st\n                            urp_label.config(text=urp_url+\" \"+f\"延时: {cost_time:.3f} 秒\",fg=\"blue\")\n                            break\n                        except:\n                            return\n\n                    data = {\n                        'kcId': kcid + '_' + kcnum,\n                        'preActionType': class_inf,\n                        'actionType': '9',\n                    }\n                    while True:\n                        try:\n                            st = time.time()\n                            response = requests.post(url, headers=headers, cookies=cookies, data=data, timeout=90).text\n                            cost_time = time.time() - st\n                            urp_label.config(text=urp_url + \" \" + f\"延时: {cost_time:.3f} 秒\", fg=\"blue\")\n                            break\n                        except:\n                            return\n\n                    try:\n                        tree = etree.HTML(response)\n                        ret = tree.xpath('//strong/font/text()')\n                        status_box.insert(tk.END, str(i+1)+\":\"+ret[0])\n                        status_box.yview_moveto(1.0)\n                        class_window.update()\n                        if \"时间冲突\" in ret[0] or \"成功\" in ret[0] or \"已经选择\" in ret[0]:\n                            print(ret[0])\n                            classbox.delete(i)\n                            len_class -= 1\n                            if \"成功\" in ret[0]:\n                                try:\n                                    winsound.PlaySound(\"succeed.wav\", winsound.SND_ASYNC)\n                                except:\n                                    print(\"找不到音频\")\n\n                    except:\n                        print(\"暂无课程信息，请稍后重试\")\n                        status_box.insert(tk.END, str(i+1)+\":\"+\"暂无课程信息，请稍后重试\")\n                        status_box.yview_moveto(1.0)\n                        class_window.update()\n                    i += 1\n                    if delay_slider.get()!=0:\n                        delay_time = delay_slider.get()+random.uniform(0, 2)-random.uniform(0,1.5)\n                        delay_time = max(0,delay_time)\n                        print(\"延迟:\",round(delay_time,2),\"s\")\n                        status_box.insert(tk.END, \"延迟：\"+str(delay_time)+\"s\")\n                        status_box.yview_moveto(1.0)\n                        class_window.update()\n                        time.sleep(delay_time)\n\n                if len_class==0:\n                    button4.config(text=\"开始选课\")\n                    urp_label.config(text=urp_url, fg='black')\n                    status_box.insert(tk.END,\"************选课任务完成************\")\n                if not thread_class_flag:\n                    status_box.insert(tk.END, \"选课已暂停，等待服务器响应...\")\n                    status_box.see(tk.END)\n                    button4.config(state=tk.NORMAL)\n                    urp_label.config(text=urp_url,fg='black')\n\n            def Thread_class():\n                global thread_class_flag\n                thread = threading.Thread(target=selectthread)\n                if button4.cget(\"text\") == \"开始选课\":\n                    thread_class_flag = True\n                    status_box.insert(tk.END,\"开始选课，等待服务器响应...\")\n                    status_box.see(tk.END)\n                    button4.config(text=\"暂停选课\")\n                    thread.start()\n                else:\n                    button4.config(text=\"开始选课\",state=tk.DISABLED)\n                    thread_class_flag = False\n\n            button4 = tk.Button(class_window, width=12,text='开始选课',command=Thread_class)\n            button4.grid(row=4, column=1, columnspan=2)\n\n            delay_slider = tk.Scale(class_window, from_=0.0, to=5.0, resolution=0.01, orient=\"horizontal\", length=200)\n            delay_slider.grid(row=5,column=0,columnspan=3)\n            def change_class():\n                global class_inf\n                if class_inf == '2':\n                    class_inf = '5'\n                    class_label.config(text='课程属性：自由选择')\n                elif class_inf == '5':\n                    class_inf='2'\n                    class_label.config(text='课程属性：方案课程')\n            button5 = tk.Button(class_window, width=10, text='切换属性', command=change_class)\n            button5.grid(row=4, column=0, columnspan=2)\n\n            status_box = tk.Listbox(class_window, width=50)\n            status_box.grid(row=3, column=0, columnspan=3)\n\n            class_label = tk.Label(class_window, text=\"课程属性：方案课程\" )\n            class_label.grid(row=6, column=1)\n            urp_label = tk.Label(class_window, text=urp_url)\n            urp_label.grid(row=7,column=0,columnspan=3)\n\n        btn_quick_select = tk.Button(root, text=\"快速选课\", width=15, height=2,command=select_class)\n        btn_quick_select.pack(pady=5)\n\n        def jxpg():\n            print(\"\\n正在读取教学评估界面\\n\")\n            resp = requests.get(url=urp_url + \"/jxpgXsAction.do?oper=listWj\", headers=headers, cookies=cookies)\n            tree = etree.HTML(resp.text)\n            list = tree.xpath('//body/form/table/tr/td/table/tr/td/img[@title=\"评估\"]/@name')\n            if len(list)==0:\n                messagebox.showinfo(\"提醒\",\"当前可评估数目为0，正在返回菜单\")\n            else:\n                new_window = tk.Toplevel(root)\n                new_window.title(\"评教\")\n                new_window.geometry(\"400x500\")\n                new_window.resizable(0, 0)\n                risk_box = tk.Listbox(new_window, width=50)\n                risk_box.pack()\n                status_box = tk.Listbox(new_window, width=50)\n                status_box.pack()\n                for i in list:\n                    j=i.split(\"#@\")\n                    risk_box.insert(tk.END,\"教师姓名：\"+j[2]+\"    课程名：\"+j[4])\n                # print(list)\n                print(\"共 \", len(list), \" 个评估任务\")\n                risk_count = tk.Label(new_window, text=\"共 \"+ str(len(list))+ \" 个评估任务\")\n                risk_count.pack(pady=10)\n\n                def start_jxpg():\n                    for item in list:\n                        info = item.split('#@')\n                        print(info)\n                        data_flag = {\n                            'wjbm': info[0],\n                            'bpr': info[1],\n                            'pgnr': info[5],\n                            'oper': 'wjShow',\n                            \"wjbz\": \"null\",\n                            \"pageSize\": \"20\",\n                            \"page\": \"1\",\n                            \"currentPage\": \"1\",\n                            \"pageNo\": \"\",\n                        }\n                        data = {\n                            \"wjbm\": info[0],\n                            \"bpr\": info[1],\n                            \"pgnr\": info[5],\n                            \"xumanyzg\": 'zg',\n                            \"wjbz\": \"\",\n                            \"0000000257\": \"40_0.96\",\n                            \"0000000258\": \"12_0.96\",\n                            \"0000000259\": \"10_0.96\",\n                            \"0000000260\": \"8_0.96\",\n                            \"0000000261\": \"8_0.96\",\n                            \"0000000262\": \"5_0.96\",\n                            \"0000000263\": \"5_0.96\",\n                            \"0000000264\": \"4_0.96\",\n                            \"0000000265\": \"4_0.96\",\n                            \"0000000266\": \"4_0.96\",\n                            \"0000000271\": \"0_0.96\",\n                            \"0000000272\": \"0_0.2\",\n                            \"0000000273\": \"0_0.96\",\n                            \"zgpj\": \"好\"\n                        }\n                        requests.post(urp_url + '/jxpgXsAction.do', cookies=cookies, data=data_flag)\n                        res = requests.post(url=urp_url + \"/jxpgXsAction.do?oper=wjpg\", cookies=cookies, data=data)\n                        tree = etree.HTML(res.text)\n                        status = tree.xpath('//script/text()')[0].split('\"')[1]\n                        status_box.insert(tk.END,status)\n                btn_query = tk.Button(new_window, text=\"开始评估\", width=15, height=2, command=start_jxpg)\n                btn_query.pack(pady=5)\n        btn_eval = tk.Button(root, text=\"一键评教\", width=15, height=2,command=jxpg)\n        btn_eval.pack(pady=5)\n\n#退课\n        def cancel_class():\n            root.withdraw()\n            cancle_window = tk.Toplevel(root)\n            cancle_window.title(\"退课\")\n            cancle_window.geometry(\"355x260\")\n            cancle_window.resizable(0, 0)\n            cancle_window.iconbitmap(\"ic.ico\")\n            def closing():\n                root.deiconify()\n                cancle_window.destroy()\n            cancle_window.protocol('WM_DELETE_WINDOW', closing)\n            lable1 = tk.Label(cancle_window,text=\"请选择所需退课课程\")\n            lable1.grid(row=0,column=1,columnspan=3)\n            cancle_box = tk.Listbox(cancle_window,width=50,height=10)\n            cancle_box.grid(row=1,column=1,columnspan=3)\n            def class_input_thread():\n                cancle_response = requests.get(url=urp_url+\"/xkAction.do?actionType=6\",cookies=cookies,headers=headers)\n                tree = etree.HTML(cancle_response.text)\n                cancle_list = tree.xpath('//table/tr[count(td) > 15]/td[position()=2 or position()=3 or position()=4 or position()=8]/text()')\n                for row in range(0,len(cancle_list),4):\n                    cancle_box.insert(tk.END,cancle_list[row][4:]+\",\"+cancle_list[row+1][4:]+\",\"+cancle_list[row+2][4:]+\",\"+cancle_list[row+3][4:])\n            def thread_class():\n                thread = threading.Thread(target=class_input_thread)\n                thread.start()\n            def ACK_cancle():\n                select_box_index = cancle_box.curselection()\n                if select_box_index:\n                    ACK_class = cancle_box.get(select_box_index[0]).split(',')\n                    requests.get(url=urp_url+\"/xkAction.do?actionType=10&kcId=\"+ACK_class[0],cookies=cookies,headers=headers)\n                    messagebox.showinfo(\"完成\",message=\"请按确认校验退课结果\")\n                    cancle_box.delete(0,\"end\")\n                    thread_class()\n                else:\n                    messagebox.showwarning(\"警告\",\"请先选定课程\")\n            thread_class()\n            cancle_button = tk.Button(cancle_window,text=\"确认退课\",command=ACK_cancle)\n            cancle_button.grid(row=2,column=1,columnspan=3)\n        btn_drop = tk.Button(root, text=\"退课\", width=15, height=2,command=cancel_class)\n        btn_drop.pack(pady=5)\n\n        root.mainloop()\n\n\nclass set_urp_url:\n    urp_url_list = [\"http://10.28.63.116:8081\",\n                    \"http://10.28.63.111:9001\",\n                    \"http://10.28.63.111:9002\",\n                    ]\n    URL_flag = True\n\n    def __init__(self):\n        url_count = len(self.urp_url_list)\n\n        def xzURLthread(i):\n            try:\n                response = requests.get(self.urp_url_list[int(i)], timeout=90)\n            except:\n                return\n            if not self.URL_flag:\n                return\n            global urp_url\n            global cookies\n            urp_url = self.urp_url_list[int(i)]\n            cookies = response.cookies.get_dict()\n            self.URL_flag = False\n\n            lock_url.set()\n\n        threads = []\n        lock_url = threading.Event()\n        for i in range(0, url_count):\n            t = threading.Thread(target=xzURLthread, args=[i])\n            threads.append(t)\n        for thread in threads:\n            thread.start()\n        lock_url.wait()\n        print(urp_url)\n\n    def getcode(self):\n        code_url = urp_url + '/validateCodeAction.do?random=0.5925328096959378'\n        mysession = requests.session()\n        response = mysession.get(code_url, headers=headers, cookies=cookies)\n        content = response.content\n        with open('code.png', 'wb') as fp:\n            fp.write(content)\n\n\nif __name__=='__main__':\n    try:\n                LoginWindow()\n    except:\n        messagebox.showinfo('Error','发生了未知错误，请检测网络是否连接')\n```\n\n# 正方教务\n\n这是做来帮人抢课的,没有进一步完善\n\n```python\nimport threading\nimport requests\nimport os\nfrom lxml import etree\nclass_dict = []\ndef search_class(name,id,header,header_oi,class_name,numb):\n    response = requests.get(url='http://112.45.152.8:30008/xf_xsqxxxk.aspx?xh='+id+'&xm='+name+'&gnmkdm=N121203',headers=header)\n    value = searchcode(response)\n    data = {\n        '__EVENTTARGET': '',\n        '__EVENTARGUMENT': '',\n        '__LASTFOCUS': '',\n        '__VIEWSTATE': value,\n        '__VIEWSTATEGENERATOR': '4E92E216',\n        'ddl_kcxz': '',\n        'ddl_ywyl': '无',\n        'ddl_kcgs': '',\n        'ddl_sksj': '',\n        'ddl_xqbs': '1',\n        'TextBox1': class_name,\n        'Button2': '确定',\n        'dpkcmcGrid$txtChoosePage': '1',\n        'dpkcmcGrid$txtPageSize': '150',\n    }\n    res = requests.post(url='http://112.45.152.8:30008/xf_xsqxxxk.aspx?xh=' + id + '&xm=' + name + '&gnmkdm=N121203', data=data, headers=header_oi)\n    data['__VIEWSTATE'] = searchcode(res)\n    data['kcmcGrid$ctl02$xk'] = 'on'\n    data['kcmcGrid$ctl02$jc'] = 'on'\n    data['Button1'] = ['++提+交++']\n    del data['Button2']\n    res = requests.post(url='http://112.45.152.8:30008/xf_xsqxxxk.aspx?xh=' + id + '&xm=' + name + '&gnmkdm=N121203', data=data, headers=header_oi)\n    # print(res.text)\n    if res.status_code == 200:\n        print(res.status_code)\n        with open(\"cx\"+numb+\".html\", 'wb') as fp:\n            fp.write(res.content)\n        os.system(\"cx\"+numb+\".html\")\n        del class_dict[int(numb)]\n    return\n\ndef searchcode(response):\n    try:\n        tree = etree.HTML(response.text)\n        return tree.xpath('//input[@id=\"__VIEWSTATE\"]/@value')[0]\n    except:\n        print(\"请检查cookie是否正确！！！\")\n        exit()\n\n\ndef menu(name,id,cookie):\n    header ={\n        'Host': '112.45.152.8:30008',\n        'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:109.0) Gecko/20100101 Firefox/110.0',\n        'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,*/*;q=0.8',\n        'Accept-Language': 'zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2',\n        'Accept-Encoding': 'gzip, deflate',\n        'Connection': 'keep-alive',\n        'Referer': 'http://112.45.152.8:30008/xs_main.aspx?xh='+id,\n        'Cookie': cookie,\n        'Upgrade-Insecure-Requests': '1',\n    }\n    nm = 'http://112.45.152.8:30008/xf_xsqxxxk.aspx?xh=' + id + '&xm=' + name + '&gnmkdm=N121203'\n    nm = nm.encode('utf-8')\n    header_oi ={\n        'Host': '112.45.152.8:30008',\n        'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv: 109.0) Gecko/20100101 Firefox/110.0',\n        'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,*/*;q=0.8',\n        'Accept-Language': 'zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2',\n        'Accept-Encoding': 'gzip, deflate',\n        'Content-Type': 'application/x-www-form-urlencoded',\n        'Content-Length': '47574',\n        'Origin': 'http://112.45.152.8:30008',\n        'Connection': 'keep-alive',\n        'Referer': nm,\n        'Cookie': cookie,\n        'Upgrade-Insecure-Requests': '1',\n    }\n    while True:\n        class_dict.clear()\n        a = 0\n        for line in open('kc.txt', 'r', encoding='utf-8'):\n            line = line.rstrip('\\n')\n            class_dict.append(line)\n            a += 1\n        print(\"共\", a, \"科\\n\", class_dict)\n        p = input(\"\\n请输入所需功能：\\n1:选取\\n\")\n        if p == \"1\" : select(name,id,header,header_oi)\n\n\ndef select(name,id,header,header_oi):\n    i = 0\n    while len(class_dict) != 0:\n        class_thread = []\n        print(len(class_dict))\n        for item in class_dict:\n            class_thread.append(threading.Thread(target=search_class,args=(name,id,header,header_oi,item,str(i))))\n            i+=1\n        for thread in class_thread:\n            thread.start()\n        for thread in class_thread:\n            thread.join()\n    return\n\nif __name__=='__main__':\n    name = input(\"请输入姓名：\")\n    id = input(\"请输入学号：\")\n    cookie = input(\"请输入cookie：\")\n    menu(name,id,cookie)\n\n```\n\n# 新版教务系统\n\n暂时只实现了选课功能，\n\n![image-20240205200345870](教务系统选课脚本正方-urp/image-20240205200345870-1707136055615-1.png)\n\n由于教务还在使用，暂时不进行开源，思路和上述两个都大同小异，有兴趣的uu可以自行尝试一下。\n","tags":["爬虫"]},{"title":"问海一号SACA随记","url":"/2022/02/05/问海一号SACA随记/","content":"\n**主核存储系统：**\n\n- 一级指令Cache 32KB\n- 一级数据Cache 32KB\n- 二级Cache 512KB\n\n**从核存储系统：**\n\n- 一个指令Cache 32KB\n- 每个从核有256KB数据存储空间（LDM）\n\n![img](问海一号SACA随记/1685787598459-32ce2b53-4270-4d08-8615-840b5f1603ac.png)\n\n从核私有变量：`_thread int a[100];`\n\n\n\n```cpp\n混合静态编译及链接\nswgcc -mhost master.c\nswgcc -mslave slave.c\nswgcc -mhybrid master.o slave.o -o a.out\n\n混合动态编译及链接\nswgcc -mhost -FPIC -c master.c\nswgcc -mslave -FPIC -c slave.c\nswgcc -mdynamic -shared master.o slave.o -o libmix.so\n\nmpi编译\nmpicc -mhost mater.c\nmpicc -mslave slave.c\nmpicc -mhybrid master.o slave.o -o a.out\n-mhost\t编译主核代码\n-mslave\t编译从核代码\n-mhybrid/-mdynamic\t静态/动态链接\n-msimd\tSIMD扩展编程接口\t（建议从核加）\n-mieee\t允许使用精确结果的任何操作\t（主核必加）\n-faddress_align=n\t所有数组、向量、结构体按照首地址 nB对齐\t主核（n=32）从核（n=64）\n-mftz\t发生下溢时，将真零写入目标寄存器 （建议主核加）\n-O[0/1/2/3/s]\t优化级别\n-lm -lm_slave\t提供高性能快速数据库链接\t（主核-lm，从核-lm_slave）\n-g\t方便gdb调试\n-mfma\t对乘加操作合成一条操作，建议增加\n```\n\n**说明：**\n\n-faddress_align=64内存对齐，加了这个编译选项后，\n\n就无需在定义数组时候加`__attribute__ ((aligned(64)))`\n\n**例如：**\n\n```\nint arr[16] __attribute__ ((aligned (64)))= {1,2,3,4,5,6,7,8,10,11,12,13,14,15}; \n```\n\n\n\nSIMD数据向量化支持512位\n\n```cpp\nCRTS_init();\n//从核线程初始化\nathread_spawn();\n//从核线程启动\nathread_join();\n//从核线程回收\nathread_halt();\n//从核线程终止\nCRTS_tid\t--从核号（0-63）\nCRTS_rid\t--从核所在行（0-7）\nCRTS_cid\t--从核所在列（0-7）\nCRTS_cgn\t--从核所在核组号（0-5）\nCRTS_spc_tid\t--从核簇方式的逻辑从核号（0-63）\nCRTS_spcn\t--从核簇号（0-16）\n\nCRTS_dma_iget(void *dst, void *src, int len, crts_rply_t *rply);\n//dst从核内的地址,src共享内存的地址,len=i*sizeof(int)\nCRTS_dma_iget_stride(void *dst, void *src, int len, int bsize, int stride, crts_rply_t *rply);\n//主存跨步读取，跨步大小为stride(4B的整数倍)即两个向量块之间的空隙，bsize为跨步向量块的大小\n\nCRTS_dma_wait_value(crts_rply_t *rply, int value);\n//当rply的值大于等于value时，代表操作已经完成\n    \nCRTS_dma_iput(void *dst, void *src, int len, crts_rply_t *rply);\n//dst为主存的地址，src为局存地址\nCRTS_dma_input_stride(void *dst, void *src, int len, int bsize, int stride, crts_rply_t *rply);\n//跨步\n```\n\n## 编译\n\n![img](问海一号SACA随记/1685699879442-3e5a6739-2f07-48fa-b74f-7a07ddf8b225.png)\n\n```cpp\nsw9gcc -mhost -c main.c\n\nsw9gcc -mslave -c slave.c\n\nsw9gcc -mhybrid main.o slave.o -o a.out\n```\n\n## 作业提交\n\n```\nbsub -I -q q_sw_expr -b -n 1 -cgsp 64 -host_stack 1024 -share_size 6000 test.exe\n```\n\n-  -I 程序输出打印到终端，终端关闭则程序停止运行，若想去掉该项，则加上\"-o out.log\"，输出内容会重定向到out.log文件，终端关闭程序也不会停止\n- -q 程序提交到q_sw_expr计算节点队列运行\n- -n 程序运行使用的核组数，最好是4的倍数（一个节点有4个核组）\n- -b 从核函数栈变量放在从核局部存储上（必选）\n- -cgsp 从核的个数，设置64\n- -host_stack 指定主核栈的空间大小，默认8M，一般设置128M以上\n- -share_size 指定核组的共享空间大小，一般share_size+host_stack ≤7500 \n\n```cpp\nbjobs \n//查看当前作业状态和作业号\n\nbkill 作业号 \n//停止作业\n\nqload -w \n//查看可用计算队列和可用节点\n```\n\n## 两级并行\n\n![img](问海一号SACA随记/1685700038922-317f4811-448c-41c9-9f52-18ae7ae9797c.png)\n\n## 性能分析\n\nswprof\n\n使用方法：在bsub命令中增加`-swrunarg '-p'`\n\n![img](问海一号SACA随记/1685700372900-61a89b72-655c-434c-8ef1-0a654eccd299.png)\n","tags":["超算"]},{"title":"SQL基础学习","url":"/2022/02/05/SQL基础学习/","content":"\n# 基础查询\n\n```sql\nuse SCT --SCT数据库\nselect C# from sc --从sc表中查询C#\nselect distinct C# from sc --从sc表中查询C#并且过滤掉重复行\nselect top 3 * from sc --从sc表中查询前三行的数据\nselect top 50 percent * from sc --从sc表中查询前50%的数据\nselect s# as 学号,score as 分数 from sc --从sc表查询s#作为“学号”输出，score作为“分数”输出\nselect s#,C#,Score*1.50 from sc --从sc中查询s#,c#，和score的1.5倍，注意此时score没有列名\nselect s#,C#,Score150 = score *1.50 from sc --此时score*1.50的列名为Score150\nselect * from sc where score>=60 --查询sc中score>=60的元组\nselect * from sc where score>=60 and s#='123' --and查询sc中score>=60并且s#为123的元组\nselect * from sc where score>=60 or score<=20 --or查询\nselect * from sc where score between 20 and 60\nselect * from sc where score>=20 and score<=60 --等效\nselect Cname,Chours from sc where Cname in('数据库','C语言')\nselect Cname,Chours from sc where Cname not in('数据库','C语言')\nselect * from sc where sname like '张%' \nselect * from sc where sname not like '张%' --%任意长的任意字符,_任意单个字符，[]指定范围内的单个字符，如[a-f]或者[abfr]，[^]指定不在范围内的单个字符\nselect * from sc where sname is NULL --[not] is对空值判断\n```\n\n\n\n```sql\nselect avg(sage) as 平均年龄 from student where ssex = '男'\n● avg()：返回列的数据平均值\n● sum()：返回列数据的和\n● max()：返回列数据中的最大值\n● min()：返回列数据中的最小值\n● count()：返回数据的个数\nuse SCT\nselect C#,avg(score) from SC\ngroup by C#\n--group by 后面的必须按照前面筛选的C#进行分组\nhaving avg(score)>=60\n--对group by进行筛选\nSELECT s#,sname \nFROM student \nWHERE ssex='女'\nORDER BY sname ASC --升序\n--ORDER BY sname DESC 降序\nSELECT student.sname, sc.c#, sc.score\nFROM student INNER JOIN sc ON student.s#=sc.s#\n\n也可用\nSELECT sname, sc.c#, sc.score\nFROM student,sc\nWHERE  student.s#=sc.s#\nselect * from subject\nleft join score --left join表示subject全部输出，score取交集\nright join score --right join 表示score全部输出，subject取交集\non subject.id = score.id\n```\n\n![img](SQL基础学习/1680141783646-9338980a-9e78-456d-a219-ad3215ccffcc.png)![img](SQL基础学习/1680141893719-2f9854d4-d7fa-4101-80fd-814543bb4399.png)![img](SQL基础学习/1680141908016-0e173a0d-1daf-4850-9c53-65792838d1ec.png)\n\n```sql\nUNION --并\nEXCEPT --差\nINTERSECT --交\n```\n\n# 数据库、表的操作\n\n### 数据库的创建\n\n```\ncreate database **DATABASE_NAME**\n```\n\n### 删除数据库\n\n```\ndrop database **DATABASE_NAME**\n```\n\n### 表的创建\n\n```sql\ncreate table TABLE_NAME\n(\n  属性1 数据类型,\n  属性2 数据类型,\n)\n```\n\n### 表的修改\n\n```sql\nalter table TABLE_NAME\n[\n  alter column 属性 数据类型 --修改表属性的数据类型\n  add 属性 数据类型 --新增表属性\n  drop column 属性 --删除表属性\n]\n```\n\n### 添加元组\n\n```\ninsert into TABLE_NAME values('','','')\ninsert into TABLE_NAME(属性1,属性2,....) values('','',''...)\n```\n\n### 修改表中数据\n\n```sql\nupdate 表名TABLE_NAME\n  set ssex='男'\n  where sno = '10011'\n```\n\n### 删除元组\n\n如果不加where则删除全部元组\n\n```sql\ndelete 表名TABLENAME\n  \twhere ssex='男'\n```\n\n### not null\n\n```sql\nUSE SCT\nCREATE TABLE STUDENT\n( Sno   char(7) not null,\nSname   char(10), \nSFZ  char(18),\nSage tinyint )\n=============================\nUSE  SCT \nALTER TABLE student\nALTER COLUMN Sname char(10) not null\n```\n\n### **primary key主键约束**\n\n```sql\nUSE SCT\n  CREATE TABLE SC\n  ( Sno   char(7) ,\n    Cno   char(3), \n    Score tinyint,\n    Primary key (Sno,Cno)\n  ) \n================================\nUSE SCT\n  CREATE TABLE STUDENT1\n\t( Sno char(7) primary key，\n    Sname char(10), \n    SFZ char(18),\n\t  Sage tinyint\n  ) \n================================\nUSE  SCT\nALTER TABLE STUDENT1\nadd primary key(sno) --不指定约束名称\nadd constraint pk1 primary key(sno) --指定约束名称\n================================\nuse sct\nalter table STUDENT1\ndrop constraint pk1 --删除pk1约束\n```\n\n### foreign key外键约束\n\n```sql\nUSE SCT\nCREATE  TABLE  SC\n( Sno char(7)  CONSTRAINT sc_k foreign key refernces student(sno),\n Cno char(3), \n Score tinyint\t ) \n=================================\nUSE  SCT\nALTER  TABLE  SC\nADD CONSTRAINT SC3_K\nforeign key(Cno) references Course(Cno)\n```\n\n![img](SQL基础学习/1680493907932-81eb8885-51a5-40cb-bdb0-61eaa798c6d9.png)\n\n注意：references指向的必须是**主键**\n\n### check 条件约束\n\n```sql\nUSE SCT\nCREATE TABLE STUDENT\n( Sno char(7) PRIMARY KEY，\nSname char(10), \nSFZ  char(18) UNIQUE,\nSage tinyint CHECK(Sage>=15 and Sage<=40 ) )\n================================================\nUSE  SCT\nALTER  TABLE  student\nADD CONSTRAINT St4_K\nCHECK(Sage>=15 and Sage<=40 )\n```\n\n### default默认约束\n\n```sql\nUSE SCT\nCREATE TABLE STUDENT\n( Sno   char(7) PRIMARY KEY,\nSname   char(10), \nMajor char(10) DEFAULT‘电计’)\n==============================\nuse SCT\nalter table STUDENT\nadd constraint pk1\ndefalut '电计' for Major\n```\n"},{"title":"Linux常用指令","url":"/2022/02/05/Linux常用指令/","content":"\n# 目录结构\n\nWindows操作系统中路径是：\n\n```\nC:\\Users\\Vicczyq\\Desktop\\a.cpp\n```\n\nLinux操作系统路径：\n\n```\n/Users/Vicczyq/Desktop/a.cpp\n```\n\n# 基础命令\n\n## 1、ls命令：\n\n语法：`ls [-a -l -h] [Linux路径]`\n\n- -a -l -h 是可选的选项\n\n-a:显示全部文件，包括隐藏文件\n\n-l:以列表的形式展示文件，更细节\n\n-h:搭配-l使用，人性化的显示文件大小(K,M,G)\n\n-d:显示目录本身属性\n\n--color:以颜色区分不同类型的文件\n\n可以组合使用，如-al,-alh\n\n\n\n- Linux路径 是可选的参数\n\n如果不加选项和参数，直接使用ls命令，表示：以平铺的形式，列出当前工作目录（开始默认为HOME目录，/HOME/用户名）内容\n\n## 2、cd命令（change directory）：\n\n语法：`cd Linux路径`\n\n- cd命令无需选项，只有路径（只有参数）\n- cd命令不给路径（不写参数）的表示回到用户HOME目录\n\n## 3、pwd命令（print work directory）：\n\n语法：`pwd`\n\npwd命令无选项，无参数，直接输入即可查看当前所在工作目录路径\n\n\n\n## 4、相对路径、绝对路径、特殊路径符：\n\ncd /home/Vicczyq/Desktop\t绝对路径\n\ncd Desktop\t相对路径\n\n特殊路径符：\n\n**.** \t表示当前目录\n\n**..**\t表示上一级目录\n\n**~**\t表示HOME目录\n\n## 5、mkdir命令（make directory):\n\n语法：`mkdir [-p] Linux路径`\n\n-p：自动创建不存在的父目录，用于多级文件夹创建\n\n## 6、touch、cat、more查看命令：\n\n语法：`touch Linux路径`\n\n例如：touch test.py 创建test.py文件（相对路径绝对路径都可以）\n\n语法：`cat Linux路径`\n\n例如：cat test.py 查看test.py文件\n\n语法：`more Linux路径`\n\n可以翻页查看文件（空格翻页，回车换行，q退出）\n\n## 7、cp、mv、rm文件操作命令：\n\n语法：`cp [-r] 参数1 参数2`\n\n- -r用于复制文件夹（如果要复制文件夹就要带上-r）\n- 参数1 Linux路径，表示被复制的文件或者文件夹路径\n- 参数2 Linux路径，表示要复制去的地方\n\n语法：`mv 参数1 参数2`\n\n- 参数1 Linux路径，表示被移动的文件或文件夹路径\n- 参数2 Linux路径，表示要移动去的地方\n\n可以用于改名\n\n语法：`rm [-r -f] 参数1 参数2 参数3.....参数n`\n\n- -r 用于删除文件夹\n- -f 强制删除，不会弹出确认信息（root超级管理员才用到）\n- 可以有多个参数Linux路径，删除多个\n\n\n\nrm可以配合通配符，用来做模糊搜索删除\n\n- 符号*表示通配符，及匹配任意内容：\n- test* 表示以任意test开头的内容\n- *test 表示任意以test结尾的内容\n- *test*表示任意包含test的内容 \n\n## 8、which、find查找命令：\n\n语法：`which 查找的命令`\n\n通过which可以查找命令程序的文件目录，如which pwd、while mkdir\n\n语法：`find 起始路径 -name \"文件名\"`\n\n文件名可以使用通配符\n\n语法：`find 起始路径 -size +|-n[kMG]`\n\n- +、-表示大于或小于\n- n表示数字大小\n- kMG表示大小单位(k为小写)\n\n例如：\n\n- 查找小于10KB的文件，find -size -10k\n- 查找大于100MB的文件：find -size +100M\n\n## 9、grep、wc（文件内容筛选和统计）管道符命令：\n\n语法：`grep [-n] 关键字 文件路径`\n\n- -n可选，表示结果显示匹配的行的行号\n- 参数，关键字，必填，表示文件内容筛选的关键字\n- 参数，文件路径，必填，可以做内容输入（见管道符）\n\n语法：`wc [-c -m -l -w] 文件路径`\n\n- 选项，-c，统计bytes数量\n- 选项，-m，统计字符数量\n- 选项，-l，统计行数\n- 选项，-w，统计单词数量\n- 参数，文件路径，必填，可以做内容输入（见管道符）\n\n**拓展：管道符 |**\n\n**cat test.txt | grep 关键字**\n\n**cat test.txt | wc -l**\n\n**将****左边的输出****作为****右边的输入**\n\n**只要左边有输出就可以作为右边的输入**\n\n## 10、echo、tail、head、重定向符：\n\n语法：`echo 输出的内容`\n\n例如：echo hello world！\n\necho `pwd`被包围的内容会按照命令去执行，最后以echo的形式显示结果\n\n语法：`tail/head [-f -num] Linux文件路径`\n\n- 选项，-f，表示持续追踪，相当于动态显示文件内容，Ctrl+C可以停止\n- 选项，-num，表示查看尾部多少行，不填默认为10\n\n\n\n**重定向符：**\n\n\\>表示覆盖写入到文件\n\n\\>>表示追加写入到文件\n\n例如：ls -al > Desktop/test.txt\n\n## 11、ln命令（软链接）快捷方式:\n\n语法：`ln -s 参数1 参数2`\n\n- -s选项 创建软链接\n- 参数1：被链接的文件或文件夹\n- 参数2：链接的文件或文件夹（快捷方式）\n\n### 12、date时间设置命令、cal日历命令\n\n通过date命令可以在命令行中查看系统时间\n\n语法：`date [-d] [+格式化字符串]`\n\n- -d 按照给定的字符串显示日期，一般用于日期计算\n\n- - - year 年\n    - month 月\n    - day 日\n    - hour 小时\n    - minute 分钟\n    - second 秒\n\n例如：date -d \"-1 day\"\n\n- 格式化字符串：通过特定的字符串标记，控制显示的日期格式\n\n- - - %Y 年\n    - %y 年份后两位（如99）\n    - %m 月份（01,12）\n    - %d 日（0,31）\n    - %H 小时（00,23）\n    - %M 分钟（00,59）\n    - %S 秒（00,60）\n    - %s 自1970-01-01 00:00:00: UTC到现在的秒数\n\ndate -d \"-1 day\" %d\n\n#### 修改时区：rm -f /etc/localtime\n\n# Vi、Vim编辑器\n\nvi/vim是命令行下对文本编辑的最经典的编辑器\n\nvim是vi的加强版本，兼容vi的所有指令，而且具有shell程序编辑的功能\n\n语法：`vim 文件名` 进入命令模式\n\n| i    | 当前光标位置进入输入模式      | dd      | 删除光标所在行             |\n| ---- | ----------------------------- | ------- | -------------------------- |\n| a    | 当前光标位置 之后进入输入模式 | ndd     | n为数字，删除当前光标下n行 |\n| I    | 当前行的开头进入输入模式      | yy      | 复制当前行                 |\n| A    | 当前行的结尾进入输入模式      | nyy     | n为数字，复制当前光标下n行 |\n| o    | 当前光标下一行进入输入模式    | p       | 粘贴                       |\n| O    | 当前光标上一行进入输入模式    | u       | 撤销修改                   |\n| esc  | 进入命令模式                  | gg      | 到首行                     |\n| 0    | 光标移动到行开头              | G       | 到尾部                     |\n| $    | 光标移动到行结尾              | :wq     | 保存并退出                 |\n| /    | 进入搜索模式                  | :q      | 直接退出                   |\n| n    | 向下继续搜索                  | :q!     | 强制退出                   |\n| N    | 向上继续搜索                  | :set nu | 设置显示行号               |\n\n# 网络请求和下载\n\n### 1、ping\n\n语法：`ping [-c num] ip或者主机名`\n\n- -c 检查的次数，不使用-c就无限次\n\n### 2、wget\n\n语法：`wget [-b] url`\n\n- -b 可选，后台下载，会将日志写入到当前目录的wget-log文件中\n- url 参数,下载链接\n\n### 3、curl\n\n可以用于发送http网络请求，用于：下载文件，获取信息等\n\n语法：`curl [-O] url`\n\n- -O 选项，用于下载文件，当url是下载链接时候，可以使用此选项保存文件\n- url，参数，要发起请求的网址\n\n# 软件\n\n### 1、yum命令（root）软件安装：\n\nRPM包软件管理器，用于自动化安装Linux软件，并可以解决依赖问题\n\n语法：`yum [-y] [install | remove | search] 软件名称`\n\n- -y，自动确认，无需手动确认安装或卸载过程\n- install：安装\n- remove：卸载\n- search：搜索\n\n### 2、systemctl命令\n\n控制软件：启动、停止、开机自启\n\n语法：`systemctl [start | stop | status |enable | disable] 服务名`\n\n- start：启动\n- stop：关闭\n- status：查看状态\n- enable：开启开机自启\n- disable：关闭开机自启\n\n# 压缩和解压缩\n\n### 1、tar压缩\n\n语法：`tar [-c -v -x -f -z -C] 参数1 参数2...参数n`\n\n- -c，创建压缩文件，用于压缩模式\n- -v，显示压缩，解压过程，用于查看进度\n- -x，解压模式\n- -f，要创建的文件，或要解压的文件，-f选项必须在所有选项的**最后**\n- -z，gzip格式，不使用就是普通的tarball格式，必须在**最前面**\n- -C，解压目的地\n\ntar：`tar -cvf test.tar 1.txt 2.txt 3.txt`\n\ngzip：`tar -zcvf test.tar.gz 1.txt 2.txt 3.txt`\n\n### 2、tar解压\n\n语法：`tar -xvf test.tar`\n\n指定解压路径：`tar -xvf test.tar -C /home/vicczyq/Desktop`\n\n\n\n### 3、zip压缩文件\n\n语法：`zip [-r] 参数1 参数2.....参数n`\n\n- -r，被压缩的包含文件夹时候，需要使用\n\n### 4、unzip解压文件\n\n语法：`unzip 参数 [-d 文件路径]`\n\n-d指定解压去的路径位置，参数为zip压缩包文件\n\n# 快捷键\n\n### 1、Ctrl+C 强行停止\n\n- Linux某些程序运行，如果想强行停止可以Ctrl+C\n- 输入命令错误，可以通过Ctrl+C清空输入\n\n### 2、Ctrl+D 退出或登出\n\n用户切换时候等效于exit，但不能退出vi/vim\n\n可以退出python等软件\n\n### 3、history命令可以查询历史使用命令\n\nhistory | grep \"关键词\"\n\n可以筛选\n\n### 4、！命令前缀\n\n执行历史记录中以前缀开头的最近的命令\n\n### 5、Ctrl+R 搜索历史命令\n\n### 6、Ctrl+a 跳到命令开头\n\n### 7、Ctrl+e 跳到命令结尾\n\n### 8、Ctrl+键盘左右键 左右跳单词\n\n### 9、Ctal+L 清空终端内容\n\n等效于输入命令clear\n\n### 10、Ctrl+U清空至行首\n\n### 11、Ctrl+K清空至行尾\n\n### 12、Home跳到行首\n\n### 13、End跳到行尾\n\n# 环境变量\n\n### 临时设置：\n\n语法：`export 变量名=变量值`\n\n### 永久生效：\n\necport PATH=$PATH :/添加的东西（$PATH取当前PATH的值）\n\n针对当前用户：配置当前用户的~/bashrc文件\n\n针对所有用户：配置在系统的/ect/profile文件\n\n配置完成，通过`source 配置文件`命令立刻生效\n\n# IP地址和主机用户\n\n### 1、hostname 查看主机名\n\n### 2、hostnamectl set-hostname 主机名\n\n修改主机名\n\n### 3、设置静态IP\n\n使用vim编辑 /ect/sysconfig/network-scripts/ifcfg-ens33文件 \n\n# Linux用户\n\n**用户账号文件：**/etc/passwd\n\n**用户密码文件：**/etc/shadow\n\n**组账号：**/etc/group\n\n**组密码：**/etc/gshadow\n\n\n\n最大权限的账户名：root\n\n切换用户（Switch User）：\n\n```\nsu [-] [用户名]\n```\n\n- “-”符号表示表示是否加载环境变量，建议加上\n- 用户名为可选参数，不填默认为root\n\n切换用户后，可以用exit切回上次用户\n\n\n\n```\nsudo 其它命令\n```\n\n这条命令以root的身份去执行，临时root授权\n\n并不是所有的用户都有权力使用sudo，只有配置sudo认证的才能\n\n\n\n**配置sudo认证：**\n\n切换到root用户，执行visudo命令，在文件最后添加\n\n```\n用户名 ALL=(ALL) NOPASSWORD\n```\n\nwq保存退出\n\n\n\n## 用户和用户组\n\n1、创建用户组：\n\n语法 `groupadd 用户组名`\n\n2、删除用户组\n\n语法 `groupdel 用户组名`\n\n3、创建用户\n\n语法 `useradd [-g -d -s] 用户名`\n\n- -g 指定用户组，如果不指定就会创建一个和用户名一样的组自己加入\n- -d 指定用户HOME路径，不指定默认在/home/用户名\n- -s 指定shell，默认为/bin/bash\n\n4、删除用户\n\n语法 `userdel [-r] 用户名`\n\n- -r 删除用户的HOME目录，不使用-r只删掉用户，不删目录文件\n\n5、查看用户所属组\n\n语法 `id [用户名]`\n\n- 不加用户名默认显示当前用户所属用户组\n\n6、修改用户所属组\n\n语法` usermod -aG 用户组 用户名`\n\n- 将指定用户加入指定组\n\n7、getent\n\n语法 `getent passwd`\n\n查看当前系统中的用户\n\n语法 `getent group`\n\n查看当前系统中的用户组\n\n8、更改/设置用户口令\n\n语法` passwd 用户名`\n\n![img](Linux常用指令/1695091854612-947fb28a-bde3-4437-b4aa-2e1fb80ddc7c.png)\n\n## 权限管理和修改\n\n![img](Linux常用指令/1679123684100-4081e340-fa70-4e1f-97bb-166729dccf43.png)\n\nr：表示可读权限\n\nw：表示可写权限\n\nx：表示执行权限\n\n-：无权限\n\n### 权限修改：\n\n**1、chmod命令：**\n\n语法：`chmod [-R] 权限 文件或文件夹`\n\n- -R指文件夹内所有文件进行相同操作\n\n实例：\n\nchmod u=rwx,g=rx,o=x hello.txt\n\n修改后的权限信息为：rwxr-x--x\n\n0：--- \t1：--x\t2：-w-\t3：-wx\n\n4：r--\t5：r-x\t6：rw-\t7：rwx\n\nchmod 751 hello.txt\n\n\n\n**2、chown命令：**\n\n语法：`chown [-R] [用户] [:] [用户组] 文件或文件夹`\n\n- -R指文件夹内所有文件进行相同操作\n\n![img](Linux常用指令/1679124407657-2754fd9e-b047-4c49-8978-174f49b9c60d.png)\n\n![img](Linux常用指令/1695695221590-a0ce7b34-78de-451b-ab9b-34a7ae774746.png)\n","tags":["计算机基础"]},{"title":"CUDA基础学习","url":"/2022/02/05/CUDA基础学习/","content":"\n![img](CUDA基础学习/1699278155036-757a1974-f6c1-43cd-a8e6-06852e4e6a4f.png)\n\nCPU+GPU组成异构计算，GPU可以看做是CPU的协作处理器，一般称为设备\n\n主机（CPU）和设备（GPU）之间的内存访问是通过PCIe总线连接的\n\n| **CPU**            | **GPU**        | **层次** |\n| ------------------ | -------------- | -------- |\n| 算术逻辑和控制单元 | 流处理器(SM)   | 硬件     |\n| 算术单元           | 批量处理器(SP) | 硬件     |\n| 进程               | Block          | 软件     |\n| 线程               | thread         | 软件     |\n| 调度单位           | Warp           | 软件     |\n\n![img](CUDA基础学习/1699013132500-689d59c7-7782-48d7-b23b-7cde1c59474d.png)\n\n一个线程在一个CUDA Core执行（SP）\n\n一个线程块被分配到一个SM上面执行\n\n一个Grid在GPU设备执行\n\n**查看显卡利用率**\n\n```\nnvidia-smi\n```\n\n![img](CUDA基础学习/1699002941511-a35e1dac-97f6-4a68-b917-50814844d2dc.png)\n\n## 1、核函数（Kernel_function）\n\n核函数在GPU上进行并行执行\n\n注意：\n\n1. 限定词_global_修饰\n2. 返回值必须是void\n3. 核函数只能访问设备（GPU）内存\n4. 核函数不能使用变长参数、静态变量、函数指针\n5. 核函数具有异步性\n\n```cpp\n_global_ void kernel_function(argument *arg)\n{\n    printf(\"Hello world from GPU\\n\");\n}\nvoid _global_ kernel_function(argument *arg)\n{\n    printf(\"Hello world from GPU\\n\");\n}\n#include <stdio.h>\n_global__ void hello()\n{\n    printf(\"Hello world from GPU\\n\");\n}\nint main()\n{\n    hello<<<1,1>>>(); //设备（GPU）核函数执行，<<<1,1>>>含义见下节。\n    cudaDeviceSynchronize(); //同步，CPU等待CPU处理完成\n    return 0;\n}\n```\n\n## 2、线程模型\n\n### 2.1基本概念\n\n| 网格 grid | 线程块 block |\n| --------- | ------------ |\n|           |              |\n\n![img](CUDA基础学习/1699011161039-62e75ab2-9f1c-4917-a815-37284fa75aa2.jpeg)\n\n线程分块是逻辑上的划分，物理上线程不分块\n\n配置线程：`<<<grid_size , block_size>>>`\n\ngrid_size：网格包含的线程块个数\tblock_size：线程块包含的线程个数\n\n![img](CUDA基础学习/1697013915734-f63e760a-5105-44f8-bafe-e9c5b382fe85.png)\n\n### 2.2一维身份标识\n\n每个线程的唯一标识由`<<<grid_size, block_size>>>`确定。\n\n在核函数中可以使用\n\n`gridDim.x`：该变量的值等于执行配置中变量`grid_size`的值（线程格的维度）\n\n`blockDim.x`：该变量的值等于执行配置中变量`block_size`的值（线程块的维度）\n\n`blockIdx.x`：线程在网格(grid)中的线程块(block)的索引，范围`0~gridDim.x-1`（线程块的索引）\n\n`threadIdx.x`：线程在线程块中的线程索引，范围`0~blockDim.x-1`（线程索引）\n\n![img](CUDA基础学习/1697012880220-f0efb73d-8784-47bf-bed8-34e3663ca4a5.png)\n\n\n\nCUDA可以组织三维的网格和线程块\n\n![img](CUDA基础学习/1829f7dfa12f09c2cfa0bde303e7d892.svg+xml)![img](CUDA基础学习/96699848a0c6e08f2eb50a52efcefc44.svg+xml)\n\n`blockIdx`和`threadIdx`都是结构体，具有x，y，z三个成员\n\n![img](CUDA基础学习/1697013503445-bdade019-0e4f-4dbe-91f9-35edef6a38ea.png)\n\n**一维：**\n\n![img](CUDA基础学习/1697013590396-76aec282-966a-48f7-804b-3cd0220a7cd4.png)\n\n**多维：**\n\n```cpp\ndim3 grid_size(Gx,Gy,Gz);\ndim3 block_size(Bx,By,Bz);\n<<<grid_size,block_size>>>//（线程块数，每个块线程数）\n\n// 例如：\n    dim3 grid_size(2,2); //等价于dim3 grid_size(2,2,1);\n\tdim3 block_size(5,3);//等价于dim3 block_size(5,3,1);\n```\n\n## 3、函数修饰符\n\n**__global__**：表明被修饰的函数在设备上执行，但在主机上调用\n\n**__device__**：表明被修饰的函数在设备上执行，但只能在其他__device__函数或者__global__函数中调用。\n\n## 4、常用的GPU函数\n\n#### cudaMalloc (void **devPtr, size_t size)\n\n功能：与C语言中的malloc函数一样，只是此函数在GPU的内存你分配内存。\n\n#### cudaMemcpy (void dst, const void src, size_t count, cudaMemcpyKind kind)\n\n功能：与c语言中的memcpy函数一样，只是此函数可以在主机内存和GPU内存之间互相拷贝数据。\n\n函数参数：cudaMemcpyKind kind表示数据拷贝方向，如果kind赋值cudaMemcpyDeviceToHost表示数据从设备内存拷贝到主机内存，cudaMemcpyHostToDevice表示主机到设备。\n\n相应的有个异步方式执行的函数cudaMemcpyAsync()\n\n#### cudaFree ( void* devPtr )\n\n功能：与c语言中的free()函数一样，只是此函数释放的是cudaMalloc()分配的内存。\n\n#### __syncthreads()\n\n功能：同步函数，确保线程块中的每个线程都执行完__syscthreads()前面的语句后，才会执行下一条语句。\n\n#### cudaDeviceSynchronize(); \n\n功能：同步，CPU等待GPU处理完成，注意此函数是CPU函数！\n\n```cpp\n#include <stdio.h>\n__global__ void add( int a, int b, int *c ) {\n    *c = a + b;\n}\nint main( void ) {\n    int c;\n    int *dev_c;\n\n    cudaMalloc( (void**)&dev_c, sizeof(int) );\n\n    add<<<1,1>>>( 2, 7, dev_c );   \n\n    cudaMemcpy( &c, dev_c, sizeof(int),cudaMemcpyDeviceToHost ) ;\n    printf( \"2 + 7 = %d\\n\", c );\n\n    cudaFree( dev_c );\n    return 0;\n}\n```\n\n## 5、GPU内存分类\n\n### 5.1全局内存\n\n通俗意义上的设备内存\n\n### 5.2共享内存\n\n位置：设备内存。\n\n形式：关键字`__share__`添加到变量声明中，如：`**__share__ float a[10]**`\n\n访问速度和L1相同\n\n### 5.3常量内存\n\n位置：设备内存\n\n形式：关键字`__constant__`添加到变量声明中，如：`__constant__ float a[10]`\n\n目的：为了提升性能。常量内存采取了不同于全局内存的处理方式，在某些情况下用常量内存替换全局内存能有效的减少内存带宽。\n\n## 6、计时\n\n```cpp\n#include <sys/time.h>\ndouble cpuSecond(){\n\tstruct timeval tp;\n    gettimeofday(&tp,NULL);\n    return ((double)tp.tv_sec + (double)tp.tv_usec*1.e-6);\n}\n\n测试函数(秒)：\ndouble start_time = cpuSecond();\nkernel_function<<<grid,block>>>();\ncudaDeviceSynchronize();\ndouble Elaps = cpuSecond() - start_time; \ncudaEvent_t startCuda, stopCuda;  //declare\ncudaEventCreate(&startCuda);      //set up \ncudaEventCreate(&stopCuda);       //set up\n\ncudaEventRecord(startCuda,0);    //start\nmyAdd <<<grid, threads>>> (d_B, d_C, d_A);\ncudaEventRecord(stopCuda,0);     //finish\n\nfloat eTime;\ncudaEventElapsedTime(&eTime, startCuda, stopCuda); \n\ncout<<eTime<<endl;\n\ncudaEventDestory(startCuda);\ncudaEventDestory(stopCuda);\n```\n\n## 7、获取GPU名字\n\n```cpp\n    cudaDeviceProp deviceProp;\n    cudaGetDeviceProperties(&deviceProp, 0);\n    printf(\"GPU Name: %s\\nJob start:\\n\", deviceProp.name);\n```\n\n## 8、线程束（Wrap)\n\n线程束是SM中基本的执行单元\n\n（SM是Streaming Multiprocessor的缩写，它是指图形处理器(GPU)中的一个核心处理单元）\n\n一个线程束由32个连续的线程组成。是执行程序时的调度单位，同在一个warp的线程执行同一个指令。\n\n\n\n**为什么要引入Wrap？**\n\n虽然GPU的Grid和Block的大小很大，可以拥有上万级别的线程，但因为硬件的限制，不是所有线程都是可以平行运行的。在运行thread的时候， thread会被捆绑到一起形成一个wrap。32个thread一个wrap。 同一个wrap里的指令是一样的，也就是他们运行的东西是一摸一样的，数据也相同。一个wrap里的线程只允许在同一个block里面运行。**为了让程序的运行更加有效，需要让同一个wrap里的线程运行同样的代码。**\n\n**看一个代码：**\n\n```cpp\n__global__ void code_with_divergence()\n{\n\tint idx = threadIdx.x;\n\tif(idx%2==0)\n\t{\n\t\t // do A\n\t}\n\telse\n\t{\n\t\t// do B\n\t}\n}\n```\n\n上面这个这个代码会让效率减少一半。因为当运行A的时候，会让满足条件的那一半thread运行，而另一半的thread会被休眠。\n\n**注意：**不是写了if语句就一定会让运行效率降低。只要能保证用一个wrap里的线程运行同样的指令就可以提升效率，比如如下代码：\n\n```cpp\n__global__ void code_without_divergence()\n{\n\tint idx = blockIdx.x * blockDim.x + threadIdx.x;\n\t// int wrap_id = idx/32;\n    int wrap_id = idx / wrapSize;//固有变量wrapSize = 32\n\tif(wrap_id%2==0)\n\t{\n\t\t // do A\n\t}\n\telse\n\t{\n\t\t// do B\n\t}\n}\n```\n\n代码是以一个wrap为整体去运行的，所以不会影响运行效率。\n\n## 9、如何设置grid和block\n\n\n\n### 前言：\n\nGPU 由多个 SM 处理器构成，一个 SM 处理器包含 8 个 SP 核。一个 SM 处理器可同时处理 32 个线程（Wrap束），实际上是同一套指令在每个 SP 核上重复 4 次， 这样提交一次任务，8 个SP 核同时就能处理 32 个线程。\n\n![img](CUDA基础学习/1699013420617-1a677527-2101-48e4-a317-1841acc8d223.png)\n\n### 设置grid和block维度\n\n如果某个GPU拥有 16 个 SM 处理器，共 128 个 SP 核（16*8）。\n\n1. 如果想让每个 SM 处理器都工作，则 Grid 的 Block 的数量最好是 16 的整数倍。这样在整个计算过程中，每个 SM 处理器负载都是一样的。\n2. 每个 SM 处理器同时可以处理 32 个线程，因此，Block 中的线程数量最好是 32 的倍数，使得 8 个 SP 核负载均衡。\n\n由上可知，应该按照16*N*32*M = 512*S的划分模式，也就是说，理想的数据量应该是 512 的整数倍。同时要注意，一个线程块线程数量不能多于1024！\n\n#### 1.一维grid，一维block\n\n```cpp\nint nx = 1 << 14;\nint ny = 1 << 14;\nint dimx = 32;\ndim3 block(dimx);\ndim3 grid((nx + block.x - 1) / block.x);\n```\n\n核函数\n\n```cpp\n__global__ void kernel_function()\n{\n    unsigned int ix = threadIdx.x + blockIdx.x * blockDim.x;\n    if (ix < nx )\n   {\n        do_something();\n    }\n}\n```\n\n#### 2.二维grid，一维block\n\n```cpp\nint nx = 1 << 14;\nint ny = 1 << 14;\nint dimx = 32;\ndim3 block(1, dimx);\ndim3 grid(nx, (ny + block.y - 1) / block.y);\n```\n\n核函数\n\n```cpp\n__global__ void kernel_function()\n{\n    int x = blockIdx.x;\n    int y = blockIdx.y*blockDim.y+threadIdx.y;\n}\n```\n\n#### 3.二维grid，二维block\n\n```cpp\nint nx = 1 << 14;\nint ny = 1 << 14;\nint dimx = 32;\nint dimy = 32;\ndim3 block(dimx, dimy);\ndim3 grid((nx + block.x - 1) / block.x, (ny + block.y - 1) / block.y);\n```\n\n核函数\n\n```cpp\n__global__ void kernel_function()\n{\n    unsigned int x = threadIdx.x + blockIdx.x * blockDim.x;\n    unsigned int y = threadIdx.y + blockIdx.y * blockDim.y;\n    unsigned int tid = x*ny + y;\n    if (ix < nx && iy < ny)\n    {\n        do_something();\n    }\n}\n```\n\n![img](CUDA基础学习/1699272791683-3f21b828-d2bd-4311-b305-d7185839e59d.png)\n\n## 文档\n\nhttps://www.zhihu.com/tardis/bd/art/566538074\n\nhttps://zhuanlan.zhihu.com/p/573271688\n","tags":["超算"]},{"title":"MPI学习","url":"/2022/02/05/MPI学习/","content":"\n## 结构\n\n![img](MPI学习/1682166215330-26e94a49-e523-43fb-9c2f-82ff9f1dea1d.png)\n\n![img](MPI学习/1682166328064-3d1cc549-b1ac-4cb0-ad4f-3149bd2ed3cc.png)\n\n## 一、MPI基本函数\n\n1、完成MPI**程序初始化**，通过获取main函数的参数，让每一个MPI进程都获取到main的函数\n\n```csharp\nMPI_Init(NULL,NULL)\n或\nMPI_Init(int *argc,char ***argv)\n```\n\n\n\n2、获取调用进程在给定的通信域中的**进程标识号**\n\n```cpp\nMPI_Comm_rank(MPI_Comm comm, int *rank)\n```\n\n\n\n3、获取当前通信域中的**进程个数**\n\n```cpp\nMPI_Comm_size(MPI_Comm comm,int *size)\n```\n\n\n\n4、MPI程序的最后一个调用，**清除全部MPI环境**\n\n```cpp\nMPI_Finalize()\n```\n\n\n\n## 二、MPI数据结构\n\n![img](MPI学习/1682170871131-718c8b78-eeb8-4609-9b46-e4dfe0c55102.png)\n\n## 三、点对点通信\n\n![img](MPI学习/1682168231767-b8a2a2a4-b604-4f2e-ad44-78efaf939968.png)\n\n```cpp\nMPI_Send(void *buff,int count,MPI_Datatype datatype,int dest,int tag, MPI_Comm comm)\nMPI_Recv( void *buff, int count, MPI_Datatype datatype, int source, int tag, MPI_Comm comm, MPI_Status *status)\n```\n\n| void *buff            | 发送的消息变量指针**/**接收变量保存位置          |\n| --------------------- | ------------------------------------------------ |\n| int count             | 发送/接收消息的个数（不是长度）                  |\n| MPI_Datatype datatype | 发送/接收消息的MPI数据类型                       |\n| int dest              | 目的进程号                                       |\n| int source            | 源进程号（**MPI_ANY_SOURCE**）                   |\n| int tag               | 消息标签（发送和接受要相同，或者**MPI_ANY_TAG**) |\n| MPI_Comm comm         | 通信域                                           |\n| MPI_Status *status    | 状态                                             |\n\n **注意count：**不是长度，例如你要发送一个int整数，这里就填写1，如要是发送“hello”字符串，这里就填写6（C语言中字符串未有一个结束符，需要多一位）。它是接收数据长度的**上界**. 具体接收到的数据长度可通过调用**MPI_Get_count** 函数得到。\n\n### MPI环境异常退出\n\n```\nMPI_Abort(comm,errorcode)\n```\n\n--comm 通信域\n\n--errorcode 返回到嵌套环境的错误码\n\n![img](MPI学习/1682170321835-db5a2fd6-4859-452e-874d-7063a679ea79.png)\n\n### 死锁\n\n![img](MPI学习/1682169954019-a674414b-3d71-433f-b17c-93ece818c07b.png)\n\n此时**进程0**和**进程1**都在等待对方发送消息\n\n### 缓存模式\n\n![img](MPI学习/1682171040745-2084a097-cd4a-4e66-ac9e-498fe9eac927.png)\n\n#### MPI申请缓冲区：\n\n```cpp\nMPI_Buffer_attach(buffer,size)\n--buffer 初始缓存地址(可选数据类型)\n--size 按字节计数的缓存大小\n```\n\n#### MPI释放缓冲区\n\n```cpp\nMPI_Buffer_detach(buffer,size)\n--buffer 缓冲区初始地址\n--size 字节为单位的缓冲区大小\nvoid bsend_test()\n{\n\tint rank = 0;\n\tMPI_Comm_rank(MPI_COMM_WORLD, &rank);\n\tchar str[MSG_SIZE] = { 0 };\n\tsprintf(str, \"use bsend hello i'm rank %d\", rank);\n\tint strsize = strlen(str);\n\tint bsize = 0;\n\tMPI_Pack_size(strsize, MPI_CHAR, MPI_COMM_WORLD, &bsize);\n\tchar * tmpbuffer = nullptr;\n\ttmpbuffer = (char*)malloc(bsize + 2 * MPI_BSEND_OVERHEAD);\n\n\tif (!tmpbuffer) {\n\t\tMPI_Abort(MPI_COMM_WORLD, 1);\n\t}\n\tMPI_Buffer_attach(tmpbuffer, bsize + 2 * MPI_BSEND_OVERHEAD);\n\tMPI_Bsend(str, strlen(str), MPI_CHAR, MSG_RECV_RANK, MSG_TAG, MPI_COMM_WORLD);\n\n\tchar * buf;\n\tint tsize = 0;\n\tMPI_Buffer_detach(&buf, &tsize);\n\n\tdouble wtime = MPI_Wtime();\t// 获取运行时间\n\tdouble wtick = MPI_Wtick();\t// 获取时间单位(s),如果是毫秒则为0.001\n\tcout << \"rank \" << rank << \" bsend success, times :\" << wtick * wtime << endl;\n}\n```\n\n### 同步通信模式\n\n![img](MPI学习/1682172948049-7898f153-167c-4c58-b5d8-bbd777c7b47f.png)\n\n`MPI_Ssend（）`参数类似于标准模式\n\n## 四、组通信\n\n### 广播\n\nMPI广播函数：`MPI_Bcast(buffer,count,dataType,root,comm)`\n","tags":["超算"]},{"title":"OpenMP学习","url":"/2022/02/05/OpenMP学习/","content":"\n## 一、openMP语句模式：\n\n```\n#pragma omp 指令 子句 子句 子句........\n```\n\n## 二、parallel 制导命令：\n\n表示接下来由花括号括起来的区域将创建多个线程并行执行\n\n可以用`num_threads`来控制使用的线程数目。\n\n```\n#pragma omp parallel num_threads(5)\n```\n\n**函数实现线程数目控制**：`omp_set_num_threads(5)`\n\n\n\n## 三、for 循环语句\n\n每一个要**循环的语句**将被分配给不同的线程去执行。\n\n```\n#pragma omp for\n```\n\n**tips**:循环体要按照`for(int i=0;i<n;i++)`的形式，注意int！要在for初始化\n\n```cpp\n#pragma omp parallel\n{\n    #pragma omp for\n    for(int i=0;i<n;i++)\n        {\n            // 执行语句\n        }\n}\n```\n\nparallel 和 for 可以写成一个整体，即：\n\n```cpp\n#pragma omp parallel for\nfor(int i=0;i<n;i++)\n{\n    // 执行语句\n}\n```\n\n## 四、for循环语句分配模式\n\n**schedule子句**：`schedule(type,size)`\n\n- type：**①static ②dynamic ③guided ④runtime**\n- size：整数型，表示**循环迭代次数划分单位**\n\n#### 1、static参数：静态调度\n\n- - 不用size参数时，分配给每个程序的都是n/t次连续迭代（n为迭代次数，t为并行的线程数目）\n  - 使用size参数，表示每次分配给线程size次的连续迭代（进入size个for中的任务）。\n\n#### 2、dynamic参数：动态调度\n\n先到先得的方式进行任务分配\n\n- - 不使用size参数时，空闲线程取**一个任务**\n  - 使用size参数时候，空闲线程取**size个任务**\n\n#### 3、guided参数：\n\n刚开始每个线程会分配到比较大的迭代块，后来分配到的迭代块逐渐递减，没有指定size就会降到1，否则降到size。\n\n#### 4、runtime参数：了解，基本不用\n\n\n\n**代码示例：**\n\n```cpp\n#include<omp.h>\n#include<iostream>\nusing namespace std;\nint main()\n{\n\tomp_set_num_threads(2);\n#pragma omp parallel for schedule(static)\n\t\tfor(int i=0;i<8;i++)\n\t\t cout << omp_get_thread_num() << endl;\n}\n```\n\n## 五、sections制导指令\n\n用sections把**不同的区域交给不同的线程**去执行\n\n**代码示例：**\n\n```cpp\n#include <bits/stdc++.h>\n#include <omp.h>\nusing namespace std;\nint main()\n{\n    #pragma omp parallel sections\n    {\n        #pragma omp section\n        {\n            // 句段1\n        }\n        #pragma omp section\n        {\n            // 句段2\n        }\n    }\n}\n```\n\n\n\n## 六、single制导语句\n\nsingle制导指令所包含的代码段只有一个线程执行，别的线程跳过。\n\n如果没有nowait子句，那么其他线程将会在single制导指令结束的隐式同步点等待。\n\n有nowait子句其他线程将跳过等待往下执行。\n\n```\n#pragma omp single\n#pragma omp single nowait\n```\n\n![img](OpenMP学习/1679317378675-95533af2-7f94-4a56-94ac-d0510a5effca.png)![img](OpenMP学习/1679317422046-122a578f-043b-43a8-8686-59db0eb7cf48.png)\n","tags":["超算"]},{"title":"web前端开发","url":"/2022/02/05/web前端开发/","content":"\n# HTML\n\n## 一、基础标签\n\n#### 1、<hr>分割线标签\n\n```html\n<!DOCTYPE html>\n<html>\n\t<head>\n\t\t<meta charset=\"utf-8\" />\n\t\t<title></title>\n\t</head>\n\t<body>\n\t\t<hr color=\"red\" />\n\t\t<hr color=\"green\" width=\"200\"/>\n\t\t<hr color=\"blue\" align=\"right\" width=\"100\"/>\n\t\t<hr />\n\t\t<hr noshade=\"noshade\"/> <!--无阴影-->\n\t</body>\n</html>\n```\n\n![img](web前端开发/1695631951027-f9965548-67e1-4eab-8cd5-eb0f942e0f66.png)\n\n#### 2、特殊符号\n\n![img](web前端开发/1695632165459-ed017fbb-bb0c-4d34-8033-989aa2baa0c6.png)\n\n#### 3、<div>和<span>标签\n\n**div标签：**无具体含义，用来划分区域，独占一行\n\n**span标签：**没有实际意义，主要用于文本的独立修饰，内容原来有多宽就占用多宽\n\n```html\n\t\t<h3>体育sports</h3>\n\t\t<h3>体育<span style=\"color: red;\">sports</span></h3>\n```\n\n![img](web前端开发/1695632731353-81a36c73-b073-4d9c-8878-06a570d49c8b.png)\n\n#### 4、<ul>、<ol>列表以及自定义列表\n\n![img](web前端开发/1695633169978-e673c111-5d9b-419b-be46-8614c153f976.png)\n\n```html\n<ol type=\"I\" start=\"3\">\n  <li>III</li>\n  <li>IV</li>\n  <li>V</li>\n</ol>\ntype：1,a,A,I,i\nstart：取值只能是一个数字\n<ul type=\"square\">\n  <li>1111</li>\n  <li>2222</li>\n</ul>\ntype: disc,circle,square,none\n<dl>\n  <dt>我是图片</dt>\n  <dd>我是文字</dd>\n</dl>\n```\n\n#### 5、<img>图片标签\n\n支持jpeg/png/gif三种格式\n\n```html\n同级目录：<img src=\"1.jpg\">\n上级目录：<img src=\"../1.jpg\">\n绝对路径\n<img src=\"图片路径\" \n  \ttitle=\"鼠标悬停上去后的文字提示\"\n  \talt=\"图片加载失败的文字提示\"\n    width=\"宽度\"\n\t\theight=\"高度\" />\n```\n\n#### 6、<a>超链接标签\n\n```html\n<a href=\"跳转路径\"\n  \ttitle=“鼠标悬停文字”\n    target=\"规定在何处打开\">\n  可视内容\n</a>\ntarget属性：规定在何处打开\n\ttarget=\"_self\" 默认值，本窗口打开\n\ttarget=\"_blank\" 新窗口打开\n\n<a href=\"www.baidu.com\" title=\"点击一下，了解更多\" target=\"_blank\">\n\t<img src=\"baidu.png\" />\n</a>\n\n<a href=\"#link_to_this\">点击到达</a>\n<p name=\"link_to_this\"></p>\n\n<a href=\"mailto:vicczyq@qq.com\">发送邮件</a>\n```\n\n![img](web前端开发/1695635303035-80966f86-af1c-4ec3-9c01-6665955ef326.png)\n\n#### 7、<table>表格标签\n\n<table>表格属性：\n\n1. width 宽度\n2. height 高度\n3. border 边框\n4. bordercolor 边框颜色\n5. bgcolor 背景颜色\n6. align 对齐：right、left、center\n7. cellspacing 单元格与单元格之间的间距\n8. cellpadding 单元格和内容之间的空隙\n\n**<tr>行属性：（没有width宽度属性）**\n\n1. height 高度\n2. bgcolor 背景颜色\n3. align 文字水平对齐left、right、center\n4. valign 文字垂直对齐top、middle、bottom\n\n**<td>单元格属性：**\n\n1. width 宽度（影响一列的宽度）\n2. height 高度（影响一行的高度）\n3. bgcolor 背景颜色\n4. align 文字水平对齐\n5. valign 文字垂直对齐\n\n```html\n\t\t<table>表\n\t\t\t<tr>行\n\t\t\t\t<td>1</td>单元格\n\t\t\t\t<td>2</td>\n\t\t\t</tr>\n\t\t\t<tr>\n\t\t\t\t<td>3</td>\n\t\t\t\t<td>4</td>\t\t\t\t\n\t\t\t</tr>\n\t\t</table>\n```\n\n**表格的合并：colspan合并列、rowspan合并行**\n\n#### 8、form表单标签\n\n```html\n<form method=\"get/post\" action=\"表单数据发送URL\">\n\t<input type=\"...\" />\n  <\n      A. 属性type定义输入框的类型\n        \ta) 文本框、密码框 <input type=\"text|password\" />\n          b) 提交框 <input type=\"submit\" />\n          c) 按钮框 <input type=\"button\" /> 单纯的按钮\n          d) 重置框 <input type=\"reset\" />清空表单内容\n          e) 单选框 <input type=\"radio\" name=\"sex\" value=\"male\"/>男\n                    <input type=\"radio\" name=\"sex\" value=\"female\"/>女\n          f) 多选框 <input type=\"checkbox\" name=\"transport\" value=\"bike\" />自行车\n                    <input type=\"checkbox\" name=\"transport\" value=\"bus\" />公共汽车\n          g) 文件上传<input type=\"file\" />\n          h) 下拉菜单 <select size=\"3\" name=\"xxx\">//视角大小为3\n                        <option disabled selected>==请选择===</option>\n                        <option value=\"1\">1</option>\n                        <option value=\"2\">2</option>\n                        <option value=\"3\">3</option>\n          \t\t\t\t\t\t</select>\n          i) 多行文本 <textarea name=\"xxx\" rows=2 cols=1>…</textarea>\n    \n      B. 属性placeholder描述输入字段预期值的简短信息提示\n      C. 属性name必须设置，否则在提交的时候输入的数据不会发送\n      D. 属性value,输入框默认输入内容，加在按钮上为标题\n\t\t      如：<input type=\"submit\" value=\"上传\" />\n              <input type=\"reset\" value=\"重置\" />\n>\n</form>\n```\n\ndisabled属性可以禁用\n\n**<filedset>...</filedset>**可以设置分组，中间加**<legend>**标签可以设置主题\n\n![img](web前端开发/1695822025377-d717d6d5-d7d8-4159-97e0-4bce7640e258.png)\n\n#### 9、锚点\n\n```html\n<div id=\"#aaa\"></div>\n<!-- 锚点aaa -->\n<a herf=\"#aaa\">点击定位到a</a>\n```\n\n# CSS\n\n```html\n<head>\n    <style >\n      *{\t\t\t\t\t\t\t\t通用选择器\n        margin:0px\t\t\n      }\n      h1{\t\t\t\t\t\t\t\t标签选择器\n        color:red;\n      }\n      #name{\t\t\t\t\t\t类选择器class\n        color:green;\n      }\n      .id {\t\t\t\t\t\t\tid选择器\n        color:blue\n      }\n    </style>\n</head>\n方法一：\n<style type=\"text/css\">\n  @import url(\"CSS文件路径\")\n</style>\n方法二：\n<link rel=\"stylesheet\" type=\"text/css\" href=\"css文件路径\">\n<div style=\"width:200px\"></div>\n```\n\n\n\n**CSS样式表的****优先级****：行内>内部>外部**\n\n```html\na:link{属性:属性值}\t超链接的初始状态\na:visited{属性:属性值} 超链接被访问后的状态\na:hover{属性:属性值} 鼠标悬停时的状态\na:active{属性:属性值} 鼠标按下超链接的状态\n```\n\nlink--visited--hover--active\n\n### 1、文本属性\n\n![img](web前端开发/1695639480688-c5abcf44-95c5-4ace-a1f2-ccd3cf40a9f9.png)![img](web前端开发/1695799466350-aec44770-7a22-49dc-aef3-65d8fb270f69.png)\n\n```html\n文本首字母大写：text-transform:capitalize\n文本转小写：text-transform:lowercase\n文字转大写：text-transform:uppercase\n```\n\n### 2、列表属性\n\n![img](web前端开发/1695800346011-6fc94c4d-a49d-46e1-ad79-df04b295c891.png)\n\n### 3、背景属性\n\n![img](web前端开发/1695800590244-632d630f-cc2e-47ce-bb7b-27304356b5bf.png)\n\n```html\nbackground-size:cover\nbackground-size:100% 100%\nbackground-size:100px 100px\n```\n\n### 4、浮动float属性\n\n![img](web前端开发/1695802285408-dd289a7f-fdf1-4364-90c7-1c361591aa3d.png)![img](web前端开发/1695802457654-cd1a1173-e0bb-41c7-b60f-eb997cc869d7.png)\n\n### 5、盒子模型\n\n![img](web前端开发/1695802939375-75259be5-d93f-42a4-96fd-3d566c0e35c2.png)\n\n#### 内边距 padding、外边距 margin\n\n- 1个值，4个方向一样\n- 2个值，上下，左右\n- 3个值，上，左右，下\n- 4个值，上，右，下，左\n\n\n\n#### 边框 border（width style color）\n\n```\nborder:1px solid red\n```\n\n**样式：**\n\n1. none：没有边框，也即忽略边框的宽度；\n2. dotted：点线；\n3. dashed：虚线；\n4. solid：实线；\n5. double：双线；\n6. groove：3D凹槽；\n7. ridge：菱形边框；\n8. inset：3D凹边；\n9. outset：3D凸边；\n\n#### 屏幕横向居中\n\n```\nmargin:0 auto\n```\n\n#### 注意：margin垂直方向外边距取最大值，水平方向取和\n\n### 6、溢出属性\n\n#### (1)overflow:\n\n![img](web前端开发/1695804858012-6f571f7d-f009-4618-b32a-bc3f4902de4e.png)\n\n#### (2)white-space\n\n![img](web前端开发/1695805168006-c97b87c7-7866-464a-bb8a-eadf9eec1759.png)\n\n#### (3)text-overflow（必须有宽度width！！！！）\n\n```\ntext-overflow:ellipsis\n```\n\n![img](web前端开发/1695805461984-30bbe8ad-0988-45ab-8b92-9f90741aa36f.png)\n\n### 7、元素显示类型\n\n![img](web前端开发/1695805704515-66885476-500c-470c-8b4e-5ced19fd7dee.png)\n\n可以用`display`进行相互转换\n\n### 8、定位\n\n![img](web前端开发/1695816702982-0509abbb-132a-4d4c-9dce-48f21c6f019a.png)\n\n父子关系如果想让父盒子显示在上面：在子盒子中设置z-index为负值即可\n\n### 9、三角形案例\n\n![img](web前端开发/1695817864798-a6945562-adac-47f4-af09-5b7c1f8d3f0a.png)\n\n```html\n\t\t<style type=\"text/css\">\n\t\t\tdiv{\n\t\t\t\theight: 0px;\n\t\t\t\twidth: 0px;\n\t\t\t\tborder-top: 20px solid red;\n\t\t\t\tborder-right: 20px solid transparent;\n\t\t\t\tborder-bottom: 20px solid transparent;\n\t\t\t\tborder-left: 20px solid transparent;\n\t\t\t}\n\t\t</style>\n```\n\n### 10、水平垂直居中\n\n```html\n\t\t<style type=\"text/css\">\n\t\t\t*{\n\t\t\t\tmargin: 0;\n\t\t\t\tpadding: 0;\n\t\t\t}\n\t\t\tdiv{\n\t\t\t\theight: 200px;\n\t\t\t\twidth: 200px;\n\t\t\t\tbackground-color: red;\n\t\t\t\tposition: absolute;\n\t\t\t\ttop: 50%;\n\t\t\t\tleft: 50%;\n\t\t\t\tmargin-left: -100px;\n\t\t\t\tmargin-top: -100px;\n\t\t\t}\n\t\t</style>\n```\n\n![img](web前端开发/1695818652162-9b170132-d822-4063-b482-e0742762bbde.png)\n\n### 11、浮动和绝对定位的区别\n\n浮动是半脱离状态，文字是环绕效果\n\n![img](web前端开发/1695818906440-c1c0d98c-7967-4cc3-ab02-d23ddcb46750.png)\n\n定位是全脱离状态，不会出现文字环绕效果\n\n![img](web前端开发/1695818881031-d284e957-f409-4ec3-890a-36d736018a4a.png)\n\n### 12、calc计算函数\n\n```\nwidth: calc(100% - 200px)\n```\n\n### 13、圆角属性\n\n```\nborder-radius: 2px\n```\n\n等价于：\n\n![img](web前端开发/1698233180004-a75117ef-636f-4f39-9145-9c6ae82f184c.png)\n\n### 14、方框阴影属性\n\n```\nbox-shadow: <h-shadow> <v-shadow> [blur] [spread] [color] [inset]\n```\n\n![img](web前端开发/1698233434344-7616929e-0211-468f-ba84-dcee322cc129.png)\n\n# JavaScript\n\n```html\n嵌入网页\n<script type=\"text/javascript\">\n    //JavaScript程序\n</script>\n\n单独.js文件调用\n<script type=\"text/javascript\" src=\"xxx/xx.js\">\n</script>\n```\n\n**变量声明：**\n\n`**var**`要求不严格，可以在作用范围内重复\n\n`**let**`要求严格，在相同的作用域内不能重复声明同一个变量\n\n**常量声明：**\n\n`**const**`不能与let声明的变量重复，一旦声明就必须初始化，值不能改变\n\n```\nconst a = 3.1415\n```\n\n## 类型转换\n\n- parseInt(String)\n- parseFloat(String)\n- Number(String) 将字符串转化为数值型\n- toFixed(String) 按照指定的小数位返回数字的字符串表示\n\n## 注释\n\n单行注释用// 多行用/**/\n\n```javascript\n//单行注释内容\n\n/*多行注释\nHello\nworld!\n*/\n```\n\n## typeof\n\n操作数的类型\n\n## 数组\n\n1. 新建长度为0的数组：`var myArray = new Array();`\n2. 新建长度为n的数组：`var myArray = new Array(n);`\n3. 新建一个指定内容的数组：`var myArray = new Array(1,2,3);`\n4. 简介定义：`var myArray = [1,2,3];`\n5. 获取数组长度 `myArray.length;`\n6. `push()/pop()栈方法`\n\n内容可以用alert输出（提示框）\n\n### 数组相关方法：\n\n#### （1）concat方法\n\n```javascript\nvar a=[1,2,3];\nvar b=[4,5,6];\nalert(a.concat(b));//输出1,2,3,4,5,6\nalert(a.length);//长度仍为3\n可以直接连接数值\n如：a.concat(4,5,6);\n```\n\n#### （2）join方法\n\n```javascript\nvar a=[1,2,3];\nalert(a.join());//输出1,2,3,\nalert(a.join(\":\"));//输出1:2:3\n```\n\n#### （3）shift方法\n\n```javascript\nvar a=[1,2,3];\nalert(a.shift());输出1\nalert(a.shift());输出2\nalert(a.length);输出长度1\n```\n\n#### （4）unshift方法\n\n```javascript\nvar a=[1,2,3];\na.unshift(4,5,6);\nalert(a);//输出4,5,6,1,2,3\n```\n\n#### （5）slice方法\n\n```javascript\nvar a1=[1,2,3,4,5];\nalert(a1.slice(1,3)); //输出2,3\nalert(a1.slice(1));   //输出2,3,4,5\nalert(a1.slice(1,-1)); //输出2,3,4\nalert(a1.slice(-3,-2)); //输出3\n```\n\n#### （6）sort方法\n\n```javascript\nvar a1=[1,4,2,3,5];\nalert(a1.sort());  //输出1,2,3,4,5\n```\n\n#### （7）reverse方法\n\n## JavaScript函数\n\n```javascript\nfunction 函数名(参数1,参数2...)\n{\n    // 函数内容\n    // [return <返回值>]\n}\n<input type=\"Submit\" value=\"显示\" onClick=\"函数名()\">\n```\n\n### 常见事件：\n\n| **事件**     | **动作**                     | **事件**      | **动作**                           |\n| ------------ | ---------------------------- | ------------- | ---------------------------------- |\n| **Abort**    | **中止正在加载的对象**       | **Load**      | **浏览器读入文件时**               |\n| **Blur**     | **失去焦点**                 | **Unload**    | **关闭当前网页**                   |\n| **Focus**    | **获取焦点**                 | **MouseDown** | **按下鼠标左键**                   |\n| **Change**   | **改变对象的值**             | **MouseMove** | **移动鼠标指针**                   |\n| **Click**    | **在对象上单击鼠标**         | **MouseOut**  | **鼠标指针离开某对象**             |\n| **DblClick** | **在对象上双击鼠标**         | **MouseOver** | **鼠标指针悬停于某对象之上**       |\n| **DrogDrop** | **拖拽对象**                 | **MouseUp**   | **放开鼠标左键**                   |\n| **Error**    | **加载文件或图形时发生错误** | **Move**      | **窗口被移动时**                   |\n| **KeyDown**  | **按下键盘上的任意键的瞬间** | **Resize**    | **窗口大小被改变**                 |\n| **KeyPress** | **按下键盘上的任意键时**     | **Select**    | **选择某对象**                     |\n| **KeyUp**    | **某键被按下后弹起来的瞬间** | **Submit**    | **单击表单上的****Submit****按钮** |\n|              |                              | **Reset**     | **单击表单上的****Reset****按钮**  |\n\n### document对象及操作\n\ndocument表示整个页面文档\n\n#### （1）documen.getElementById(id)\n\n```\nvar a = document.getElementById(\"name\").value;\n```\n\n#### （2） document.getElementsByName(name)\n\n```javascript\nvar userNameInput=document.getElementsByName(\"userName\");\nvar userName = userNmaeInput[0].value;\n返回值为数组对象；如果无符合条件的对象，则返回空数组\n由于该方法的返回值是一个数组，所以可以通过位置下标来获得页面元素\n```\n\n#### （3）document.getElementsByTagName(tagname)\n\n```javascript\n返回值：数组对象; 如果无符合条件的对象，则返回空数组\n例如：\nvar inputs=document.getElementsByTagName(“input”);\nalert(input.length);   //显示为4\n```\n\n#### （4）document.forms\n\n```javascript\n返回值：数组对象。如果无符合条件的对象(Form对象)，则返回空数组\n例如：\nvar frms=document.forms;  //先获得数组对象，注意不是方法，是属性\nvar loginfrm=frms[0]; //获得数组中的第一个form对象，如果存在的话\n```\n\n### document属性\n\n#### (1)innerHTML属性\n\n```javascript\n<p id=\"p1\">Hello World!</p>\n<script>\ndocument.getElementById(\"p1\").innerHTML=\"New text!\";\n</script>\n\n<script>\ndocument.getElementById(\"p2\").style.color=\"blue\";\n</script>\n```\n\n#### (2)操作HTML\n\n```javascript\nvar para = document.createElement(\"p\");\nvar node = document.createTextNode(\"新段落\");\npara.appendChild(node);\nvar element=document.getElementById(\"div1\");\nelement.appendChild(para);\n```\n\n#### (3)改变元素属性\n\n```javascript\nobj.getAttribute(attribute);\nobj.setAttribute(attribute,value);\n//getAttribute方法就是专门用来获取元素属性的\n//相应的我们也可以使用setAttribute方法来更改元素节点的值\n例如：\ndocument.getElementById(\"div1\").getAttribute(\"name\");\n```\n\n#### (4)删除元素\n\n```javascript\nvar child=document.getElementById(\"p1\");\nvar parent=document.getElementById(\"div1\");\nparent.removeChild(child);//从父元素中删除该元素\n    <script>\n        const loginForm = document.getElementById('loginForm');\n        const usernameInput = document.getElementById('username');\n        const passwordInput = document.getElementById('password');\n        const usernameMessage = document.getElementById('username-message');\n\t\t\t\tconst passwordMessage = document.getElementById('password-message');\n\n        loginForm.addEventListener('submit', function (event) {\n            event.preventDefault(); \n            const username = usernameInput.value;\n            const password = passwordInput.value;\n      \t\t\tshowMessage(passwordMessage,'');\n      \t\t\tshowMessage(usernameMessage,'');\n      \t\t\tvar user_flag = false;\n      \t\t\tvar pass_flag = false;\n            if (username.length === 0)showMessage(usernameMessage,'请输入用户名');\n            else if (!isEnglishCharacter(username))showMessage(usernameMessage,'用户名必须以英文字母开头！');  \n            else if(username.length < 6||username.length>18)showMessage(usernameMessage,\"用户名必须在6到18位\");\n\t\t\t\t\t\telse user_flag = true;\n  \n            if (password.length < 6)showMessage(passwordMessage,\"密码不能小于6位！\"); \n            else pass_flag=true; \n            if(pass_flag && user_flag)\n            {\n            \talert(\"注册成功！！\");\n            }\n        });\n      \n        function isEnglishCharacter(input) {\n            const firstChar = input.charAt(0);\n            // const firstCharCode = firstChar.charCodeAt(0);\n            return (firstChar >='a' && firstChar <='z') || (firstChar >='A' && firstChar <='Z');\n            // return (firstCharCode >= 65 && firstCharCode <= 90) || (firstCharCode >= 97 && firstCharCode <= 122);\n        }\n\n        function showMessage(element,message) {\n           element.textContent = message;\n        }\n    </script>\n```\n\n# JQurey\n\n```html\n\t\t<script>\n\t\t\t$(document).ready(\n\t\t\t\tfunction(){\n\t\t\t\t\tfunction loadStuInfo(){\n\t\t\t\t\t\t$.ajax({\n\t\t\t\t\t\t\ttype:\"get\",\n\t\t\t\t\t\t\turl:\"http://114.67.241.121:8123/stu/list\",\n\t\t\t\t\t\t\tasync:true,\n\t\t\t\t\t\t\tsuccess: function(e){\n\t\t\t\t\t\t\t\t$(\"#info\").find(\"tr:gt(0)\").remove();\n\t\t\t\t\t\t\t\tfor(var i=0; i<e.data.length;i++)\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t$(\"#info\").append(\n\t\t\t\t\t\t\t\t\t\t\"<tr>\"+\n\t\t\t\t\t\t\t\t\t\t\t\"<td>\"+e.data[i].stuid+\"</td>\"+\n\t\t\t\t\t\t\t\t\t\t\t\"<td>\"+e.data[i].stuno+\"</td>\"+\n\t\t\t\t\t\t\t\t\t\t\t\"<td>\"+e.data[i].stuname+\"</td>\"+\n\t\t\t\t\t\t\t\t\t\t\t\"<td>\"+e.data[i].stumajor+\"</td>\"+\n\t\t\t\t\t\t\t\t\t\t\t\"<td>\"+e.data[i].stugender+\"</td>\"+\n\t\t\t\t\t\t\t\t\t\t\t\"<td>\"+e.data[i].stugrade+\"</td>\"+\n\t\t\t\t\t\t\t\t\t\t\t\"<td>\"+e.data[i].stuphone+\"</td>\"+\n\t\t\t\t\t\t\t\t\t\t\t\"<td>\"+e.data[i].stuaddess+\"</td>\"+\n\t\t\t\t\t\t\t\t\t\t\t\"<td>\"+e.data[i].stunative+\"</td>\"+\n\t\t\t\t\t\t\t\t\t\t\t\"<td><a href='' class='delete'>删除</a>\"+\n\t\t\t\t\t\t\t\t\t\t\"</tr>\"\n\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tloadStuInfo();//初始化数据\n\t\t\t\t\t\n\t\t\t\t\t$(\"#submit\").click(\n\t\t\t\t\t\tfunction(){\n\t\t\t\t\t\t\t$.ajax({\n\t\t\t\t\t\t\t\ttype:\"post\",\n\t\t\t\t\t\t\t\tdataType: 'json',\n\t            \t\t\t\tcontentType: 'application/json',\n\t\t\t\t\t\t\t\turl:\"http://114.67.241.121:8123/stu/add\",\n\t\t\t\t\t\t\t\tdata:JSON.stringify(\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t  stuaddess: $(\"#stuaddress\").val(),\n\t\t\t\t\t\t\t\t\t  stugender: $(\"#stugender\").val(),\n\t\t\t\t\t\t\t\t\t  stugrade: $(\"#stugrade\").val(),\n\t\t\t\t\t\t\t\t\t  stuid: 0,\n\t\t\t\t\t\t\t\t\t  stumajor: $(\"#stumajor\").val(),\n\t\t\t\t\t\t\t\t\t  stuname: $(\"#stuname\").val(),\n\t\t\t\t\t\t\t\t\t  stunative: $(\"#stunative\").val(),\n\t\t\t\t\t\t\t\t\t  stuno: $(\"#stuno\").val(),\n\t\t\t\t\t\t\t\t\t  stuphone: $(\"#stuphone\").val()\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t),\n\t\t\t\t\t\t\t\tsuccess:function(e){\n\t\t\t\t\t\t\t\t\tconsole.log(JSON.stringify(e));\n\t\t\t\t\t\t\t\t\tloadStuInfo();\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t}\n\t\t\t\t\t);\n\t\t\t\t\n\t\t\t\t\t$(\"#info\").on(\"click\",\"a\",function(event)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tevent.preventDefault();\n\t\t\t\t\t\t\tvar stuid = $(this).closest(\"tr\").children(\":eq(0)\").text();\n\t\t\t\t\t\t\t//let stuid = $(this).closest(\"tr\").children().first().text();\n\t\t\t\t\t\t\t$.ajax({\n\t\t\t\t\t\t\t\ttype:\"post\",\n\t\t\t\t\t\t\t\turl:\"http://114.67.241.121:8123/stu/del\",\n\t\t\t\t\t\t\t\tdata: \"stuId=\" + stuid,\n\t\t\t\t\t\t\t\tsuccess:function(e){\n\t\t\t\t\t\t\t\t\tconsole.log(JSON.stringify(e));\n\t\t\t\t\t\t\t\t\tloadStuInfo();\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t}\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t);\n\t\t</script>\n```\n\n![img](web前端开发/1698476517302-c078f5c0-030c-48ee-ad49-7db744722890.png)\n"}]