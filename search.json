[{"title":"实习学习日志","url":"/2024/06/17/实习学习日志/","content":"\n# 一、LU分解\n\n假设`A = LU`，方程`Ax = b`即可写成`LUx = b`\n\n此时令`Ux = y`，即可通过一对方程来求解x x*x*，写作\n$$\n\\begin{equation}\n\\left\\{\n\\begin{array}{l}\nLy = b \\\\\nUx = y\n\\end{array}\n\\right.\n\\end{equation}\n$$\n因此，求解过程就可以转换为\n$$\n\\begin{equation}\n\\begin{aligned}\nLUx &= b \\\\\n⇒x &= (LU)^{-1} b \\\\\n  &= U^{-1} L^{-1} b\n\\end{aligned}\n\\end{equation}\n$$\n实际应用中，矩阵A往往是固定的，而右侧向量b经常会替换。当矩阵A被分解后，L和U可充分利用，提高效率。\n\n**注意事项：**选主元时尽量选最大数所在的行，然后将其交换到第一行\n\n## 示例：\n\n$$\nA = \\begin{pmatrix}\n1 & 5 & -3 \\\\\n-2 & -7 & 3 \\\\\n4 & 9 & 6\n\\end{pmatrix}\n$$\n\n通常手动消元的时候，消元顺序不是固定的，但是在LU分解时，消元顺序是固定的，即**以第一行为主元，依次向下消元，最终消元为一个上三角矩阵**。\n$$\nA = \\begin{bmatrix}\n1 & 5 & -3 \\\\\n-2 & -7 & 3 \\\\\n4 & 9 & 6\n\\end{bmatrix}\n\\xrightarrow{\\substack{E_{21} \\\\ r_2 + 2r_1}}\n\\begin{bmatrix}\n1 & 5 & -3 \\\\\n0 & 3 & -3 \\\\\n4 & 9 & 6\n\\end{bmatrix}\n\\xrightarrow{\\substack{E_{31} \\\\ r_3 - 4r_1}}\n\\begin{bmatrix}\n1 & 5 & -3 \\\\\n0 & 3 & -3 \\\\\n0 & -11 & 18\n\\end{bmatrix}\n\\xrightarrow{\\substack{E_{32} \\\\ r_3 + \\frac{11}{3} r_2}}\n\\begin{bmatrix}\n1 & 5 & -3 \\\\\n0 & 3 & -3 \\\\\n0 & 0 & 7\n\\end{bmatrix} = U\n$$\n上述变换过程为\n\n\n$$\nE_{32}​E_{31}​E_{21}​A=U\n$$\n其中\n$$\nE_{21} = \\begin{pmatrix}\n1 & 0 & 0 \\\\\n2 & 1 & 0 \\\\\n0 & 0 & 1\n\\end{pmatrix}, \\quad\nE_{31} = \\begin{pmatrix}\n1 & 0 & 0 \\\\\n0 & 1 & 0 \\\\\n-4 & 0 & 1\n\\end{pmatrix}, \\quad\nE_{32} = \\begin{pmatrix}\n1 & 0 & 0 \\\\\n0 & 1 & 0 \\\\\n0 & \\frac{11}{3} & 1\n\\end{pmatrix}\n$$\n所以，矩阵A可以写做：\n$$\nA=LU=(E_{32}​E_{31}​E_{21})^{-1}U\n$$\n\n$$\nE_{32}​E_{31}​E_{21} = \\begin{pmatrix}\n1 & 0 & 0 \\\\\n2 & 1 & 0 \\\\\n\\frac{10}{3} & \\frac{11}{3} & 1\n\\end{pmatrix}\n$$\n\n因此，\n$$\nL=(E_{32}​E_{31}​E_{21})^{-1}=\\begin{pmatrix}\n1 & 0 & 0 \\\\\n-2 & 1 & 0 \\\\\n4 & -\\frac{11}{3} & 1\n\\end{pmatrix}\n$$\n原变换矩阵$E_{32}E_{31}E_{21}$会在矩阵(3,1)中引入一个无实际意义的$\\frac{10}{3}$\n\n而改写的L矩阵，其中的(2,1)(3,1)(3,2)位置对应的则刚好均是初等变换矩阵中实际变换位置处元素的相反数\n这就是**LU分解的优点：**只保留了消元过程中最关键的消元信息，同时其上/下三角矩阵形式减少了大量计算量。\n\n算法：\n\n```\nfor i = 1, . . . , n do\t\t\t\t\t//行\n\tfor k = 1, . . . , i - 1 do\t\t\t//列\n\t\ta[i][k] = a[i][k] /a[k][k]\n\t\tfor j = k + 1, . . . , n do\t\t//行更新\n\t\t\ta[i][j] −= a[i][k]a[k][j]\n\t\tend for\n\tend for\nend for\n```\n\n\n\n# 二、ILU不完全分解\n\nILU和LU的联系：都是将一个给定的方阵分解为一个下三角矩阵（L）和一个上三角矩阵（U）的乘积。\n\n区别在于ILU的分解：$A≈LU$\n\nLU分解通常用于解决精确的线性方程组，而ILU分解则是用于解决大型稀疏线性方程组。因此LU分解得到的解是精确的，而ILU分解的解是近似的\n\n## 2.1 ILU(0)\n\n![image-20240617165015419](实习学习日志/image-20240617165015419.png)\n\nILU(0) 基本上是对原始矩阵 AAA 的LU分解，但分解结果中的非零结构严格遵循原始矩阵的非零结构。具体来说：\n\n- 如果 A 是一个稀疏矩阵，ILU(0) 分解得到的 L 和 U 也是稀疏矩阵，并且其非零元素位置与 A 的非零元素位置相同。\n\n## 2.2 ILUT\n\n基于一个预定的阈值，仅保留那些绝对值大于阈值的填充值\n\n## 2.3 ILU(k)\n\n允许一定程度的填充，保留在计算过程中出现的非零元素。这里的 𝑘 表示允许的填充级别。较大的 𝑘会带来更高的精度，但也会增加计算和存储成本\n\n## 2.4 示例\n\n```cpp\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <limits.h>\n\n#define N 4\n#define K 1  // ILU(k)中的k值\n\ntypedef struct {\n    double **data;\n    int **level;  // 用于存储fill-in级别\n} Matrix;\n\nMatrix createMatrix();\nvoid printMatrix(Matrix mat);\nvoid LU(Matrix mat);\nvoid ILU0(Matrix mat);\nvoid ILUk(Matrix mat, int k);\nMatrix copyMatrix(Matrix src);\nvoid freeMatrix(Matrix mat);\n\nint main() {\n    Matrix A = createMatrix();\n    Matrix B = copyMatrix(A);\n    Matrix C = copyMatrix(A);\n\n    printf(\"原始矩阵:\\n\");\n    printMatrix(A);\n\n    LU(A);\n    ILU0(B);\n    ILUk(C, K);\n\n    // 释放矩阵内存\n    freeMatrix(A);\n    freeMatrix(B);\n    freeMatrix(C);\n\n    return 0;\n}\n\nMatrix createMatrix() {\n    Matrix mat;\n    mat.data = (double **)malloc(N * sizeof(double *));\n    mat.level = NULL;  // 初始化为NULL，只有在ILUk中才分配内存\n    for (int i = 0; i < N; ++i) {\n        mat.data[i] = (double *)malloc(N * sizeof(double));\n        for (int j = 0; j < N; ++j) {\n            mat.data[i][j] = rand() % 10 + 1;  // 1 到 10 之间的随机数\n        }\n    }\n    return mat;\n}\n\nvoid printMatrix(Matrix mat) {\n    for (int i = 0; i < N; ++i) {\n        for (int j = 0; j < N; ++j) {\n            printf(\"%.2f\\t\", mat.data[i][j]);\n        }\n        printf(\"\\n\");\n    }\n    printf(\"\\n\");\n}\n\n// LU分解函数\nvoid LU(Matrix mat) {\n    for (int i = 1; i < N; i++) {\n        for (int j = 0; j < i; j++) {\n            mat.data[i][j] /= mat.data[j][j];\n            for (int k = j + 1; k < N; k++) {\n                mat.data[i][k] -= mat.data[i][j] * mat.data[j][k];\n            }\n        }\n    }\n\n    printf(\"LU分解后的矩阵:\\n\");\n    printMatrix(mat);\n}\n\n// ILU(0)分解\nvoid ILU0(Matrix mat) {\n    for (int i = 1; i < N; i++) {\n        for (int j = 0; j < i; j++) {\n            if (mat.data[i][j] != 0) {\n                mat.data[i][j] /= mat.data[j][j];\n                for (int k = j + 1; k < N; k++) {\n                    if (mat.data[i][k] != 0 && mat.data[j][k] != 0)\n                        mat.data[i][k] -= mat.data[i][j] * mat.data[j][k];\n                }\n            }\n        }\n    }\n\n    printf(\"ILU(0)分解后的矩阵:\\n\");\n    printMatrix(mat);\n}\n\n// ILU(k)分解\nvoid ILUk(Matrix mat, int k) {\n    mat.level = (int **)malloc(N * sizeof(int *));\n    for (int i = 0; i < N; ++i) {\n        mat.level[i] = (int *)malloc(N * sizeof(int));\n        for (int j = 0; j < N; ++j) {\n            if (mat.data[i][j] != 0) {\n                mat.level[i][j] = 0;  // 初始矩阵元素级别为0\n            } else {\n                mat.level[i][j] = INT_MAX;  // 非初始元素级别为无穷大\n            }\n        }\n    }\n\n    for (int i = 1; i < N; ++i) {\n        for (int j = 0; j < i; ++j) {\n            if (mat.level[i][j] <= k) {\n                mat.data[i][j] /= mat.data[j][j];\n                for (int m = j + 1; m < N; ++m) {\n                    if (mat.level[i][m] > mat.level[i][j] + mat.level[j][m] + 1) {\n                        mat.level[i][m] = mat.level[i][j] + mat.level[j][m] + 1;\n                        if (mat.level[i][m] <= k) {\n                            mat.data[i][m] -= mat.data[i][j] * mat.data[j][m];\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    printf(\"ILU(%d)分解后的矩阵:\\n\", k);\n    printMatrix(mat);\n}\n\n// 复制矩阵函数\nMatrix copyMatrix(Matrix src) {\n    Matrix dest;\n    dest.data = (double **)malloc(N * sizeof(double *));\n    dest.level = NULL;  // 初始化为NULL，只有在ILUk中才分配内存\n    for (int i = 0; i < N; ++i) {\n        dest.data[i] = (double *)malloc(N * sizeof(double));\n        memcpy(dest.data[i], src.data[i], N * sizeof(double));\n    }\n    return dest;\n}\n\n// 释放矩阵内存\nvoid freeMatrix(Matrix mat) {\n    for (int i = 0; i < N; ++i) {\n        free(mat.data[i]);\n        if (mat.level != NULL) {\n            free(mat.level[i]);\n        }\n    }\n    free(mat.data);\n    if (mat.level != NULL) {\n        free(mat.level);\n    }\n}\n```\n\n此处的ILU(k)代码正确性未知，还没验证\n\n# 三、存储结构\n\n更多存储格式：https://en.wikipedia.org/wiki/Sparse_matrix\n\n## 3.1 CSR 压缩稀疏行格式\n\n参考链接：https://blog.csdn.net/weixin_62592231/article/details/127477739\n\n![image-20240618093507083](实习学习日志/image-20240618093507083.png)\n\n- val：存储非0元素的值\n\n- x：依次存储每行的**<u>首元素</u>**在val中的位置，最后一个代表总的非零元素的总个数\n\n- y：存储非0元素的列坐标\n\n  ```cpp\n  struct CsrMatrix {\n      int rows;//矩阵的总行数\n      int *row_off;//x数组，每行第一个元素前面的非零元素，最后一个rowoff代表总的非零元素\n      int *cols;//y数组,即每个非零元素在普通矩阵中的列标（从0开始）\n      double *data;//图中的val数组\n      int data_size;//val数组大小\n  };\n  \n  ```\n\n## 3.2 BSR\n\n**BSR**块压缩存储是**CSR**行压缩存储的升级变形\n\n![在这里插入图片描述](实习学习日志/5fb0c2a217204128a88e97478b75f3d4.png)\n\n如果采用CSR进行表示：\n\n```\nvals:1 6 7 2 1 8 2 1 4 5 1 4 3 7 2\ncols:0 2 3 0 1 2 3 2 3 2 3 2 3 4 5\nrow_off:0 3 7 9 11 14 14\n```\n\n采用BSR进行表示：\n\n```\nvals: 1 0 2 1|6 7 8 2|1 4 5 1|4 3 0 0|7 2 0 0\ncols: 0 1 | 1 | 1 2\nrow_off: 0 2 3 5\n```\n\nBSR与CSR类似，只是BSR的cols和row_off都是**以块为单位**进行定位\n\n优势显而易见，节约存储空间，CSR需要存count(vals,cols,row_off)=37个空间\n\n而BSR只需要存count(vals,cols,row_off)=29个空间\n\n```cpp\nstruct BsrMatrix {\n    int rows; // 矩阵的总行数\n    int cols; // 矩阵的总列数\n    int row_block_size; // 行方向的块大小\n    int col_block_size; // 列方向的块大小\n    int num_blocks; // 非零块的数量\n    int *row_off; // 每个块行第一个块前的非零块数量，最后一个元素代表总的非零块数量\n    int *col_indices; // 每个非零块在普通矩阵中的列标（从0开始）\n    double *data; // 存储非零块的数据，按照块行的顺序存储\n    int data_size; // 存储数据数组的大小\n};\n```\n\n## 3.3 COO\n\n三元组存储结构，行+列+数据\n\n```cpp\nstruct CooMatrix {\n    int rows;     // 矩阵的总行数\n    int cols;     // 矩阵的总列数\n    int nnz;      // 非零元素的数量\n    int *row_indices; // 非零元素所在的行索引数组\n    int *col_indices; // 非零元素所在的列索引数组\n    double *data;     // 非零元素的值数组\n};\n\n```\n\n# 四、BLAS\n\nBLAS(basic linear algebra subroutine)基本线性代数算法\n\n- level1：向量×向量\n- level2：向量×矩阵\n- level3：矩阵×矩阵\n\n## 4.1 BLAS函数命名\n\n- s：单精度（float）\n- d：双精度（double）\n- c：单精度复数（gsl_complex_float）\n- z：双精度复数（gsl_complex）\n\n```cpp\nint gls_blas_sdot(const gsl_vector_float *x,const gsl_vector_float *y, float *resuilt)//两个向量点积运算，只有单精度\n\nint gls_blas_dsdot(const gsl_vector_float *x,const gsl_vector_float *y, double *resuilt)//两个向量点积运算，向量为单精度，输出结果为双精度\n```\n\n\n\n# 五、BLASTed\n\n## 5.1 testcsrmatrix.cpp\n\n```cpp\nint testCSRMatMult(const std::string type,\nconst std::string matfile, const std::string xvec, const std::string prodvec)\n{\t//读取矩阵，此时为COO格式\n\tCOOMatrix<double,int> coom;\n\tcoom.readMatrixMarket(matfile);\n\t//读取x向量，和ans向量，ans向量用于后续验证结果\n\tconst device_vector<double> x = readDenseMatrixMarket<double>(xvec);\n\tconst device_vector<double> ans = readDenseMatrixMarket<double>(prodvec);\n\t\n\tAbstractLinearOperator<double,int>* testmat = nullptr;\n\tif(type == \"view\") {\n\t\ttestmat = new CSRMatrixView<double,int>(move_to_const<double,int>(getSRMatrixFromCOO<double,int,1>(coom, \"\")));\n\t}\n\telse\n\t\ttestmat = new BSRMatrix<double,int,1>(getSRMatrixFromCOO<double,int,1>(coom, \"\"));\n\n\tdevice_vector<double> y(testmat->dim());//dim获取矩阵的行数，创建y向量(b)\n\ttestmat->apply(x.data(), y.data());//进行计算Ax = b\n\n\tfor(int i = 0; i < testmat->dim(); i++) {\n\t\tassert(std::fabs(y[i]-ans[i]) < 10*DBL_EPSILON);//结果验证\n\t}\n\tdelete testmat;\n\treturn 0;\n}\n```\n\napply函数跳转：blockmatrices.ipp->matvecs.cpp\n\n```cpp\ntemplate <typename scalar, typename index>\nvoid CSRMatrixView<scalar,index>::apply(const scalar *const xx,\n                                        scalar *const __restrict yy) const\n{\n\tBLAS_CSR<const scalar,const index>::matrix_apply(std::forward<const MatrixWrapper>(mat), xx, yy);\n}\n```\n\n```cpp\ntemplate <typename mscalar, typename mindex>\nvoid BLAS_CSR<mscalar,mindex>::matrix_apply(const SRMatrixStorage<mscalar,mindex>&& mat,\n                                            const scalar *const xx, scalar *const __restrict yy) \n{\n#pragma omp parallel for default(shared)\n\tfor(index irow = 0; irow < mat.nbrows; irow++)\n\t{\n\t\tyy[irow] = 0;\n\n\t\tfor(index jj = mat.browptr[irow]; jj < mat.browptr[irow+1]; jj++)\n\t\t{\n\t\t\tyy[irow] += mat.vals[jj] * xx[mat.bcolind[jj]];\n\t\t}\n\t}\n}\n```\n\n"},{"title":"Linux驱动开发题目","url":"/2024/06/12/Linux驱动开发题目/","content":"\n相关链接：https://www.cnblogs.com/lxq-247A3/p/16337398.html\n\n# 1.字符设备和块设备\n\n**字符设备：**能够像**字节流**一样被访问的设备，驱动程序至少实现open,close,read和write系统调用。字符终端、串口、鼠 标、键盘、摄像头、声卡和显卡等。\n\n**块设备：**可以存取任意字节数，能够容纳文件系统。如：u盘，SD卡，磁盘等。\n\n**网络设备：**可以是一个硬件设备，或者是软件设备，没有相应的read write，**面向流**的一种特殊设备。\n\n**相同点：**都是通过/dev目录下的文件系统节点来访问。\n\n\n\n系统调用：read、open、close、write，注意fopen\\fread为标准IO不是系统调用\n\n# 2.驱动加载\n\n**静态加载：**把驱动直接编译到内核中，这种加载方式比较麻烦，特别是我们需要修改驱动的时候，就需要每次都编译内核，编译内核是比较费时间的\n\n**动态加载：**使用insmod命令添加模块（.ko），在不需要的时候用rmmod命令卸载模块，采用这种动态加载的方式便于驱动程序的调试，同时可以针对产品的功能需求，进行内核的裁剪，将不需要的驱动去除，大大减小了内核的存储容量。\n\n# 3.查看模块相关信息\n\n1. 查看驱动模块中打印信息的命令：dmesg\n\n2. 查看字符设备信息可以用lsmod 和modprobe\n\n   - lsmod可以查看模块的依赖关系\n\n   - modprobe在加载模块时会加载其他依赖的模块\n\n3. 显示当前使用的中断号cat /proc/interrupt\n\n# 4.主设备号和次设备号\n\n创建chartest设备：`mknod chartest c 4 64`\n\n**主设备号：**标识设备对应的驱动程序，Linux中为12位\n\n**次设备号：**通过次设备号获得一个指向内核设备的直接指针，也可将此设备号当作设备本地数组的索引。占20位\n\nchartest 由驱动程序4管理，该文件所指的设备是64号设备\n\n# 5.内核和用户空间之间的拷贝\n\n**copy_to_user()：**完成内核空间到用户空间的复制\n\n**copy_from_user()：**完成用户空间到内核空间的复制\n\n一般用于file_operations（文件操作结构体）里的`read`,`write`,`ioctl`等内存数据交换作用的函数。如果`ioctl`没有用到内存数据复制，那么就不会用到这两个函数。\n\n# 6.引入模块机制的好处\n\n该机制有助于缩短模块的开发周期。即:注册和卸载都很灵活方便。\n\n# 7.字符设备基本框架\n\n## 7.1 模块加载\n\n~~~cpp\n\n\n```cpp\n#include <linux/init.h>\n#include <linux/module.h>\n\n/* 驱动入口函数 */\nstatic int __init xxx_init(void)\n{\n    /* 入口函数具体内容 */\n    return 0;\n}\n/* 驱动出口函数 */\nstatic void __exit xxx_exit(void)\n{\n    /* 出口函数具体内容 */\n}\n/* 将上面两个函数指定为驱动的入口和出口函数 */\nmodule_init(xxx_init);\nmodule_exit(xxx_exit)\nMODULE_LICENSE(\"GPL\");//模块GPL许可声明\nMODULE_AUTHOR(\"VICCZYQ\");//模块作者等信息\n```\n\n```shell\nsudo insmod hello.ko//加载模块\nsudo rmmod hello//卸载模块\n```\n\n**注意在init函数中申请的资源在exit函数中要释放**\n~~~\n\n对于字符设备驱动而言，当驱动模块加载成功以后需要注册字符设备。卸载驱动模块的时也需要注销掉字符设备。\n\n## 7.2 注册字符设备驱动\n\n对于字符设备驱动而言，当驱动模块加载成功以后需要注册字符设备。卸载驱动模块的时也需要注销掉字符设备。一般**字符设备的注册**在**驱动模块的入口函数 xxx_init** 中进行，**字符设备的注销**在**驱动模块的出口函数 xxx_exit** 中进行。\n\n```cpp\nstatic inline int register_chrdev(unsigned int major, \n\t\t\t\t\t\t\t\t\tconst char *name,\n\t\t\t\t\t\t\t\t\tconst struct file_operations *fops)\n \nstatic inline void unregister_chrdev(unsigned int major, \n\t\t\t\t\t\t\t\t\tconst char *name)\n\n```\n\n## 7.3 内存映射\n\n在Linux中不能直接访问寄存器，要想要操作寄存器需要完成物理地址到虚拟空间的映射。物理内存和虚拟内存之间的转换，需要用到： ioremap 和 iounmap两个函数\n\n```cpp\n#define addr (0X020E0068)  // 物理地址\nstatic void __iomem*  va; //指向映射后的虚拟空间首地址的指针\nva=ioremap(addr, 4);   // 得到虚拟地址首地址\n```\n\n注意卸载时候要用iounmap\n\n```cpp\niounmap(va);\n```\n\n## 7.4 数据传递\n\n```cpp\nstatic inline long copy_from_user(void *to, const void __user * from, unsigned long n)\nstatic inline long copy_to_user(void __user *to, const void *from, unsigned long n)\n//to:目标地址\n//from:源地址\n//n:拷贝的字节数\n```\n\n## 7.5 字符设备最基本框架\n\n```cpp\n#define CHRDEVBASE_MAJOR 200\t\t\t//手动设置主设备号\n#define CHRDEVBASE_NAME  \"chrdevbase\"\t//设备名称\n//内核缓存区\nstatic char readbuf[100];\t\t\t\t\t\t//读数据缓存\nstatic char writebuf[100];\t\t\t\t\t\t//写数据缓存\nstatic char kerneldata[] = {\"kernel data!\"};\t//测试数据\n//硬件寄存器\n#define GPIO_TEST_BASE (0x01234567) \t//宏定义寄存器映射地址\nstatic void __iomem *GPIO_TEST;\t\t\t// __iomem 类型的指针，指向映射后的虚拟空间首地址\n//打开设备\nstatic int chrdevbase_open(struct inode *inode, struct file *filp) \n{\n\treturn 0;\n}\n// 从设备读取数据 \nstatic ssize_t chrdevbase_read(struct file *filp , char __user *buf , size_t cnt , loff_t *offt) \n{\n\tint retvalue = 0;\n\tunsigned char databuf[1];\n// 读取硬件寄存器\n#if 0  \n\t//读取寄存器状态\n\tdatabuf[0] = readl(GPIO_TEST);\n\tretvalue = copy_to_user(buf , databuf, cnt);\n//读取内核内存\n#else\t\n\t//测试数据拷贝到读数据缓存中\n    memcpy(readbuf , kerneldata , sizeof(kerneldata));  \n    //内核中数据（读缓存）拷贝到用户空间\n    retvalue = copy_to_user(buf , readbuf , cnt);\n#endif\n\n    if(retvalue == 0) printk(\"kernel senddate ok!\\n\");   \n  \telse printk(\"kernel senddate failed!\\n\");\n    return 0;\n}\n//向设备写数据 \nstatic ssize_t chrdevbase_write(struct file *filp, const char __user *buf, size_t cnt , loff_t *offt) \n{\n\tint retvalue = 0;\n//写硬件寄存器\n#if 0\n\twritel(buf[0],GPIO_TEST);\n//写内核缓存\n#else\n\t//用户数据拷贝到内核空间（写缓存）\n    retvalue = copy_from_user(writebuf , buf ,cnt);\n#endif\n    if(retvalue == 0) printk(\"kernel recevdate : %s\\n\",writebuf);\n  \telse printk(\"kernel recevdate failed!\");\n    return 0;\n}\n//关闭/释放设备\nstatic int chrdevbase_release(struct inode *inode , struct file *filp) \n{\n\treturn 0;\n}\n//设备操作函数\nstatic struct file_operations chrdevbase_fops = {\n    .owner = THIS_MODULE,\n    .open = chrdevbase_open,\n    .read = chrdevbase_read,\n    .write = chrdevbase_write,\n    .release = chrdevbase_release,\n};\n/* 驱动入口函数 */\nstatic int __init chrdevbase_init(void)\n{\n\tint retvalue = 0;\n\t//寄存器物理映射，物理地址映射到虚拟地址指针\n\tGPIO_TEST= ioremap(GPIO_TEST_BASE, 4);\n\t//注册字符设备驱动\n    retvalue = register_chrdev(CHRDEVBASE_MAJOR, \t//主设备号\n    \t\t\t\t\t\t\tCHRDEVBASE_NAME, \t//设备名称\n    \t\t\t\t\t\t\t&chrdevbase_fops);\t//设备操作函数集合\n    \t\t\t\t\t\t\t\n    if(retvalue < 0) printk(\"chrdevbase driver register failed\\n\");\n    printk(\"chrdevbase_init()\\r\\n\");\n    return 0;\n}\n/* 驱动出口函数 */\nstatic void __exit chrdevbase_exit(void)\n{\n\t//解除寄存器映射\n\tiounmap(GPIO_TEST);\n\t//注消字符设备驱动\n\tunregister_chrdev(CHRDEVBASE_MAJOR ,  \t//主设备号\n\t\t\t\t\t\tCHRDEVBASE_NAME);\t//设备名称\n    printk(\"chrdevbase_exit()\\r\\n\");\n}\n/* 将上面两个函数指定为驱动的入口和出口函数 */\nmodule_init(chrdevbase_init);\nmodule_exit(chrdevbase_exit);\n\nMODULE_LICENSE(\"GPI\");//GPL模块许可证\nMODULE_AUTHOR(\"songwei\");//作者信息\n\n```\n\n## 7.6 创建驱动节点文件\n\n```bash\nmknod /dev/chrdevbase c 200 0\n```\n\n创建完成以后就会存在/dev/chrdevbase 这个文件，可以使用“ls /dev/chrdevbase -l”命令查看\n\n# 8.DMA和中断\n\n**DMA：**一种无须CPU的参与就可以让**外设**与**系统内存**之间进行数据传输的硬件机制\n\n**中断：**是指CPU在执行程序的过程中，出现了某些突发事件时CPU必须暂停执行当前的程序，转去处理突发事件，处理完毕后CPU又返回源程序被中断的位置并继续执行。\n\n中断和DMA的区别就是<u>DMA不需CPU</u>参与而中断是需要CPU参与的。\n\n# 9.驱动的Makefile框架\n\n```makefile\nBASE_KERNEL ?= 内核的源码目录\nobj-m += 驱动源文件名.o\nall:\n    make -C $(BASE_KERNEL) M=$(PWD) modules\nclean:\n    make -C $(BASE_KERNEL) M=$(PWD) clean\n```\n\n eg.驱动源文件为abc.c和hello.c\n\n```makefile\n# 若是虚拟机自身内核，可以定义变量为: /lib/modules/$(shell uname -r)/build\n# 定义内核源码根目录\nBASE_KERNEL ?= /lib/modules/$(shell uname -r)/build\n\n# 定义目标名\nTARGET := hello\n\n# 将多个对象文件合并到同一行\nobj-m := abc.o hello.o\n\nall:\n    make -C $(BASE_KERNEL) M=$(PWD) modules\n\nclean:\n    make -C $(BASE_KERNEL) M=$(PWD) clean\n```\n\n# 10 启动过程\n\n## 10.1 U-boot 启动流程\n\n**第一阶段：**\n\n- 硬件设备初始化\n- 将第二阶段的代码加载到RAM\n- 设置好栈空间\n- 跳转到第二阶段代码入口处\n\n**第二阶段：**\n\n- 初始化本阶段的硬件设备\n- 将Linux内核从Flash读入RAM\n- 为Linux内核设置启动参数\n- 调用Linux内核\n\n## 10.2 Linux系统启动过程\n\n1. 内核引导\n2. 运行初始化，init\n3. 系统初始化\n4. 建立终端\n5. 用户登录系统\n\n"},{"title":"高性能计算学习导航","url":"/2024/05/26/高性能计算学习总帖/","content":"\n**高性能程序** = 数据结构 + 算法 + **体系结构**\n\n优化效果 = 深入思考 + 敢于尝试 + **时间累积**\n\n# 学习资源\n\n- [intel Intrinsics Guide (opens new window)](https://software.intel.com/sites/landingpage/IntrinsicsGuide/#cats=Arithmetic&expand=3904,3913,4011,4014,4602,4011&techs=MMX,SSE,SSE2,SSE3,SSSE3,SSE4_1,SSE4_2,AVX,AVX2,FMA,AVX_512,AMX,SVML,Other)\n- OpenMP 和 MPI ：《[并行程序设计导论](https://kaywu-images.oss-cn-beijing.aliyuncs.com/book/code/%E5%B9%B6%E8%A1%8C%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E5%AF%BC%E8%AE%BA.pdf)》\n- [现代微处理器架构 90分钟指南](https://www.starduster.me/2020/11/05/modern-microprocessors-a-90-minute-guide/)\n- [高性能计算学习路线](https://heptagonhust.github.io/HPC-roadmap/)\n- [shell 脚本学习-bilibili](https://www.bilibili.com/video/BV14L4y157Bv/)\n- [快速入门：Slurm资源管理与作业调度系统](https://zhuanlan.zhihu.com/p/571973164)\n- [CMake和Makefile](https://vicczyq.github.io/2024/03/06/Makefile%E5%92%8CCMake/)\n\n# 一、基础知识\n\n## 1.1 并行计算\n\n**并行计算**是指在计算过程中同时执行多个任务或操作，以提高计算效率的技术。与传统的串行计算相比，它能够利用多个处理单元或计算资源同时进行计算，从而更快地完成任务。\n\n### 1.1.1 分类：\n\n- **指令级并行：**CPU流水线\n- **分布式并行：**MPI\n- **共享存储式并行：**OpenMP、OpenACC、OpenCL\n\n### 1.1.3 并行和并发的区别\n\n**并行：**在**同一时刻真正地并行处理多个任务**，依赖于多处理器或多核心系统\n\n**并发**：是指多个任务在同一时间段内**交替执行**，但不一定是同时执行的。\n\n### 1.1.3 异构并行的概念\n\n计算任务中使用具有不同架构的多种计算资源（例如CPU、GPU、神威主从核等）进行并行计算。\n\n![image-20240523203637666](高性能计算学习总帖/image-20240523203637666.png)\n\n## 1.2 进程和线程\n\n**进程：**<u>资源分配的最小单位</u>。是并发执行的程序在执行过程中分配和管理资源的基本单位，是一个动态概念，竞争计算机系统资源的基本单位。（资源分配）\n**线程：**<u>CPU调度的最小单位</u>。是进程的一个执行单元，是进程内可调度实体。比进程更小的独立运行的基本单位。线程也被称为轻量级进程。（执行体）\n\n- 一个程序至少有一个进程，一个进程至少有一个线程\n- 线程的划分尺度小于进程，使得多线程程序的并发性高\n- 进程在执行过程中有独立的内存单元，而多线程之间是共享内存\n\n**OpenMP**\n\n1. 并行粒度：线程级\n2. 数据分配方式：隐式（系统或编译器自动处理数据分配和管理）\n3. 共享存储，可扩展性差\n\n\n**MPI**\n\n1. 并行粒度：进程级\n2. 数据分配方式：显式（由程序员自主分配）\n3. 分布式存储，可扩展性好\n\n\n\n## 1.3 CPU内部架构\n\n### 1.3.1 指令流水线（pipeline）\n\n以经典的5级流水线为例，一条指令的执行被分为5个阶段：\n\n- 取指（IF）：从内存中取出一条指令\n- 译码（ID）：对指令进行解码，确定指令要执行的操作\n- 执行（EX）：执行指令操作\n- 访存（MEM）：内存访问操作\n- 写回（WB）：执行结果写回寄存器或内存\n\n![img](高性能计算学习总帖/2efd9ec72267748ff315f95e4959d13a.png)\n\n在CPU内部，执行每个阶段使用的是不同的硬件资源，从而可以让多条指令的执行时间相互重叠。\n\n![img](高性能计算学习总帖/d7e26bf2bf7f955559e36abee7a66c59.png)\n\n有了流水线技术，理想情况下，每个时钟周期，CPU可以完成一条指令的执行。那有没有什么方法，可以让CPU在每个时钟周期，完成多条指令的执行呢，这岂不是会大大提高CPU整体性能吗？这就是Superscalar技术！（还有VLIW技术）\n\n### 1.3.2 超标量（Superscalar）\n\n通过在CPU内部实现多条指令流水线，可以真正实现多条命令并行执行，也被称为**多发射数据通路技术**\n\n![img](高性能计算学习总帖/438dfd2c0f9f9b798b403063f5858f88.png)\n\n### 1.3.3 流水线冲突\n\n在理想情况下，上述设计十分完美，但是现实中程序的指令序列之间往往存在各种各样的**依赖和相关性**，而CPU为了解决这种指令间的依赖和相关性，有时候不得不“**停顿**”下来，直到这些依赖得到解决，这就导致CPU指令流水线无法总是保持“全速运行”。\n\n#### （1）数据冲突\n\n两条在流水线中并行执行的指令，**第二条指令需要用到第一条指令的执行结果**，因此第二条指令的执行不得不暂停，一直到可以获取到第一条指令的执行结果为止。\n\n```cpp\nx = 某些计算;\ny = x;\n```\n\n#### （2）控制冲突\n\nCPU在执行**分支跳转时，无法预知下一条要执行的指令。**\n\n```cpp\nif(a > 100) {\n    x = 1;\n} else {\n    y = 2;\n}\n```\n\n#### （3）结构冲突\n\n**多条指令同时竞争同一个硬件资源**，由于硬件资源短缺，无法同时满足所有指令的执行请求。如两条并行执行的命令需要同时访问内存，而内存地址译码单元可能只有一个，这就产生了结构冲突。\n\n## 1.4 高性能数学算法库\n\n基本概念：计算领域的基础软件库，是发挥硬件算力的基石，提高效率\n\n![image-20240523180934242](高性能计算学习总帖/image-20240523180934242.png)\n\n主流的硬件厂商都会为自身硬件提供优化了的算法库\n\n- **Intel** MKL\n- **IBM** ESSL/PESSL\n- **AMD** AOCL\n- **Nvidia** CUDA-X\n\n### 1.4.1 BLAS/LAPACK\n\n**BLAS：**基础线性代数子程序，是一系列初级操作的规范，如向量之间的乘法，矩阵乘法等\n\n**LAPACK：**线性代数库，底层是BLAS，在此基础上定义了很多矩阵和高级运算函数，如矩阵分解、求逆等，运算效率比BLAS高\n\n### 1.4.2 PETSc\n\n底层为BLAS/LAPACK，用于高性能求解偏微积分方程组相关问题，目前PETSc所有消息传递均采用MPI实现。\n\n支持Fortran 77/90、C/C++编写的串行和并行代码\n\n## 1.5 计算机架构\n\n划分计算机架构的方法有很多，广泛使用的为佛林分类法（Flynn’s Taxonomy）\n\n### 1.5.1 佛林分类法（Flynn’s Taxonomy）\n\n根据指令和数据进入CPU的方法进行分类\n\n- 单指令单数据SISD（传统串行计算机，386）\n- 单指令多数据SIMD（并行架构，比如向量机，所有核心指令唯一，但是数据不同，现在CPU基本都有这类的向量指令）\n- 多指令单数据MISD（少见，多个指令围殴一个数据）\n- 多指令多数据MIMD（并行架构，多核心，多指令，异步处理多个数据流，从而实现空间上的并行，MIMD多数情况下包含SIMD，就是MIMD有很多计算核，计算核支持SIMD）\n\n### 1.5.2 根据内存划分\n\n#### 1.5.2.1 分布式内存的多节点系统\n\n通常把这种成为集群，节点有独立的硬件，节点与节点之间通过网络进行交互（MPI的作用）\n\n![image-20240809163234017](高性能计算学习总帖/image-20240809163234017.png)\n\n#### 1.5.2.2 共享内存的多处理器系统\n\n单个主板上面有多个处理器，他们共享主板上面的内存，通过PCIe和内存进行交互\n\n![img](高性能计算学习总帖/6.png)\n\n上面讲到的”多个处理器“可以分为 多片处理器 和 单片多核（众核），也就是说有些主板上安装了许多片处理器，也有的是一个主板上就一个处理器，但是这个处理器里面有几百个核。\n\nGPU就属于众核系统。当然现在CPU也都是多核的了，但是他们还是有很大区别的：\n\n- CPU适合执行复杂的逻辑，比如多分支，其核心比较重（复杂）\n- GPU适合执行简单的逻辑，大量的数据计算，其吞吐量更高，但是核心比较轻（结构简单）\n\n# 二、入门篇\n\nPS：在这之前最好学好C++的相关知识\n\n## 2.1 Pthread\n\n![image-20240521112131105](高性能计算学习总帖/image-20240521112131105.png)\n\npthread是许多并行模型的底层实现\n\n**具体内容：**https://vicczyq.github.io/2024/05/21/Pthread\n\n## 2.2 OpenMP\n\n以Pthread为基础开发的，面向多线程并行编程模型，极大简化了多线程编码，支持Fortran、C/C++\n\n详细内容：[https://vicczyq.github.io/2022/02/05/OpenMP学习](https://vicczyq.github.io/2022/02/05/OpenMP学习)\n\n# 三、基础篇\n\n## 3.1 MPI\n\n详细内容：[https://vicczyq.github.io/2022/02/05/MPI%E5%AD%A6%E4%B9%A0/](https://vicczyq.github.io/2022/02/05/MPI%E5%AD%A6%E4%B9%A0/)\n\n## 3.2 CUDA\n\n（内容不是很完善，待更......）\n\n详细内容：[https://vicczyq.github.io/2022/02/05/CUDA%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/](https://vicczyq.github.io/2022/02/05/CUDA%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/)\n\n## 3.3 性能分析\n\n### 3.3.1 静态分析工具\n\n利用代码静态分析，对代码进行数据对象、函数接口封装和调用分析\n\n主流的工具：**Understand**、SourceInsight、DeepScan、deepsource、VERACODE\n\n以Understand为例：[https://blog.csdn.net/qq_40513792/article/details/111991978](https://blog.csdn.net/qq_40513792/article/details/111991978)\n\n### 3.3.2 动态分析工具\n\n实际运行过程中调用了哪些函数。\n\n主流的工具：gprof、intel vtune profiler、Perf等\n\n#### Perf\n\n使用教程：[Amicoyuan-perf-系统级性能分析工具](https://xingyuanjie.top/2022/01/19/tool003/)\n\n#### gprof（GNU profile）\n\n**注意：**<u>不适用于多线程程序，只会记录主线程。</u>\n\n用gcc、g++等编译程序时，使用-pg参数，编译器会在原代码中插入用于性能测试的代码片断\n\n如：`g++ -pg -o test test.cpp`\n\n执行编译后的可执行程序，如：`./test`\n\n程序运行结束后，会在程序所在路径下生成一个缺省文件名为gmon.out的文件\n\n最后使用`gprof test gmon.out > output.txt`即可\n\n![image-20240523190516990](高性能计算学习总帖/image-20240523190516990.png)\n\n#### intel vtune profiler\n\n针对于英特尔处理器。\n\n## 3.4 SIMD\n\nAVX：Advanced Vector Extension 高级向量扩展\n\nAVX是SIMD（单指令多数据）指令，可以用一条指令产生多个并行操作。\n\n**寄存器位宽：**\n\n- SSE：128bit\n- AVX/AVX2：256bit\n- AVX512：512bit\n\n因为AVX/AVX2都支持256bit，所以可以统称为AVX256\n\n更多内容见：[https://blog.csdn.net/qq_17075011/article/details/130555559](https://blog.csdn.net/qq_17075011/article/details/130555559)\n\n# 四、其他常用优化手段\n\n## 4.1 常用循环优化技术\n\n### **（1）输入值嵌入**\n\n将运行时需要从文件读入的关键数据转换为编译时的静态可知数据\n\n例子如下：\n\n```c++\n#include <stdio.h>\nint main() {\n    FILE *file;\n    int value;\n    file = fopen(\"data.txt\", \"r\");\n    if (file == NULL) {\n        perror(\"Error opening file\");\n        return 1;\n    }\n    if (fscanf(file, \"%d\", &value) != 1) {\n        perror(\"Error reading integer from file\");\n        fclose(file);\n        return 1;\n    }\n    fclose(file);\n    printf(\"Read value: %d\\n\", value);\n    return 0;\n}\n```\n\n如果我已经知道需要读入的数据value的值为0，就可以直接采用宏定义或者静态变量的方法，不需要去读入\n\n```cpp\n#define value 3\n```\n\n### **（2）分支消除**\n\n消除循环中的分支，减少分支判断和跳转\n\n也可以用补码/位运算\n\n例如：\n\n```cpp\nfor(int i = 0; i < 100; i++){\n\tif(i<30){ //执行A操作 }\n\telse{ //执行B操作 }\n}\n```\n\n修改为：\n\n```cpp\nfor(int i = 0; i < 30; i++){\n//执行A操作\n}\nfor(int j = 30; j < 100; j++){\n//执行B操作\n}\n```\n\n### **（3）循环合并**\n\n每次循环需要对循环条件进行判断（i<N?）循环合并可以减少判断次数。\n\n如果A，B操作数据有关联，甚至可以减少IO\n\n```cpp\nfor(int i = 0; i < N; i++){\n\t//执行A操作\n}\nfor(int j = 0; j < N; j++){\n\t//执行B操作\n}\n```\n\n修改为\n\n```cpp\nfor(int i = 0; i < N; i++){\n\t//执行A操作\n\t//执行B操作\n}\n```\n\n### **（4）次序交换**\n\nC/C++存储是按**行优先**存储，Fortran是**列优先**存储\n\n在对数据进行访问时，最好按照顺序进行访问。\n\n原理是最大化利用高速缓存Cache\n\n```cpp\nfor(int i = 0; i < N; i++){\n\tfor(int j = 0; j < N; j++){\n\t\tcout << array[j][i]; //列优先顺序访问\n        cout << array[i][j]; //行优先顺序访问\n\t}\n}\n\n```\n\n### （5）循环分块\n\n目的是**提高Cache的命中率**，\n\n一个`Cache line`被使用过之后，后面可能还会使用，但是默认循环的方式，到下次要使用的时候`Cache line`已经被替换。\n\n于是我们就把循环重新排一下，使得一个`Cache line`在被替换之前就能被再次使用\n\n**例：**\n\n```cpp\nfor(i = 0; i < N; i++){\n\tfor(j = 0; j < M; j++){\n\t\tA[i] = A[i] + B[j];\n\t}\n}\n```\n\n如果当前`Cache Line`的大小为 **b** ，A的cache miss次数就为`N/b`，B的cache miss次数为`N*M/b`\n\n![image-20240523163713301](高性能计算学习总帖/image-20240523163713301.png)\n\n因此就可以划分块，令块大小为**T**（一般是b的整数倍，也要足够小）\n\n```cpp\nfor(jj = 0; jj < M; jj += T){\n\tfor(i = 0; i < N; i++){\n\t\tfor(j = 0; j < jj+T; j++){\n\t\t\tA[i] = A[i] + B[j];\n\t\t}\n\t}\n}\n```\n\n### （6）循环展开\n\n循环条件判断次数减少，更大的代码块有更多优化手段\n\n现在有一个代码\n\n```cpp\nint calc(int n){\n\tint fact = 1;\n\tfor(int i = 1; i < n; i++){\n\t\tfact *= i;\n\t}\n\treturn fact;\n}\n```\n\n对代码进行循环展开，假设n是4的倍数（如果不是4的倍数要边界处理）\n\n```cpp\n//test_1\nint calc(int n){\n\tint fact0 = 1, fact1 = 1, fact2 = 1, fact3 = 1;\n\tfor(int i = 1; i < n; i+=4){\n\t\tfact0 *= i;\n        fact1 *= i+1;\n        fact2 *= i+2;\n        fact3 *= i+3;\n\t}\n\treturn fact0 * fact1 * fact2 * fact3;\n}\n```\n\n```cpp\n//test_2\nint calc(int n){\n\tint fact = 1;\n\tfor(int i = 1; i < n; i+=4){\n\t\tfact *= i;\n        fact *= i+1;\n        fact *= i+2;\n        fact *= i+3;\n\t}\n\treturn fact;\n}\n```\n\ntest_2和test_1都属于循环展开，但是test_1效果更好\n\n**内容前提补充：**[流水线](#1.3 CPU内部架构)，见 1.3\n\ntest_1是这样展开的\n\n```cpp\nfact0 *= i;\nfact1 *= i+1;\nfact2 *= i+2;\nfact3 *= i+3;\n```\n\ntest_2是这样展开的\n\n```cpp\nfact *= i;\nfact *= i+1;\nfact *= i+2;\nfact *= i+3;\n```\n\n很明显，test_2的后一条指令执行前，必须知道前一条指令的计算结果，这也就是**数据依赖**，造成流水线冲突。\n\n虽然通过循环展开，减少了无用指令，也减少了热点路径上分支跳转引起的流水线控制冲突，但它同时引入了数据依赖，进而导致流水线冲突，仍然无法发挥流水线和superscalar的指令级并行执行的能力！\n\n#### 补充：优化热点路径内存访问\n\n定义局部变量时加上`register`关键字即可，\n\n作用是建议编译器尽可能把变量放在寄存器中，以求更快的访问速度\n\n```cpp\nint calc(int n){\n\tregister int fact0 = 1, fact1 = 1, fact2 = 1, fact3 = 1;\n\tfor(register int i = 1; i < n; i+=4){\n\t\tfact0 *= i;\n        fact1 *= i+1;\n        fact2 *= i+2;\n        fact3 *= i+3;\n\t}\n\treturn fact0 * fact1 * fact2 * fact3;\n}\n```\n\n## 4.2 cache优化\n\n### 4.2.1 指令cache优化\n\n将需要多次调用的函数设置为内联函数`inline`，减少函数调用开销\n\n `inline` 关键字可以建议编译器在调用该函数的地方直接插入函数代码，而不是执行正常的函数调用。\n\n```cpp\ninline int add(int a, int b) {\n    return a + b;\n}\n\nint main() {\n    int result = add(3, 4);  // 此处展开为 int result = 3 + 4;\n}\n```\n\n### 4.2.2 数据cache优化\n\n**数据预取：**在本次计算中，预取下一次需要的数据。\n\n```cpp\n//使用GCC内置函数实现\nvoid __builtin_prefetch(const void *addr, int rw, int locality);\n//addr：指向预取数据的地址。\n//rw：预取的意图，0 表示预取用于读取（默认），1 表示预取用于写入。\n//locality：数据的局部性提示，范围是 0 到 3，数值越高表示数据将被频繁访问，因此应尽量保持在缓存中。\n```\n\n**数据重排：**把数据重新排列（行优先或列优先），使其对Cache访问更为友好，减少Cache miss\n\n## 4.3 逻辑优化\n\n选择合适编译级别（O0\\O1\\O2\\O3\\Ofast）\n\n使用register关键字，将常访问变量放入寄存器\n\n使用快速数学计算（-ffast-math）等\n","tags":["超算"]},{"title":"Pthread","url":"/2024/05/21/Pthread/","content":"\npthread是许多并行模型(OpenMP)的底层实现\n\n# pthread_once\n\n线程的一次性初始化\n\n```\npthread_once(pthread_once_t *once_control, void(*init_routime)(void))\n```\n\n- once_control：控制变量\n- init_routime：初始化函数\n\n将控制变量（once_control）设置为`PTHREAD_ONCE_INIT`即可保证在多线程编程环境中，尽管pthread_once函数会出现在多个线程中，函数也仅执行一次，究竟在哪个线程中执行由内核调度决定\n\n# pthread_create\n\n```c\n#include <pthread.h>\npthread_create(thread, attr, start_routine, arg);\n```\n\n- thread：指向线程标识符\n- 用于设置线程属性，默认也可以使用NULL\n- 线程函数地址\n- 运行函数所需要参数，可以为NULL\n\n若创建成功，函数会返回0，若不为0则线程创建失败。\n\n# 线程终止函数\n\n## `int pthread_detach(pthread_t tid);`\n\n**功能**：\n\n- 将线程标记为分离状态。\n\n**详细描述**：\n\n- 使得线程在终止时自动释放其资源，而不需要调用`pthread_join`来等待它的结束。\n- 分离线程后，不能再对该线程调用`pthread_join`。\n\n**返回值**：\n\n- 成功时返回`0`。\n- 失败时返回一个错误码。\n\n**使用场景**：\n\n- 当不需要等待线程完成，也不需要获取其返回值时使用。\n\n```c\npthread_t tid;\npthread_create(&tid, NULL, thread_function, NULL);\npthread_detach(tid); // 分离线程\n```\n\n\n\n## `int pthread_cancel(pthread_t tid);`\n\n**功能**：\n\n- 请求取消一个线程。\n\n**详细描述**：\n\n- 向指定的线程发送一个取消请求。被请求的线程如果处于取消状态且到达一个取消点（例如在阻塞的系统调用中），则会响应取消请求并终止执行。\n\n**返回值**：\n\n- 成功时返回`0`。\n- 失败时返回一个错误码。\n\n**使用场景**：\n\n- 当需要强制终止一个线程时使用。线程可以设置取消状态和取消类型来控制取消行为。\n\n```c\npthread_t tid;\npthread_create(&tid, NULL, thread_function, NULL);\npthread_cancel(tid); // 请求取消线程\n```\n\n\n\n##  `int sched_yield(void);`\n\n**功能**：\n\n- 使调用线程主动让出CPU，让其他线程可以运行。\n\n**详细描述**：\n\n- 调用线程进入就绪队列尾部，调度程序将选择其他线程运行。\n- 线程调度的一部分，用于提高系统的响应性和并发性。\n\n**返回值**：\n\n- 成功时返回`0`。\n- 失败时返回一个错误码。\n\n**使用场景**：\n\n- 当一个线程执行了足够长时间或需要等待某些资源时，可以调用`sched_yield`让其他线程运行。\n\n```c\nsched_yield(); // 让出CPU，让其他线程运行\n```\n\n## `int pthread_join(pthread_t tid, void **status);`\n\n**功能**：\n\n- 等待指定线程终止，并获取其退出状态。\n\n**详细描述**：\n\n- 调用线程阻塞，直到指定线程终止。\n- 可以通过`status`参数获取被等待线程的退出状态。\n\n**返回值**：\n\n- 成功时返回`0`。\n- 失败时返回一个错误码。\n\n**使用场景**：\n\n- 当需要等待某个线程完成其任务并获取其结果时使用。\n\n```c\npthread_t tid;\npthread_create(&tid, NULL, thread_function, NULL);\nvoid *status;\npthread_join(tid, &status); // 等待线程完成并获取其退出状态\n```\n\n\n\n##  `void pthread_exit(void *status);`\n\n**功能**：\n\n- 终止调用线程，并返回一个退出状态。\n\n**详细描述**：\n\n- 终止当前线程的执行，并将`status`传递给`pthread_join`调用者。\n- 调用`pthread_exit`后，线程的资源会被释放。\n\n**返回值**：\n\n- 此函数不返回，直接终止线程。\n\n**使用场景**：\n\n- 当线程完成其任务，并希望终止并返回一个状态值时使用。\n\n```c\nvoid *thread_function(void *arg) {\n    // 线程的工作\n    pthread_exit((void *)0); // 终止线程并返回状态\n}\n```\n\n## 总结\n\n| 函数             | 功能描述                                       | 使用场景                                         |\n| ---------------- | ---------------------------------------------- | ------------------------------------------------ |\n| `pthread_detach` | 将线程标记为分离状态，使其终止时自动释放资源。 | 不需要等待线程完成，也不需要获取其返回值时使用。 |\n| `pthread_cancel` | 请求取消一个线程。                             | 需要强制终止一个线程时使用。                     |\n| `sched_yield`    | 使调用线程主动让出CPU，让其他线程可以运行。    | 当线程需要让出CPU给其他线程运行时使用。          |\n| `pthread_join`   | 等待指定线程终止，并获取其退出状态。           | 需要等待线程完成任务并获取其结果时使用。         |\n| `pthread_exit`   | 终止调用线程，并返回一个退出状态。             | 线程完成任务后，希望终止并返回一个状态值时使用。 |\n\n# 线程的标识\n\n## `pthread_t pthread_self(void)`\n\n**功能**：\n\n- 获取调用线程的线程标识符。\n\n**详细描述**：\n\n- `pthread_self`函数返回一个表示调用线程的线程标识符（ID）。\n\n**示例代码**：\n\n```c\n#include <pthread.h>\n#include <stdio.h>\n\nvoid* thread_function(void* arg) {\n    pthread_t tid = pthread_self(); // 获取当前线程ID\n    printf(\"Thread ID: %lu\\n\", (unsigned long)tid);\n    return NULL;\n}\n\nint main() {\n    pthread_t tid;\n    pthread_create(&tid, NULL, thread_function, NULL);\n    pthread_join(tid, NULL);\n    return 0;\n}\n```\n\n## `int pthread_equal(pthread_t t1, pthread_t t2)`\n\n**功能**：\n\n- 比较两个线程ID是否相等。\n\n**详细描述**：\n\n- `pthread_equal`函数用于比较两个线程ID，如果它们相等，返回非零值（通常为1）；如果它们不相等，返回0。\n- 直接使用`==`运算符比较`pthread_t`类型的线程ID在某些实现中可能**不安全或不可移植**，因此建议使用`pthread_equal`函数。\n\n**参数**：\n\n- `t1`：第一个线程ID。\n- `t2`：第二个线程ID。\n\n**返回值**：\n\n- 相等时返回非零值。\n- 不相等时返回零。\n\n**示例代码**：\n\n```c\n#include <pthread.h>\n#include <stdio.h>\n\nvoid* thread_function(void* arg) {\n    pthread_t tid = pthread_self();\n    printf(\"Thread ID: %lu\\n\", (unsigned long)tid);\n    return NULL;\n}\n\nint main() {\n    pthread_t tid1, tid2;\n    pthread_create(&tid1, NULL, thread_function, NULL);\n    pthread_create(&tid2, NULL, thread_function, NULL);\n\n    pthread_join(tid1, NULL);\n    pthread_join(tid2, NULL);\n\n    if (pthread_equal(tid1, tid2)) {\n        printf(\"Threads are equal\\n\");\n    } else {\n        printf(\"Threads are not equal\\n\");\n    }\n\n    return 0;\n}\n```\n\n# 线程的同步和互斥\n","tags":["超算"]},{"title":"信息网络安全","url":"/2024/04/30/信息网络安全/","content":"\n扩展链接：https://www.cnblogs.com/lxq-247A3/p/16320439.html\n\n# 一、概述\n\n## 1.1 基本概念\n\n**信息安全**是指信息网络中的**硬件**、**软件**及其**系统中的数据**受到保护，不受偶然的或者恶意的原因而遭到**破坏、更改、泄露、否认**等，系统连续可靠正常的运行，**信息服务**不中断。\n\n\n\n**信息安全威胁**是指某些因素（人、物、事件、方法等）对信息系统的安全使用可能构成的危害。\n\n- 硬件的安全隐患（CPU、网络设备） \n- 操作系统安全隐患\n- 网络协议的安全隐患\n- 数据库系统安全隐患（分为直接攻击和间接攻击）\n- 计算机病毒\n- 管理疏漏，内部作案\n\n计算机病毒是一种能够自我复制的程序，木马的作用是偷偷监视别人和盗取别人数据等\n\n## 1.2 攻击\n\n**攻击：**入侵行为完全完成且入侵者已进入目标网络内的行为称为攻击。\n\n但更为积极的观点是：所有可能使一个网络受到破坏的行为都称为攻击。即从一个入侵者开始在目标机上工作的那个时刻起，攻击就开始了。\n\n**信息系统的构成：**信道、网络、传输协议、主机系统、数据库系统、应用系统\n\n**攻击分类：**泄露信息、破坏信息、拒绝服务\n\n**主要手段：**口令入侵、后门软件、监听法（Sniffer）、E-mail技术、电子欺骗、Dos（Denial of Service）\n\n## 1.3 信息安全\n\n**信息安全三要素：** \n\n机密性（**C**onfidentiality）、完整性（**I**ntegrity）、可用性（**A**vailability）\n\n**CIA**三要素是网络安全的基本准则、核心准则\n\n\n\n**信息安全典型技术：**\n\n- 信息加密技术\n- 防火墙技术\n- 漏洞扫描技术\n- 入侵检测技术\n- 防病毒技术\n- 网络安全隧道技术（VPN）\n\n\n\n# 二、信息加密技术\n\n**密码学**是信息安全的核心和关键技术\n\n## 2.1 古典密码学案例\n\n藏头诗、回环诗、网格密码、凯撒（Caesar）密码\n\n## **2.2 代换密码**\n\n就是将明文中的一个字母由其它字母、数字或者符号替代的一种方法。\n\n**常见的代换密码**\n\n- 单表代换密码（Caesar密码）\n- 多表代换密码\n\n**缺点：**\n\n1. 密码量小，不能抵抗穷尽搜索攻击\n2. 明文固定代换，不能抵抗频率分析攻击\n\n## 2.3 密码学基本概念\n\n研究**信息系统安全**保密的科学，包含两个分支\n\n- 密码编码学\n- 密码分析学\n\n一个**密码（加密）系统**是由**明文(M)、密文(C)、加密算法(E)、解密算法(D)、密钥(K)**五个部分组成\n\n![image-20240501121927416](信息网络安全/image-20240501121927416.png)\n\n**按保密程度换分：**\n\n- 理论上保密的密码：不管有多少密文和算例，对明文始终得不到唯一解\n- 实际上保密的密码：理论上可破\n- 不保密的密码：获取一定量密文后可得到解\n\n**按编制原理划分：**\n\n- 代换（明文内容的表示形式改变，内容元素之间相对位置不变，明文字母用密文中对应字母代替）\n- 置换（明文内容元素的相对位置改变，内容的表示形式不变）\n- 多种组合\n\n**按密钥使用方式划分：**\n\n- 对称密码体制\n  - 加密：EK(M)=C\n  - 解密：DK(C)=M\n- 非对称密码体制（公钥密码体制）\n  - 加密：EKp(M)=C\n  - 解密：DKs(C)=M\n\n**按数据加密发展阶段分类：**\n\n- 古典密码体制：代替、置换密码\n- 对称密码：DES、AES\n- 非对称密码（公钥密码）：RSA\n\n# 三、古典密码体制\n\n**单表代换密码：**对明文消息中出现的同一个字母，在加密时使用同一个固定字母来代换，不管它出现在什么地方。\n\n**缺点：**\n\n1、密码量小，不能抵抗穷尽搜索攻击\n\n2、明文固定代换，不能抵抗频率分析的攻击\n\n**多表代换密码：**明文消息中出现的同一个字母，在加密时不是完全被同一个固定的字母代换，而是根据其出现的位置次序，用不同的字母代换。\n\n## 3.1 Vigenere（维吉尼亚）密码\n\n使用一个词组作为密钥，第一个密钥字母加密明文的第一个字母，第二个密钥字母加密明文的第二个字母，等所有密钥字母使用完后，密钥又再循环使用。\n\n| **v** | **i** | **g** | **e** | **n** | **e** | **r** | **e** |\n| ----- | ----- | ----- | ----- | ----- | ----- | ----- | ----- |\n| **k** | **e** | **y** | **k** | **e** | **y** | **k** | **e** |\n\n![image-20240501123650623](信息网络安全/image-20240501123650623.png)\n\n## 3.2 Playfair密码\n\n矩阵构造方法：从左至右、从上至下依次填入关键词的字母（若关键词中有重复字母，则第二次出现是略过）。\n\n如果没填满，然后再以字母表顺序依次填入其他字母，**字母I和J被算为同一个字符**。\n\n同时约定如下规则：表中第一列看作是第五列的右边一列，第一行看作是第五行的下一行。\n\n**加密方法如下：**  \n\n1. 若**同行**，则对应的密文分别是紧靠其右端的字母（解密反向）。\n2. 若**同列**，则对应的密文分别是紧靠其下方的字母（解密反向）。\n3. 若**不同行、不同列**，则对应的密文分别是由明文字母确定的对角线的其他两角的字母，且按其同行对应（解密方法相同)。\n4. 若两字母相同，则在重复字母之间插入一个事先约定好的字母（如:Q)。再按上述方法执行。\n5. 若明文字母数为奇数，则在末尾添加一个约定好的字母(如:Q)。\n\n![image-20240501124323285](信息网络安全/image-20240501124323285.png)\n\n## 3.3 Hill密码\n\n![image-20240501124548901](信息网络安全/image-20240501124548901-1714538750999-1.png)\n\n### **逆矩阵求法：**\n\n$$\nA*A^{-1}=E\\\\\n\\\\\nA=\n\\begin{bmatrix}A_{11} &A_{12}  &A_{13}\\\\\nA_{21} & A_{22} & A_{23}\\\\\nA_{31} & A_{32} & A_{33}\n\\end{bmatrix}\n\\\\\nA^{-1}=\n\\begin{bmatrix}a &b  &c\\\\\nd & e & f\\\\\ng & h & i\n\\end{bmatrix}\n$$\n\n待定系数法即可求出对应的逆矩阵\n\n# 四、对称密码体制\n\n如果一个密码算法的加密密钥和解密密钥相同，或由其中一个很容易推导出另一个，该算法就是对称密码算法，满足关系： M=DK (C)=DK(EK(M)) \n\n 对称密码体制的安全性主要取决于两个因素：**加密算法**和**密钥空间大小**\n\n**对称密码的优点：**\n\n  （1）加密解密处理速度快；\n\n  （2）保密度高。\n\n**对称密码的缺点：**\n\n1. 发信方必须安全、妥善地把密钥护送到收信方，代价高\n2. 多人通信需要的密钥数会出现爆炸性膨胀\n3. 通信方必须统一密钥\n4. 接收方可以伪造签名\n\n**对称密码分类：**\n\n- 序列密码算法（流密码算法）：对明文的单个位或字节进行运算\n- 分组密码算法：明文信息划分为块，对每个块进行加解密\n\n**著名的加密算法：**DES、AES、RC系列\n\n## 4.1 序列密码\n\n![image-20240501141743080](信息网络安全/image-20240501141743080.png)\n\n![image-20240501141752390](信息网络安全/image-20240501141752390.png)\n\n**分类：**\n\n- 同步序列密码\n  - 在同样的位置用同样的密钥才能保证正确地解密，一个密文位的改变只影响该位的恢复，不会对后继位产生影响。\n- 自同步序列密码\n  - 自同步序列密码的密钥的产生与密钥和已产生的固定数量的密文位有关，一个错误会影响到后面有限位的正确解密\n\n**自同步案例：**\n\n![image-20240501142352650](信息网络安全/image-20240501142352650.png)\n\n## 4.2 分组密码\n\n分组密码本质是由**密钥控制**的从明文空间到密文空间的一个**一对一**映射。\n\n加密变换的构造应遵循下列几个原则：\n\n1. 分组长度足够大。\n2. 密钥量空间足够大\n3. 加密变换足够复杂\n4. 加密和解密运算简单，易于实现\n5. 加密和解密的逻辑结构最好一致\n\n## 4.3 DES算法\n\nDES算法属于**对称加密算法**中的**分组加密算法**\n\n明文长度为64bit，密钥长度为56bit，校验位为8bit（8,16,24,32,40,48,56,64）\n\n![image-20240501143556535](信息网络安全/image-20240501143556535.png)\n\n![image-20240501163825138](信息网络安全/image-20240501163825138.png)\n\n\n\n### 4.3.1 IP置换和IP-1置换\n\n给定一个初始或结果置换表，\n\n![image-20240501150229520](信息网络安全/image-20240501150229520.png)\n\n第一个数为58意思就是把明文的第58位放在此处\n\n### 4.3.2 f轮函数\n\n#### 4.3.2.1 扩展置换（32->48）\n\n![image-20240501161304788](信息网络安全/image-20240501161304788.png)\n\n![image-20240501161323721](信息网络安全/image-20240501161323721.png)\n\n#### 4.3.2.2 与K异或\n\n64bit 的key去掉8个校验位就变成了56bit\n\n再经过密钥变化成为48bit子密钥，具体看后面子密钥生成过程\n\n#### 4.3.2.3 S盒压缩（48->32）\n\n使用8个S盒压缩处理得到32位数据，每个S盒有6个输入，4个输出\n\n处理时采用8张 4行16列的表进行压缩\n\n\n\n**数据：**111111 101100 001011 101010 101111 000001 100000 111000\n\n第一组取出，头尾数据表示行，中间数据表示列\n\n![image-20240501162959468](信息网络安全/image-20240501162959468.png)\n\n查找**压缩表**对应位置，并转换为二进制形式即为所求数据\n\nS1的3行15列为13，所以输出内容为1101\n\n![img](信息网络安全/20200309184608860.png)\n\n\n\n**例：**某组数据为101100\n\n![img](信息网络安全/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0RyaWZ0ZXJfR2FsYXh5,size_16,color_FFFFFF,t_70.png)\n\n#### 4.3.2.4 P盒置换\n\n和ip置换或ip-1置换一样，只是置换表不同\n\n![img](信息网络安全/u=3299240445,2534654427&fm=253&fmt=auto&app=138&f=JPEG.jpeg)\n\n### 4.3.3 子密钥生成过程\n\n![image-20240501170040880](信息网络安全/image-20240501170040880.png)\n\n64位的密钥通过PC-1置换表顺便去除校验位得到56位的数据\n\n经过循环左移再经过PC-2置换得到48位的单轮子密钥\n\n### 4.3.4 DES的缺点\n\n（1）密钥太短\n\n（2）DES的半公开性\n\n（3）DES迭代次数偏少，只有16轮\n\n## 4.4 AES算法\n\nAES算法属于**对称加密算法**的**分组加密算法**\n\n明文长度固定为128位，密钥长度可以是128（10轮）、192（12轮）、256位（14轮）\n\n![img](信息网络安全/d9952c306b71491da8a6ba8da52e39d1.png)\n\n以下内容均为以128位（16字节）密钥为例（明文128位，密钥128位）\n\n明文按字节划分为16个块\n\n![image-20240501225201302](信息网络安全/image-20240501225201302.png)\n\n\n\n### 4.4.1 求子密钥：密钥扩展\n\n$$\n若i是4的倍数\\\\\nW_i=W_{i-4}⊕T(W_{i-1})\\\\\n若i不是4的倍数\\\\\nW_i=W_{i-4}⊕W_{i-1}\n$$\n\n**T函数：**\n\n- 将列上元素<u>上移1位</u>\n- 字节代换（查S表）\n- 轮常量异或（查轮常量表Rcon）\n\n![image-20240501231148350](信息网络安全/image-20240501231148350.png)\n\n![image-20240501231514158](信息网络安全/image-20240501231514158.png)\n$$\n求28⊕a0\\\\\n00101000⊕10100000=10001000=0x88\n$$\n**S表如下：**![img](信息网络安全/d386e45b52a84313a349c5e8a9ebcf48.png)\n\n\n\n### 4.4.2 初始变换\n\n明文矩阵和**初始密钥**进行**异或操作**\n\n![image-20240501232058403](信息网络安全/image-20240501232058403.png)\n\n### 4.4.3 9轮循环\n\n#### 4.4.3.1 字节代换\n\n查S表，替换对应的明文\n\n![image-20240501232252019](信息网络安全/image-20240501232252019.png)\n\n#### 4.4.3.2 行位移\n\n线性运算，以第0行开始，第i行左移i个字节。可以使原来同一列的4个元素分散到不同列\n\n![image-20240501232403611](信息网络安全/image-20240501232403611.png)\n\n#### 4.4.3.3 列混合\n\n将上一步的结果左乘一个固定的4*4矩阵\n\n**在列混合中的乘法和普通的乘法不相同，**\n\n主要看a7为0还是为1,\n\n![image-20240501234117197](信息网络安全/image-20240501234117197.png)\n\n![img](信息网络安全/0f0a71f057cd4fae873a625f72a03847.png)\n\n\n\n![image-20240501232535297](信息网络安全/image-20240501232535297.png)\n\n#### 4.4.3.4 轮密钥加\n\n![image-20240501233057107](信息网络安全/image-20240501233057107.png)\n\n#### 4.4.3.5 循环\n\n![image-20240501233611792](信息网络安全/image-20240501233611792.png)\n\n**注意**：第十轮没有第三步（列混合）\n\n## 4.5 AES和DES的相似与不同\n\n### 4.5.1 相似\n\n![image-20240501235213078](信息网络安全/image-20240501235213078.png)\n\n### 4.5.2 不同\n\n![image-20240501235220080](信息网络安全/image-20240501235220080.png)\n\n# 五、公钥密码体制（非对称）\n\n- RSA算法\n- ElGamal算法\n- ECC算法\n- IBE算法\n\n**基本原理：**单向陷门函数\n\n## 5.0 公钥加密体制模型\n\n![image-20240502155233871](信息网络安全/image-20240502155233871.png)\n\n- 发送方A查找接收方B的公钥；\n- A采用公钥加密算法用B的公钥对明文进行加密；\n- A通过不安全信道将密文发送给B；\n- B收到密文后使用自己的私钥对密文解密还原出明文\n\n## 5.1 RSA算法\n\n RSA的理论基础是**欧拉定理**，其安全性依赖于**大整数的质数因子分解的困难性**\n\n### 5.1.1 加密过程\n\n| 步骤 |             说明             |       描述       |\n| :--: | :--------------------------: | :--------------: |\n|  1   | 选择一对不相等且足够大的质数 |       p,q        |\n|  2   |        计算p,q的乘积         |      n=p*q       |\n|  3   |       计算n的欧拉函数        | φ(n)=(p-1)*(q-1) |\n|  4   |   选一个与φ(n)互质的整数e    |     1<e<φ(n)     |\n|  5   |  计算出e对于φ(n)的模反元素d  | de mod φ(n) = 1  |\n|  6   |             公钥             |     KU=(e,n)     |\n|  7   |             私钥             |     KR=(d,n)     |\n\n明文 M，密文 C\n$$\nM^e\\%n =C\\\\\nC^d\\%n=M\n$$\n\n### 5.1.2 计算n的欧拉函数\n\n**欧拉函数**是小于n的正整数中与n互质的数的数目\n\n**互质**是指公约数只有1的两个数\n\n**质数**的欧拉函数值为n-1\n\nφ(6)=2\n\n**1**,2,3,4,**5**\n\n### 5.1.3 计算模反元素d\n\n如果两个正整数e和φ(n)互质，那么一定可以找到一个整数d，使得ed-1被φ(n)整数\n\n或者说ed除以φ(n)所得余数为1\n$$\ned-1=kφ(n)\\\\\ned\\%φ(n)=1\n$$\n因此d就叫做e的模反元素\n\n\n\n**欧几里得算法：**\n$$\n已知p=5,q=11,e=7，求d\\\\\nn=p*q=55\\\\φ(n)=(p-1)(q-1)=4*10=40\\\\\ned\\%φ(n)=1即ed-kφ(n)=1\\\\\n7d-40k=1\n$$\n采用辗转相除法，以小的数对大的数取模，得到的结果替换大的数\n$$\n40\\%7=5所以原式替换为7d-5k=1\\\\\n7\\%5=2所以上式替换为2d-5k=1\\\\\n5\\%2=1所以上式替换为2d-1k=1\n$$\n当出现某个数字变为1的时候即可结束辗转，\n\n**当e为1时，设k=0；当φ(n)=1时，设d=1**\n$$\n设d=1，由2d-1k=1得到k=1\\\\\n由2d-5k=1得到d=3\\\\\n由7d-5k=1得到k=4\\\\\n由7d-40k=1得到d=23\n$$\n\n快速取模运算：https://zhuanlan.zhihu.com/p/521322795\n\n### 5.1.4 RSA小结\n\n![image-20240502215526552](信息网络安全/image-20240502215526552.png)\n\n# 六、数字签名\n\n## **6.1 数字签名的定义**\n\n![image-20240502224239887](信息网络安全/image-20240502224239887.png)\n\n![image-20240502230200309](信息网络安全/image-20240502230200309.png)\n\n**散列函数(又称哈希函数)**是将任意长度的输入消息M映射成一个固定长度散列值h的特殊函数，使用Hash函数**缩小签名密文的长度**，大大提高了签名的速度\n\n## 6.2 RSA数字签名\n\n### 6.2.1 签名\n\n- 利用一个安全的hash函数h产生消息摘要h(m)\n- 计算签名\n\n$$\ns=signk(m)=h(m)^d \\% n\n$$\n\n\n\n### 6.2.2 验证\n\n- 接收者使用相同的hash函数h计算消息摘要h(m)\n\n- 接收者验证以下公式是否成立。若成立，则签名有效，否则签名无效\n  $$\n  h(m) \\% n=s^e \\% n\n  $$\n  \n\n## 6.3 练习\n\n为了生成RSA算法的密钥，选取两互异大素数p=11和q=13，假定e=17，求其公钥（e,n）和私钥d，并利用此私钥对消息m进行签名，其中h(m)=16，求其签名s？\n\n**答案：**d=113，s=16^113%143=48\n\n# 七、信息隐藏\n\n## 7.1 定义\n\n信息隐藏是将秘密信息隐藏在另一非机密的载体信息中，通过公共信道进行传递。攻击者无从判断是否有秘密信息，也无法提取或去除秘密信息。\n\n## 7.2 主要应用\n\n1. 数据保密\n2. 数据完整性（用于认证和篡改检测）\n3. 图像自恢复\n4. 版权保护\n5. 票据防伪\n\n## 7.3 特点\n\n- **鲁棒性**\n  - 伪装对象对隐藏信息的“兼容性”\n- **不可检测性**\n  - 好的统计特性，无法判断是否有隐藏信息\n- **透明性**\n  - 目标数据没有明显变化\n- **安全性**\n  - 隐藏算法有较强的抗攻击能力\n- **自恢复性**\n  - 少量的数据信息，恢复出隐藏信息\n\n## 7.4 数字水印\n\n### 7.4.1 概念\n\n将一些标识信息（即数字水印，如机构Logo、产品序列号等）直接嵌入数字载体当中，且不影响原载体的使用价值，也不容易被再次修改。\n\n### 7.4.2 数字水印的作用\n\n1. **版权保护**：表明对数字产品的所有权 \n2. **数字指纹**：用于防止数字产品被非法复制和散发\n3. **认证和完整性校验**：验证数字内容未被修改或假冒 \n4. **内容标识和隐藏标识**：多媒体内容检索\n5. **使用控制**：控制复制次数 \n6. **内容保护**：保护内容不被滥用\n\n# 八、应用层安全技术\n\n**SQL注入**：用户可以提交一段数据库查询代码，根据程序返回的结果，获得某些他想得知的数据\n\n**IIS**即Internet信息服务，是一个用于配置应用程序池或网站、FTP 站点、SMTP或NNTP站点的工具，功能十分强大。\n\n## 8.2 电子邮件系统\n\n![image-20240503161137755](信息网络安全/image-20240503161137755.png)\n\n根据邮件网关的**用途**可划分为**普通邮件网关**、**邮件过滤网关**、**反垃圾邮件网关**\n\n### 8.2.1 SMTP协议(Simple Mail Transfer Protocol)\n\n简单邮件传输协议，属于TCP/IP协议族的应用层协议，SMTP服务器则是遵循SMTP协议的发送邮件服务器，用来发送或中转电子邮件。\n\n### 8.2.2 POP协议(Post Office Protocol)\n\n邮局协议,是一种允许用户从邮件服务器收发邮件的协议\n\nPOP3允许用户从服务器上把邮件存储到本地主机，同时删除保存在邮件服务器上的邮件。是电子邮件的**第一个离线协议标准**\n\nPOP3服务器则是遵循POP3协议的接收邮件服务器，用来接收电子邮件的。\n\n### 8.2.3 反垃圾邮件技术\n\n- **过滤技术**\n  - 关键词过滤\n  - 黑白名单\n  - 基于规则过滤\n  - 智能和概率系统\n  - HASH技术\n- **验证查询**\n- **挑战**\n- **密码术**\n\n### 8.2.4 PCG技术\n\nPGP是一个基于**公钥加密算法**的应用程序，该程序把RSA公钥体系的方便和传统加密体系的高速度结合起来，并在数字签名和密钥认证管理机制上有巧妙的设计。\n\n**PGP特点：**\n\n- （1）加密速度快\n- （2）可移植性出色\n- （3）源代码是免费的\n\n\n\n# 九、网络攻击技术\n\n网络攻击的目标主要有两类：**系统**和**数据**，其所对应的安全性也涉及系统安全和数据安全两个方面。\n\n网络攻击分为**主动攻击**和**被动攻击**\n\n## 9.1 漏洞扫描技术\n\n**计算机漏洞**是指计算机系统具有的某种可能被入侵者恶意利用的属性。 \n\n **漏洞扫描技术**是指在攻击者渗透入侵到用户的系统前，采用手工或使用特定的软件工具，对系统脆弱点进行评估，寻找可能对系统造成损害的安全漏洞，并且对目标系统进行漏洞检测和分析\n\n**分类：**\n\n- 主机漏洞扫描：检查配置文件，增强主机系统安全性\n- 网络扫描：模拟黑客攻击，寻找安全漏洞\n\n## 9.2 ARP协议-地址解析协议\n\nMAC地址和IP地址间使用ARP 和RARP协议进行相互转换。\n\n协议缺陷：ARP和RARP均未对收发双方做任何认证，可以进行伪造身份\n\n## 9.3 Dos攻击\n\nDenial of Service-拒绝服务，**主要攻击方式是传送大量要求确认的信息到服务器，使服务器里充斥着这种无用的信息**周而复始，最终导致服务器瘫痪\n\n**常用DoS攻击方法**：\n\n- TCP SYN Flood攻击\n  - 发送大量TCP请求，从而使服务器资源耗尽\n- IP欺骗攻击\n  - 伪造大量IP地址，想服务器发送RST数据，使服务器不对合法用户提供服务\n- 带宽攻击\n  - 发送请求来消耗服务器缓冲区\n\n## 9.4 DDoS分布式拒绝服务\n\n**攻击是利用很多台计算机一起发动攻击**\n\n![image-20240503164343207](信息网络安全/image-20240503164343207.png)\n\n**防御手段：**\n\n（1）ISP+丢包\n\n（2）移动IP技术或借助检测工具\n\n# 十、计算机病毒\n\n定义：**计算机病毒是一个程序，一段可执行码。**\n\n特征：非授权可执行性、传染性、隐蔽性、潜伏性\n\n**常见病毒：**\n\n- 感染型病毒 ：危害最大\n- 蠕虫病毒：传播载体多，传播能力强\n- 后门程序：远程操控\n- 木马病毒：隐藏、窃取\n- 病毒工具：网络媒介\n- 病毒生成器：拼积木形式\n- 搞笑程序：愚弄\n\n## 10.1 VBS病毒\n\n这种病毒不断的利用自身的复制功能，把自身复制到计算机内的每一个文件夹内\n\n**原理：**首先将计算机病毒自身代码赋给字符串变量VBscopy。将这个字符串覆盖到目标文件并创建一个以目标文件名为文件名前缀，以vbs为扩展名的文件副本，最后删除目标文件。\n\n## 10.2 蠕虫病毒\n\n蠕虫病毒一般是由主程序和引导程序两部分构成。主程序成功入侵计算机后，读取网络状态信息，通过系统缺陷在联机的计算机上植入引导程序，感染每台计算机。\n\n### 10.3 木马\n\nWindows本身自带的 **Netstat**命令可以查看开放端口，判断是否有木马或其他黑客程序\n\n# 十一、防火墙\n\n**防火墙的作用:**\n\n1. 防黑客入侵\n2. 防病毒内网传播\n3. 访问控制\n4. “隔离”屏障 \n\n**概念：**一种将内部网和公众访问网（如Internet）分开的方法，它实际上是一种隔离技术\n\n**基本原理：**在两个网络进行通信时执行访问控制\n\n**防火墙的功能：**\n\n1. 网络安全屏障\n2. 强化网络安全策略\n3. 对网络存取和访问进行监控审计\n4. 防止内部信息外泄\n5. 保护内网安全\n\n\n\n# 十二、入侵检测系统\n\n入侵检测系统(Intrusion Detection System,IDS)是探测计算机网络攻击行为的软件或硬件。作为防火墙的合理补充，它可以帮助网络管理员探查进入网络的入侵行为，从而扩展系统管理员的安全管理能力。\n\n## 12.1**IDS主要功能：**\n\n1. 监测并分析用户和系统的活动\n2. 核查系统配置和漏洞\n3. 评估系统关键资源和数据文件的完整性\n4. 识别已知的攻击行为\n5. 统计分析异常行为\n6. 操作系统日志管理，并识别违反安全策略的用户活动\n\n\n\n## 12.2 IDS通用模型CIDF\n\n![image-20240503170424594](信息网络安全/image-20240503170424594.png)\n\n**入侵检测信息来源：**\n\n1. 系统和网络日志文件：利用系统和网络日志文件信息是入侵检测的**必要条件**\n2. 目录和文件中不期望的改变\n3. 程序执行中的不期望行为\n4. 物理形式的入侵信息\n\n**IDS信号分析手段：**\n\n- **模式匹配：**将收集到的信息和已知的网络入侵和系统误用模式数据库进行比对。\n\n​\t（1）优点：准确、效率高\n\n​\t（2）缺点：需要不断更新，无法检测未出现过的攻击\n\n- **统计分析：**首先给系统对象创建一个统计描述，统计正常使用时的一些测量属性。任何观测值在正常范围之外的，就认为有入侵行为发生。\n\n​\t（1）优点：可检测到未知和更为复杂的入侵\n\n​\t（2）缺点：误报、漏报率高\n\n- **完整性分析：**主要关注某个文件或对象是否被更改\n\n​\t（1）优点：能发现攻击导致文件或对象发生的任何改变\n\n​\t（2）缺点：无法实时响应，只能事后分析\n\n## 12.3 IDS分类\n\n- 基于网络的IDS\n  - 概念：对数据包进行分析以探测针对网络的攻击。\n  - 优点：全网监控，满足各种性能要求\n  - 缺点：带宽要求，无法处理加密数据\n\n- 基于主机的IDS\n  - 概念：通过在主机或操作系统上检查有关信息（系统调用，审计日志和错误信息）来探测入侵行为\n\n\n## 12.4 **入侵检测技术分类：**\n\n- 特征检测\n- 异常检测\n\n## 12.5 IDS面临的挑战\n\n1. 提高IDS的检测速度，以适应网络通信的要求\n2. 减少IDS的漏报和误报，提高其安全性和准确度\n3. 提高IDS的互动性能，从而提高整个系统的安全性能。\n\n\n\n# 十三、网络安全协议\n\n**概念：**安全协议是建立在密码体制基础上的一种交互通信协议，它运用密码算法和协议逻辑来实现认证和密钥分配\n\n## 13.1 TCP/IP 各层常见协议\n\n![image-20240512221851079](信息网络安全/image-20240512221851079.png)\n\n## 13.2 OSI常见协议\n\n![image-20240512221909053](信息网络安全/image-20240512221909053.png)\n\n\n\n# 十四、VPN技术\n\nVirtual Private Network,虚拟专用网络，采用加密、认证和隧道技术，利用公共网络设施来发送专用网络信息。\n\n## 14.1 常用的远程连接方法\n\n- 利用拨号技术来实现远程连接（数字/模拟）\n- 利用VPN实现远程连接\n\n​\t（1）硬件：路由器VPN\n\n​\t（2）软件：常用个人远程协助软件（花生壳，向日葵，Teamviewer）\n\n- 无线远程连接\n\n## 14.2 VPN的基本要求：\n\n- 用户验证\n- 地址管理\n- 数据加密\n- 密钥管理\n- 多协议支持\n\n## 14.3 隧道技术和基本要求\n\n### 14.3.1 概念\n\n隧道技术是一种通过使用互联网络的基础设施在网络之间传递数据的技术。\n\n### 14.3.2 基本要求\n\n1. 用户验证\n2. 令牌卡（Tokencard）支持\n3. 动态地址分配\n4. 数据压缩\n5. 数据加密\n6. 密钥管理\n7. 多协议支持\n\n## 14.4 VPN的优点\n\n- 节省成本\n- 实现网络安全\n- 简化网络结构\n- 连接的随意性\n- 掌握自主权\n\n# 十五、无线网络\n\n**概念：**以无线信道作传输媒介的计算机局域网，是有线联网方式的重要补充和延伸\n\n## 15.1 无线网络的安全防范措施\n\n- 采用强力的密码。\n- 严禁广播服务集合标识符(SSID)。\n- 采用有效的无线加密方式。\n- 采用不同类型的加密。\n- 对介质访问控制(MAC)地址进行控制。\n- 关闭无线网络接口。\n- 对网络入侵者进行监控。\n- 确保核心的安全。\n"},{"title":"嵌入式系统移植","url":"/2024/04/10/嵌入式系统移植/","content":"\n使用FS4412开发板\n\n# 网络配置\n\n**配置板子IP**\n\n编辑/etc/init.d/rcS文件，添加\n\n```shell\nifconfig eth0 192.168.2.111\nifconfig eth0 up\n```\n\n重启板子即可。\n\n**配置虚拟机IP**\n\n点击虚拟网络编辑器\n\n![image-20240410150711037](嵌入式系统移植/image-20240410150711037.png)\n\n![image-20240410150741702](嵌入式系统移植/image-20240410150741702.png)\n\n虚拟机有线网络设置\n\n![image-20240410151030759](嵌入式系统移植/image-20240410151030759.png)\n\n![image-20240410151047806](嵌入式系统移植/image-20240410151047806.png)\n\n注意：虚拟机网络适配器需要更改为**桥接模式**\n\n![image-20240410151130855](嵌入式系统移植/image-20240410151130855.png)\n\n\n\n## 编译软件\n\n编译软件采用`arm-linux-gcc`\n\n```shell\narm-linux-gcc a.c\n```\n\n\n\n# 文件传输\n\n采用`tftp`工具进行传输\n\n1. 安装tftp服务器：   注意：虚拟机需要连外网\n\t\n\t```bash\n\tsudo    apt-get    update\n\tsudo    apt-get    install     tftpd-hpa     tftp-hpa   \n\t```\n\t\n2. 配置tftp服务器：   \n\t\n\t```bash\n   sudo    vim    /etc/default/tftpd-hpa\n   点i进入编辑模式\n        TFTP_USERNAME=\"tftp\"\t\t\t\t\n        TFTP_DIRECTORY=\"/home/hqyj/tftpboot\"\t    //共享文件的路径；\n        TFTP_ADDRESS=\"0.0.0.0:69\"\t\t\t\n\t     TFTP_OPTIONS=\"-l   -c    -s\"\n\t 点Esc退出编辑模式\n\t\n\t家目录下面创建目录tftpboot:    \n\t\tsudo  mkdir   /home/hqyj/tftpboot\n\t修改共享文件的权限:   \n\t\tsudo   chmod   0777     /home/hqyj/tftpboot\n\t```\n\t\n3. 启动tftp服务器: Ubuntu开机后只需要启动一次      \n\t\n\t```bash\n\tsudo service tftpd-hpa restart\n\t```\n\t\n4. 将需要传输的文件存储在共享目录中(/home/hqyj/tftpboot):   \n\t\n\t```bash\n\tcp  <filename> /home/hqyj/tftpboot\n\t```\n\n要从远程主机`192.168.1.2`上下载 `test.txt`，则应输入以下命令\n\n```bash\ntftp -g -r test.txt 192.168.1.2\n```\n\n将磁盘中的文件上传到远程主机的命令\n\n```bash\ntftp -p -l file.txt 192.168.1.2\n```\n\n# Linux文件操作\n\n相关驱动文件存放在/dev中\n\n```cpp\nint fd = open();\nioctl(fd, _IO('L',0));\n```\n\nioctl的请求：\n\n- _IO('L',0)\t开灯\n- _IO('L',2)    关灯\n\n# 裸机操作\n\n![image-20240414091204368](嵌入式系统移植/image-20240414091204368.png)\n\n可以发现LED3连接到GPX1_0，查询用户手册\n\n![image-20240414091553406](嵌入式系统移植/image-20240414091553406.png)\n\n- CON：配置寄存器\n- DAT：数据寄存器\n- PUD：\n- DRV：\n\n![image-20240414092432928](嵌入式系统移植/image-20240414092432928.png)\n\n![image-20240414092049105](嵌入式系统移植/image-20240414092049105.png)\n\n![image-20240414091844457](嵌入式系统移植/image-20240414091844457.png)\n\n可以看到GPX1_0对应配置为GPX1CON[0]，配置[3:0]位置即可设置状态\n\nGPX1DAT[7:0]既可以配置输入输出电平，\n\n\n\n打开板子开关，马上按**回车**，进入启动加载界面（U-boot），类似于终端\n\n![image-20240414094159863](嵌入式系统移植/image-20240414094159863.png)\n\n通过`pri`命令可以打印基本配置信息\n\n![image-20240414094347917](嵌入式系统移植/image-20240414094347917.png)\n\n通过`set`命令修改配置信息，`save`保存\n\n![image-20240414094547766](嵌入式系统移植/image-20240414094547766.png)\n\n`ping`测试连通性\n\n![image-20240414094717566](嵌入式系统移植/image-20240414094717566.png)\n\n**注意：**Ubuntu ping不同开发板，裸机只能由开发板主动发起ping\n\n通过`tftp`下载文件，\n\n```\ntftp 内存地址 文件名\ntftp 43e00000 a.out\ngo 43e00000\n```\n\n此时为裸机，需要用二进制文件才能识别\n\n这个不为二进制数据文件\n\n![image-20240414101123569](嵌入式系统移植/image-20240414101123569.png)\n\n![image-20240414103310580](嵌入式系统移植/image-20240414103310580.png)\n\n高级语言：（预处理->编译->汇编->链接）\n\n- 预处理：展开头文件\n- 编译：把高级语言转变为汇编语言\n- 汇编：转变为二进制\n- 链接：将多个二进制段结合在一起\n\n```cpp\n#define GPX1CON (volatile unsigned int *)0x11000c20\n#define GPX1DAT (volatile unsigned int *)0x11000c24\n\nint main()\n{\n\t*GPX1CON = 0x1;\n\t*GPX1DAT = 0x1;\n\twhile(1);\n\treturn 0;\n}\n```\n\n转变为汇编语言\n\n# 操作系统启动\n\n**量产**：研发完成后，直接以一个整体放到内存中，直接启动 -> 产品\n\n研发过程中，首先将系统分为4部分：\n\n启动加载器(bootloader) + 系统内核(kernel) + 设备树(device tree) + 根文件系统(rootfs-root file system)\n\n![image-20240417150853819](嵌入式系统移植/image-20240417150853819.png)\n\n![image-20240417151100936](嵌入式系统移植/image-20240417151100936.png)\n\n![image-20240418150357886](嵌入式系统移植/image-20240418150357886.png)\n\n```\n相关命令：\nprintenv(pri):\nsaveenv(save): \nsetenv(set): set 变量名 (变量值)  //变量值为空的话就删除变量\nboot \nbootm \t内核\t根文件系统\t设备树\ntftp\n```\n\n\n\n##  分段启动操作系统\n\n```\n将 u-sd.bin烧写进入SD卡\n启动u-boot\ntftp下载内核镜像，前提为网络可以ping通\n```\n\n![image-20240417152243317](嵌入式系统移植/image-20240417152243317.png)\n\n```\ntftp 41000000 start/uImage\ntftp 42000000 start/exynos4412-fs4412.dtb\ntftp 43000000 start/ramdisk.img\n\nbootm 41000000 43000000 42000000\n\t\t内核\t 根文件系统  设备树\n```\n\n输入完成后即可进入此界面\n\n![image-20240417153246046](嵌入式系统移植/image-20240417153246046.png)\n\n配置网络采用`ifconfig eth0 ip地址`\n\n## 自启动操作系统\n\n```\nset bootcmd \"tftp 41000000 start/uImage;tftp 42000000 start/exynos4412-fs4412.dtb;tftp 43000000 start/ramdisk.img;bootm 41000000 43000000 42000000\"\nset bootdelay 1\nsave\n\nboot\n```\n\n## NFS挂载启动\n\n通过网络挂载一个共享文件夹\n\nramdisk.img是封装好的，rootfs.tar.gz是没封装的\n\n**Ubuntu下操作:**\n\n\t1.nfs安装,要有外网\n\t\t\t sudo   apt-get   update\n\t\t\t sudo   apt-get   install    nfs-kernel-server\n\t2.准备好一个即将被共享出去的文件夹\n\t\t sudo   mkdir     nfs\n\t\t sudo    chmod   0777    nfs\n\t\n\t3.将 文件系统 放入 nfs 文件夹, 解压文件系统   解压  rootfs.tar.xz\n\t\t tar  -xvf  rootfs.tar.xz\n\t\n\t4.解压后进入到rootfs目录，使用pwd确定所对应的绝对路径\n\t\t cd    rootfs\n\t\t pwd   -->  /home/hqyj/nfs/rootfs 就是用来挂载的共享路径；\n\t\t\n\t5.在nfs服务器的配置文件中说明 /home/hqyj/nfs/rootfs 需要共享出去\n\t\tsudo   vi    /etc/exports\n\t\t尾部加入, 添加新的一行:\n\t\t\t/home/hqyj/nfs/rootfs *(rw,sync,no_root_squash,no_subtree_check)\n\t\t解释:\n\t\t\t*：允许所有的网段访问，也可以使用具体的IP\n\t\t\trw：挂接此目录的客户端对该共享目录具有读写权限\n\t\t\tsync：资料同步写入内存和硬盘\n\t\t\tno_root_squash：root用户具有对根目录的完全管理访问权限\n\t\t\tno_subtree_check：不检查父目录的权限\n\t\n\t6.重启nfs共享\n\t\t sudo service nfs-kernel-server restart\n\t\n\t7.检查是否开成功\n\t\t showmount -e\n\t\t\tExport list for ubuntu:\n\t\t\t /home/hqyj/nfs/rootfs  * \t\t//共享成功的路径\n开发板上操作(不进操作系统):\t\n\n\t8.修改u-boot启动参数\n\t\tset   bootargs    \"root=/dev/nfs nfsroot=192.168.2.222:/home/hqyj/nfs/rootfs,v3 rw console=ttySAC2,115200 clk_ignore_unused init=/linuxrc ip=192.168.2.111\"\n\t\t\t注意更改:\n\t\t\t\tnfsroot=192.168.2.222:/home/hqyj/nfs/rootfs   //Ubuntu的ip地址,  要挂载的文件路径\n\t\t\t解释:\n\t\t\t\troot=/dev/nfs //文件系统在网上\n\t\t\t\tnfsroot=192.168.2.222:/home/hqyj/nfs/rootfs,v3 //那台电脑的哪个文件夹,而且用v3版本的协议\n\t\t\t\trw //可读可写\n\t\t\t\tconsole=ttySAC2,115200 //通过串口2输出信息,波特率115200\n\t\t\t\tclk_ignore_unused //忽略未使用的时钟，如果不加很有可能卡住\n\t\t\t\tinit=/linuxrc //当挂载成功后，自动执行init进程(文件夹下的linuxrc文件)\n\t\t\t\tip=192.168.2.111 //内核起来之后用这个IP(开发板IP)\n\t\t\t\t\n\t9.修改u-boot启动命令\n\tset  bootcmd  \"tftp  41000000  start/uImage;   tftp 43000000  start/exynos4412-fs4412.dtb;  bootm  41000000  -  43000000\"\n\tsave\n\n## EMMC启动\n\n要确保有一个u-emmc.bin\n\n```\n先SD卡启动，将u-emmc.bin 下载到运存\ntftp 41000000 u-emmc.bin\n\n将下载成功的u-emmc.bin放到emmc中\n命令：movi write u-boot 41000000\n解释：将41000000运存地址数据写入到emmc的u-boot区\n```\n\n![image-20240418152230925](嵌入式系统移植/image-20240418152230925.png)\n\n![image-20240418152306126](嵌入式系统移植/image-20240418152306126.png)\n\n进入后操作与前段相同\n\n## Bootloader\n\nCPU架构：\n\n```\nX86(intel):高性能\nC51(intel):低功耗，单片机-单应用（51单片机）\nARM(ARM):低功耗同时高性能，移动端市场\n\tCortex-A：高性能\n\tCortex-R：实时realtime\n\tCortex-M：低功耗（STM32）\n\npowerPC：功耗非常高，性能好，用于大型后台服务器\n```\n\n**什么是Bootloader？**\n\n- 硬件启动的引导程序，是运行操作系统的前提。\n- 在操作系统内核或用户应用运行之前的一段代码。\n- 对于硬件进行初始化，为操作系统准备好环境。\n- 在嵌入式系统重，整个系统的启动加载任务通常由bootloader来完成。\n\n**Bootloader**的特点：\n\n- 不属于操作系统，由汇编语言或C语言开发\n- 针对特定的硬件平台编写\n- 在移植系统时，首先要为开发板移植bootloader\n- bootloader不依赖于CPU的体系结构，依赖于嵌入式系统班设备的配置\n\n**bootloader的基本功能：**\n\n- 初始化相关硬件，把bootloader自搬运到内存中\n- 执行用户的命令：访问环境变量，通过串口/网络通信，读写RAM/FLASH\n- 加载并执行内核\n\n**bootloader启动：**\n\n1. 第一阶段：BL1\n   1. 初始化基本的硬件\n   2. 把bootloader搬运到内存\n   3. 设置堆栈指针并将bss段清理，为后续执行C代码做准备\n   4. 跳转到第二阶段代码\n2. 第二阶段：BL2\n   1. 初始化本阶段需要用到底的硬件\n   2. 读取环境变量\n   3. 如果是自启动模式，从flash或通过网络加载内核并执行\n   4. 如果是下载模式，接收用户的命令后执行\n\n# u-boot系统移植\n\n## 1.抄板 \n\n仿照别人的板子修改一些信息, 改成自己的 \n\n```\nvi boards.cfg 复制284行, yy复制, p粘贴, 将复制的285行中的两个origen修改为fs4412 \n\ncp include/configs/origen.h include/configs/fs4412.h \n\ncp -r board/samsung/origen/ board/samsung/fs4412 \n\nmv board/samsung/fs4412/origen.c board/samsung/fs4412/fs4412.c \n\nvi Makefile 修改185行: CROSS_COMPILE ?= arm-none-linux-gnueabi\n\nvi board/samsung/fs4412/Makefile 修改31行: COBJS += fs4412.o \n\nmake fs4412 \n//敲 fs4 用tab键补全 make完成后, 看看有没有报错信息, 没有的话就能生成 u-boot.bin 文件\n```\n\n![image-20240418163234598](嵌入式系统移植/image-20240418163234598.png)\n\n具体过程：\n\n [u-boot移植.pdf](u-boot移植.pdf) \n\n[代码修改](1.代码修改.txt)\n\n [tool_SD_img.zip](tool_SD_img.zip)\n\n[tool_EMMC_bin.zip](tool_EMMC_bin.zip) \n\n [movi 修改文件.zip](movi 修改文件.zip) \n\n# Linux内核\n\n通常我们使用的Linux系统是一个集Linux内核、工具集、各种库、桌面管理器、应用程序于一体的一个发布包\n\n一个内核不是一套完整的操作系统，\n\n“内核”指的是一个提''供硬件抽象层、磁盘以及文件控制、多任务等功能的系统软件\n\n## 内核移植\n\n### 准备\n\n安装插件exuberant-ctags和libncurses5-dev\n\n```\nsudo apt-get update //更新软件\nsudo apt-get install exuberant-ctags\nsudo apt-get install libncurses5-dev\n```\n\n获取Linux源码，并解压\n\n```bash\ntar -xvf linux-3.14.tar.xz\n```\n\n修改交叉编译工具\n\n```\n修改Makefile，198行,199行\nARCH ?= arm\nCROSS_COMPILE ?= arm-none-linux-gnueabi-\n```\n\n![image-20240420110903156](嵌入式系统移植/image-20240420110903156.png)\n\n生成默认配置\n\n（配置文件放在 arch/arm/configs下）\n\n```\nmake exynos_defconfig\n```\n\n![image-20240420111239775](嵌入式系统移植/image-20240420111239775.png)\n\n### 配置内核:\n\n正常执行，会弹出一个菜单选项，我们可以去选择需要配置的内核；\n\n```\nmake menuconfig\n```\n\n![image-20240420111316895](嵌入式系统移植/image-20240420111316895.png)\n\n在菜单界面选中 dm9000 网卡驱动\n\n```\nDevice Drivers --->\n\t[*] Network device support --->\n\t\t[*] Ethernet driver support --->\n\t\t\t<*> DM9000 support\n回车键选择进入, 空格键改变选择, 上下左右方向键改变选择\n```\n\n```\n内核中选配必要的网络协议栈支持\n[*] Networking support --->\n\tNetworking options --->\n\t\t<*> Packet socket\n\t\t<*>Unix domain sockets\n\t\t[*] TCP/IP networking\n\t\t[*] IP: kernel level autoconfiguration\n```\n\n```\n选择NFS支持\nFile systems --->\n\t[*] Network File Systems (NEW) --->\n\t\t<*> NFS client support\n        [*] NFS client support for NFS version 3\n        [*] NFS client support for the NFSv3 ACL protocol extension\n        [*] Root file system on NFS\n```\n\n```\n选择USB支持\nDevice Drivers --->\n\t[*] USB support --->\n        <*> EHCI HCD (USB 2.0) support\n        <*>EHCI support for Samsung S5P/EXYNOS SoC Series\n        <*> USB Mass Storage support\n        <*> USB3503 HSIC to USB20 Driver\n\t\tUSB Physical Layer drivers --->\n\t\t\t<*> Samsung USB 2.0 PHY controller Driver\n\tSCSI device support --->\n        <*> SCSI device support\n        <*> SCSI disk support\n        <*> SCSI generic support\n```\n\n### 编译生成内核镜像\n\n编译内核镜像会用到\"mkimage\"命令, 需要提前配置一下, 这个工具在 u-boot 文件夹下 首先将u-boot-2013.01文件夹下的mkimage命令复制到用户系统命令文件夹下\n\n```\nsudo cp ../u-boot-2013.01/tools/mkimage /usr/local/bin/\n```\n\n编译内核\n\n```\nmake uImage\n```\n\n编译成功会生成一个经过压缩后的镜像文件uImage，\n\n其生成的文件路径为：arch/arm/boot/uImage\n\n将生成的 uImage 移动到 tftp 共享 路径下\n\n```bash\ncp arch/arm/boot/uImage /home/hqyj/tftp/my_uImage\n```\n\n启动镜像\n\n![image-20240420114131499](嵌入式系统移植/image-20240420114131499.png)\n\n [内核移植.pdf](内核移植.pdf) \n\n![image-20240421082027484](嵌入式系统移植/image-20240421082027484.png)\n\n```\nImage:原始镜像\nzImage:压缩镜像\nuImage:在zImage的基础上多补充了【格式头】\n\nImage -> 压缩 -> zImage -> 添加u-boot能解析的格式头 -> uImage\n```\n\n## 设备树移植\n\n![image-20240421090313912](嵌入式系统移植/image-20240421090313912.png)\n\n复制一份为exynos4412-fs412.dts\n\n修改527行后面，添加**网卡驱动**\n\n![image-20240421091312045](嵌入式系统移植/image-20240421091312045.png)\n\n格式不对，选中全部行，按一下\"=\"，格式即可对齐\n\n![image-20240421091359487](嵌入式系统移植/image-20240421091359487.png)\n\n修改makefile文件\n\n![image-20240421091853047](嵌入式系统移植/image-20240421091853047.png)\n\n编译设备树文件：\n\n```\nmake dtbs\n```\n\n![image-20240421091932551](嵌入式系统移植/image-20240421091932551.png)\n\n拷贝编译的设备树到tftp共享文件中:\n\n```\ncp arch/arm/boot/dts/exynos4412-fs4412.dtb /home/hqyj/tftp/my_exynos4412-fs4412.dtb\n```\n\n挂载启动\n\n![image-20240421092414811](嵌入式系统移植/image-20240421092414811.png)\n\n拓展：添加**USB驱动**\n\n```\nvim arch/arm/boot/dts/exynos4412-fs4412.dts\n```\n\n```\nusbphy: usbphy@125B0000 {\n#address-cells = <1>;\n#size-cells = <1>;\ncompatible = \"samsung,exynos4x12-usb2phy\";\nreg = <0x125B0000 0x100>;\nranges;\nclocks = <&clock 2>, <&clock 305>;\nclock-names = \"xusbxti\", \"otg\";\nusbphy-sys {\nreg = <0x10020704 0x8 0x1001021c 0x4>;\n};\n};\nehci@12580000 {\nstatus = \"okay\";\nusbphy = <&usbphy>;\n};\nusb3503@08 {\ncompatible = \"smsc,usb3503\";\nreg = <0x08 0x4>;\nconnect-gpios = <&gpm3 3 1>;\nintn-gpios = <&gpx2 3 1>;\nreset-gpios = <&gpm2 4 1>;\ninitial-mode = <1>;\n};\n```\n\n```\nmake dtbs\n```\n\n```\ncp arch/arm/boot/dts/exynos4412-fs4412.dtb /home/hqyj/tftp/my_exynos4412-fs4412.dtb\n```\n\n插入USB设备，\n\n![image-20240421093222897](嵌入式系统移植/image-20240421093222897.png)\n\n## 字符设备\n\n![image-20240421102926332](嵌入式系统移植/image-20240421102926332.png)\n\n主（组）设备号，用于定义同一类设备\n\n次设备号用于定位具体设备\n\n\n\n修改Makefile\n\n![image-20240421111004155](嵌入式系统移植/image-20240421111004155.png)\n\n生成驱动代码.ko文件\n\n板子通过`insmod myled.ko`安装驱动\n\n通过应用程序开关灯\n\n![image-20240421111723254](嵌入式系统移植/image-20240421111723254.png)\n\n卸载驱动文件\n\n![image-20240421112006653](嵌入式系统移植/image-20240421112006653.png)\n\n## 根文件系统制作\n\n我们选择的版本是busybox-1.22.1.tar.bz2, 将文件移动到Ubuntu内, 进行解压:\n\n进入源码目录, 在 busybox-1.22.1 文件夹内进行操作: \n\n```\nmake menuconfig \n```\n\n![image-20240422160754543](嵌入式系统移植/image-20240422160754543.png)\n\n```\nBusybox Settings --->\nBuild Options --->\n[*] Build BusyBox as a static binary (no shared libs)\n[ ] Force NOMMU build\n[ ] Build with Large File Support (for accessing files > 2 GB)\n(arm-linux-) Cross Compiler prefix //采用的编译器是arm-linux-,敲回车输入\n```\n\n![image-20240422160843827](嵌入式系统移植/image-20240422160843827.png)\n\n配置好保存后, 进行编译: \n\n```\nmake\n```\n\n编译好后, 安装busybox, 生成根文件夹:  \n\n```\nmake install\n```\n\n安装完成后默认生成 _install 文件夹, 这就是我们制作的根文件夹, 将所有文件拷贝到nfs共享文件夹下,\n切换路径:  \n\n```\nsudo cp -rf _install /home/hqyj/nfs/my_rootfs\ncd /home/hqyj/nfs/my_rootfs\nls\n```\n\n![image-20240422161124379](嵌入式系统移植/image-20240422161124379.png)\n\n创建缺少的目录  \n\n```\nsudo mkdir etc dev tmp mnt proc sys var lib\n```\n\n![image-20240422161809231](嵌入式系统移植/image-20240422161809231.png)\n\n添加所需要的库代码 \n\n```\nsudo   cp  -a  /home/hqyj/Downloads/gcc-4.6.4/arm-arm1176jzfssf-linux-gnueabi/sysroot/lib/*    ./lib/\n```\n\n删除无用的库，用来保证rootfs足够小8M以内；\n\n```\nsudo rm lib/*.a     \nsudo cp /home/hqyj/Downloads/gcc-4.6.4/bin/arm-linux-strip   /usr/local/bin/ \nsudo arm-linux-strip lib/*\n```\n\n![image-20240422161930999](嵌入式系统移植/image-20240422161930999.png)\n\n### 添加系统启动文件 \n\n在etc下添加文件inittab，文件内容如下  sudo vi etc/inittab\n\n```\n#this is run first except when booting in single-user mode.\n::sysinit:/etc/init.d/rcS\n# /bin/sh invocations on selected ttys\n# start an \"askfirst\" shell on the console (whatever that may be)\n::askfirst:-/bin/sh\n# stuff to do when restarting the init process\n::restart:/sbin/init\n# stuff to do before rebooting\n::ctrlaltdel:/sbin/reboot\n```\n\n在etc下添加文件fstab，文件内容如下,  \n\n```\n#device mount-point type options dump fsck order\nproc /proc proc defaults 0 0\ntmpfs /tmp tmpfs defaults 0 0\nsysfs /sys sysfs defaults 0 0\ntmpfs /dev tmpfs defaults 0 0\n```\n\n在etc下创建init.d目录，并在init.d下创建rcS文件，rcS文件内容为：  \n\n```\n#!/bin/sh\n# This is the first script called by init process\n/bin/mount -a\necho /sbin/mdev > /proc/sys/kernel/hotplug\n/sbin/mdev -s\n```\n\n为rcS添加可执行权限:\n\n```\nsudo chmod +x etc/init.d/rcS\n```\n\n  在etc下添加profile文件，文件内容为:  \n\n```\n#!/bin/sh\nPATH=/bin:/sbin:/usr/bin:/usr/sbin\nLD_LIBRARY_PATH=/lib:/usr/lib:$LD_LIBRARY_PATH\nexport PATH LD_LIBRARY_PATH\nexport HOSTNAME=Group3\nexport USER=Vicczyq\nexport HOME=root\nexport PS1=\"[$USER@$HOSTNAME \\W]\\# \"\n```\n\n### 复制文件系统, 修改挂载镜像  \n\n在nfs服务器的配置文件中说明 /home/hqyj/nfs/my_rootfs 需要共享出去  \n\n```\nsudo vi /etc/exports  \n```\n\n```\n将原来的挂载信息屏蔽 - 前面加#:\n# /home/hqyj/nfs/rootfs *(rw,sync,no_root_squash,no_subtree_check)\n尾部加入, 添加新的一行:\n/home/hqyj/nfs/my_rootfs *(rw,sync,no_root_squash,no_subtree_check)\n```\n\n```\n重启nfs\nsudo service nfs-kernel-server restart\n```\n\n开发板设置启动参数\n\n```\nset bootargs \"root=/dev/nfs nfsroot=192.168.2.222:/home/hqyj/nfs/my_rootfs,v3 rw console=ttySAC2,115200 clk_ignore_unused init=/linuxrc ip=192.168.2.111\"\nsave\n```\n\n![image-20240422163406444](嵌入式系统移植/image-20240422163406444.png)\n\n### 打包为img镜像文件\n\n```\ncd /home/hqyj/nfs\n```\n\n创建一个8M的空磁盘(ramdisk)\n\n```\ndd if=/dev/zero of=ramdisk bs=1k count=8192 \n```\n\n![image-20240422171712115](嵌入式系统移植/image-20240422171712115.png)\n\n把ramdisk制作成ext2格式的文件\n\n```\nmkfs.ext2 -F ramdisk  \n```\n\n![image-20240422171736733](嵌入式系统移植/image-20240422171736733.png)\n\n创建mymnt目录作为挂载点\n\n```\nmkdir  mymnt \n```\n\n把ramdisk挂载到mymnt/  \n\n```\nsudo mount -t ext2 ramdisk mymnt/ \n```\n\n将测试好的文件系统里的内容全部拷贝到 mymnt/ 目录下面\n\n```\nsudo cp -a my_rootfs/* mymnt/\n```\n\n取消挂载\n\n```\nsudo  umount  mymnt/\n```\n\n压缩ramdisk为ramdisk.gz\n\n```\ngzip  --best  -c  ramdisk  >  ramdisk.gz\n```\n\n格式化为uboot识别的格式\n\n```\nmkimage -n \"ramdisk\" -A arm -O linux -T ramdisk -C gzip -d ramdisk.gz ramdisk.img\n```\n\n![image-20240422172254713](嵌入式系统移植/image-20240422172254713.png)\n\n拷贝到tftp目录下,方便下载\n\n```\ncp  ramdisk.img  /home/hqyj/tftp/my_ramdisk.img\n```\n\n### 板子设置\n\n```\nset bootcmd \"tftp 41000000 my_uImage;tftp 42000000 my_exynos4412-fs4412.dtb;tftp 43000000 my_ramdisk.img;bootm 41000000 43000000 42000000\"\n```\n\n![image-20240422173216187](嵌入式系统移植/image-20240422173216187.png)\n\n# 整个打包\n\n创建一个img镜像文件\n\n```\nsudo dd if=/dev/zero of=fs4412.img bs=1M count=300\n```\n\n安装工具\n\n```\nsudo apt install kpartx qemu-utils fdisk\n```\n\n建立分区\n\n```\nsudo fdisk ./fs4412.img\n1.使用m可以查看帮助\n2.使用n快速创建分区 这里第一分区是16m\n3.第二分区剩下的全部（需再按一次n重新分区）\n4.记得保存 使用w进行保存\n5.最后按q退出\n一般都选择默认 分区大小写 +16m 表示增加16m的分区如下：\n\nCommand (m for help): n //创建分区\nPartition type\n   p   primary (0 primary, 0 extended, 4 free)\n   e   extended (container for logical partitions)\nSelect (default p): p //创建主分区\nPartition number (1-4, default 1): 1 //第一分区\nFirst sector (2048-614399, default 2048): 2048 //默认 也可直接按回车\nLast sector, +sectors or +size{K,M,G,T,P} (2048-614399, default 614399): +16m //表示增加16m 若直接回车表示后面的全部为该分区的内容 所以第二分区可以直接全按回车\n\nCreated a new partition 1 of type 'Linux' and of size 16 MiB.\n\n```\n\n加载img文件\n\n```\nsudo kpartx -av ./fs4412.img\n加载成功会出现以下位置：\nsudo kpartx -av ./fs4412.img\nadd map loop28p1 (253:0): 0 32768 linear 7:28 2048\nadd map loop28p2 (253:1): 0 579584 linear 7:28 34816\n说明在设备加载在/dev/loop28\n而两个分区是/dev/mapper/loop28p1 和loop28p2\n```\n\n格式化两个分区\n\n```\n第一分区为fat16（按需求 v3s是fat16）\nsudo mkfs -t fat /dev/mapper/loop28p1\n第二分区为ext4\nsudo mkfs.ext4  /dev/mapper/loop28p2 -L rootfs\n```\n\n挂载两个分区\n\n```\n创建两个文件夹\nmkdir -p ./boot\nmkdir -p  ./rootfs\n挂载两个分区到两个文件夹中\nsudo mount /dev/mapper/loop28p1 ./boot/\nsudo mount /dev/mapper/loop28p2 ./rootfs/\n加载完后可以用 df -h命令查看是否挂载下面图有挂载成功的图\n```\n\n![image-20240424112658286](嵌入式系统移植/image-20240424112658286.png)\n\n将boot，内核，设备树文件拷贝进boot分区中\n\n[PhraseEdit.txt](PhraseEdit.txt)\n"},{"title":"CPP相关问题","url":"/2024/04/01/CPP相关问题/","content":"\n# 1 C/C++概念\n\n## 1.1 简述C++的特点\n\n- 支持**面向对象**程序设计，包括封装、继承和多态三大特征\n- 更加安全，增加了const变量、引用&、智能指针、try_catch等\n- 引入了模板的概念，可复用性高\n- 跨平台\n\n## 1.2 各种变量之间的区别\n\n主要看**生命周期**和**作用域**\n\n## 1.3 new和malloc的区别\n\nnew是一个**操作符**，malloc是一个**函数**\n\nmalloc内存分配成功返回的是void*，需要强制类型转换，而new无需进行\n\nmalloc分配内存失败会返回NULL，new则返回bac_alloc的异常\n\n## 1.4 有了malloc/free 为什么还要new/delete ?\n\nmalloc/free是函数，无法在创建对象时自动执行构造函数，也无法再消亡时自动执行析构函数，因此需要new和delete\n\n**new创建的是一个对象，malloc分配的是一块内存区域**\n\n## 1.5 指针函数和函数指针的区别？\n\n**函数指针：**指向函数的指针变量，可以通过指针调用函数\n\n```cpp\n#include <stdio.h>\nint add(int a,int b){\n\treturn a+b;\n}\nint sub(int a,int b){\n\treturn a-b;\n}\n//函数指针\nint (*func)(int a,int b);\n\nint main()\n{\n\tfunc = &add;\n\tprintf(\"add:%d\\n\",(*func)(10,5));\n\tfunc = &sub;\n\tprintf(\"sub:%d\\n\",(*func)(10,5));\n\treturn 0;\n}\n```\n\n**指针函数：**返回值为指针的函数，比如，int * func()\n\n## 1.6 野指针\n\n指向“垃圾”内存的指针，由于**未初始化指针**、**数据已删除**或**超出作用域**都会产生\n\n# 2 面向对象\n\n## 2.1 什么是面向对象\n\n一种软件开发方法，也是一种编程范式，将相关数据和对这些数据的操作组织称一个整体，成为“对象”。\n\n## 2.2 面向对象的三大特征\n\n**封装、继承、多态**\n\n- 封装：将属性和方法打包在一起，形成一个“类”，并对其加以权限控制\n- 继承：让某个类型的对象获得另外一个类型对象的属性和方法的机制。\n- 多态：通过基类指针可以调用任何派生类的函数。多态分为编译时的多态（重载），运行时的多态（虚函数）。\n\n三大特性使得编程更加灵活，提高代码的可读性、可复用性、可维护性\n\n"},{"title":"LeetCode-top-100","url":"/2024/03/14/LeetCode-top-100/","content":"\n# 1 两数之和\n\n给定一个整数数组 `nums` 和一个整数目标值 `target`，请你在该数组中找出 **和为目标值** *`target`* 的那 **两个** 整数，并返回它们的数组下标。\n\n你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。\n\n你可以按任意顺序返回答案。\n\n**示例 1：**\n\n```cpp\n输入：nums = [2,7,11,15], target = 9\n输出：[0,1]\n解释：因为 nums[0] + nums[1] == 9 ，返回 [0, 1] 。\n```\n\n**示例 2：**\n\n```cpp\n输入：nums = [3,2,4], target = 6\n输出：[1,2]\n```\n\n创建一个哈希表，对于每一个 x，首先查询哈希表中是否已存在 target - x，如果存在那么就已经找到了答案，不存在直接将 x 插入到哈希表中，方便下一次快速匹配。\n\n```cpp\nclass Solution {\npublic:\n    vector<int> twoSum(vector<int>& nums, int target) {\n        unordered_map<int, int> mp;//创建哈希表\n        vector<int> res(2, -1);\n        for (int i = 0; i < nums.size(); i++) {\n            if (mp.count(target - nums[i]) == 0) {\n                mp.insert(pair<int, int>(nums[i], i));\n            } else {\n                res[0] = mp[target - nums[i]];\n                res[1] = i;\n                break;\n            }\n        }\n        return res;\n    }\n};\n```\n\n# 2 字母异位词分组\n\n给你一个字符串数组，请你将 **字母异位词** 组合在一起。可以按任意顺序返回结果列表。\n\n**字母异位词** 是由重新排列源单词的所有字母得到的一个新单词。\n\n**示例 1:**\n\n```\n输入: strs = [\"eat\", \"tea\", \"tan\", \"ate\", \"nat\", \"bat\"]\n输出: [[\"bat\"],[\"nat\",\"tan\"],[\"ate\",\"eat\",\"tea\"]]\n```\n\n**示例 2:**\n\n```\n输入: strs = [\"\"]\n输出: [[\"\"]]\n```\n\n**示例 3:**\n\n```\n输入: strs = [\"a\"]\n输出: [[\"a\"]]\n```\n\n将每一个字符串都进行排序得到唯一的序列，将序列用hash表保存起来，做映射，最后遍历hash表得到结果\n\n```cpp\nclass Solution {\npublic:\n    vector<vector<string>> groupAnagrams(vector<string>& strs) {\n        unordered_map<string,vector<string>> hash;\n        for(vector<string>::iterator it=strs.begin();it!=strs.end();it++){\n            string str_tmp = *it;\n            sort(str_tmp.begin(),str_tmp.end());\n            hash[str_tmp].push_back(*it);\n        }\n        vector<vector<string>> res;\n        for(unordered_map<string,vector<string>>::iterator it=hash.begin();it!=hash.end();it++){\n            res.push_back(it->second);\n        }\n        return res;\n    }\n};\n};\n```\n\n# 3 最长连续序列\n\n给定一个未排序的整数数组 `nums` ，找出数字连续的最长序列（不要求序列元素在原数组中连续）的长度。\n\n请你设计并实现时间复杂度为 `O(n)` 的算法解决此问题。\n\n**示例 1：**\n\n```\n输入：nums = [100,4,200,1,3,2]\n输出：4\n解释：最长数字连续序列是 [1, 2, 3, 4]。它的长度为 4。\n```\n\n**示例 2：**\n\n```\n输入：nums = [0,3,7,2,5,8,4,6,0,1]\n输出：9\n```\n\n\n\n```cpp\nclass Solution {\npublic:\n    int longestConsecutive(vector<int>& nums) {\n        int max_len = 0;\n        unordered_set<int> st;\n        for (auto num : nums)\n            st.insert(num);\n        for (auto num : st){\n            if(st.find(num-1)==st.end()){\n                int len=1;\n                while(st.find(num+len)!=st.end())len++;\n                max_len=max(max_len,len);\n            }\n        }\n            return max_len;\n    }\n};\n```\n\n# 4 移动零\n\n给定一个数组 `nums`，编写一个函数将所有 `0` 移动到数组的末尾，同时保持非零元素的相对顺序。\n\n**请注意** ，必须在不复制数组的情况下原地对数组进行操作。\n\n**示例 1:**\n\n```\n输入: nums = [0,1,0,3,12]\n输出: [1,3,12,0,0]\n```\n\n**示例 2:**\n\n```\n输入: nums = [0]\n输出: [0]\n```\n\n \n\n```cpp\nclass Solution {\npublic:\n    void moveZeroes(vector<int>& nums) {\n        int count = 0;\n        for (vector<int>::iterator it = nums.begin(); it != nums.end();) {\n            if (*it == 0) {\n                nums.erase(it);\n                count++;     \n            } else {\n                it++;\n            }\n        }\n        for (int i = 0; i < count; i++){\n            nums.push_back(0);\n        }\n    }\n};\n```\n\n# 5 盛最多水的容器\n\n给定一个长度为 `n` 的整数数组 `height` 。有 `n` 条垂线，第 `i` 条线的两个端点是 `(i, 0)` 和 `(i, height[i])` 。\n\n找出其中的两条线，使得它们与 `x` 轴共同构成的容器可以容纳最多的水。\n\n返回容器可以储存的最大水量。\n\n**说明：**你不能倾斜容器。\n\n**示例 1：**\n\n![img](LeetCode-top-100/question_11.jpg)\n\n```\n输入：[1,8,6,2,5,4,8,3,7]\n输出：49 \n解释：图中垂直线代表输入数组 [1,8,6,2,5,4,8,3,7]。在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为 49。\n```\n\n**示例 2：**\n\n```\n输入：height = [1,1]\n输出：1\n```\n\n 双指针法，初始化i、j为两端，取height最小的向右或者向左移，直到两端相遇\n\n```cpp\nclass Solution {\npublic:\n    int maxArea(vector<int>& height) {\n        int i = 0, j = height.size() - 1, MAX = -1;\n        while(i < j){\n            MAX = height[i] > height[j] ? \n    max(MAX, (j-i) * height[j--]):max(MAX, (j-i)* height[i++]);\n        }\n        return MAX;\n    }\n};\n```\n\n# 6 三数之和\n\n给你一个整数数组 `nums` ，判断是否存在三元组 `[nums[i], nums[j], nums[k]]` 满足 `i != j`、`i != k` 且 `j != k` ，同时还满足 `nums[i] + nums[j] + nums[k] == 0` 。请\n\n你返回所有和为 `0` 且不重复的三元组。\n\n**注意：**答案中不可以包含重复的三元组。\n\n**示例 1：**\n\n```\n输入：nums = [-1,0,1,2,-1,-4]\n输出：[[-1,-1,2],[-1,0,1]]\n解释：\nnums[0] + nums[1] + nums[2] = (-1) + 0 + 1 = 0 。\nnums[1] + nums[2] + nums[4] = 0 + 1 + (-1) = 0 。\nnums[0] + nums[3] + nums[4] = (-1) + 2 + (-1) = 0 。\n不同的三元组是 [-1,0,1] 和 [-1,-1,2] 。\n注意，输出的顺序和三元组的顺序并不重要。\n```\n\n**示例 2：**\n\n```\n输入：nums = [0,1,1]\n输出：[]\n解释：唯一可能的三元组和不为 0 。\n```\n\n**示例 3：**\n\n```\n输入：nums = [0,0,0]\n输出：[[0,0,0]]\n解释：唯一可能的三元组和为 0 。\n```\n\n \n\n```cpp\nclass Solution {\npublic:\n    vector<vector<int>> threeSum(vector<int>& nums) {\n        vector<vector<int>> res;\n        sort(nums.begin(), nums.end());\n        int N = nums.size();\n        for (int i = 0; i < N; i++) {\n            if(nums[i] > 0) break;//当nums[i]大于零的时候,nums[l]和nums[r]必定大于零\n            if(i != 0 && nums[i] == nums[i-1])continue;//去重，跳过\n            int l = i+1;\n            int r = N-1;\n            while(l < r){\n                int sum = nums[i] + nums[l] + nums[r];\n                if( sum == 0 ){\n                    res.push_back({nums[i],nums[l],nums[r]});\n                    while( l+1 < r && nums[l] == nums[l+1]) l++;//去重\n                    while( r-1 > l && nums[r-1] == nums[r]) r--;//去重\n                    l++;\n                    r--;\n                } else if(sum < 0) {\n                    l++;\n                } else if(sum > 0){\n                    r--;\n                }\n            }\n        }\n\n        return res;\n    }\n};\n```\n\n# 7 只出现一次的数字\n\n给你一个 **非空** 整数数组 `nums` ，除了某个元素只出现一次以外，**其余每个元素均出现两次**。找出那个只出现了一次的元素。\n\n你必须设计并实现线性时间复杂度的算法来解决此问题，且该算法只使用常量额外空间。\n\n**示例 1 ：**\n\n```\n输入：nums = [2,2,1]\n输出：1\n```\n\n**示例 2 ：**\n\n```\n输入：nums = [4,1,2,1,2]\n输出：4\n```\n\n**示例 3 ：**\n\n```\n输入：nums = [1]\n输出：1\n```\n\n一开始想法为对数组进行排序，再用栈进行匹配处理\n\n```cpp\nclass Solution {\npublic:\n    int singleNumber(vector<int>& nums) {\n        stack<int> stk;\n        sort(nums.begin(),nums.end());\n        for(auto num:nums){\n            if(!stk.empty() && num==stk.top()){\n                stk.pop();\n            }else{\n                stk.push(num);\n            }\n        }\n        return stk.top();\n    }\n};\n```\n\n在题解中看到**异或运算** ：注意题目中的“除了某个元素只出现一次以外，其余每个元素均出现两次”，采用异或运算即可求出所需数字\n\n```cpp\nclass Solution {\npublic:\n    int singleNumber(vector<int>& nums) {\n        int res = 0;\n        for(auto num:nums){\n            res ^= num;\n        }\n        return res;\n    }\n};\n```\n\n# 8 无重复字符的最长子串\n\n给定一个字符串 `s` ，请你找出其中不含有重复字符的 **最长子串**的长度。\n\n**示例 1:**\n\n```\n输入: s = \"abcabcbb\"\n输出: 3 \n解释: 因为无重复字符的最长子串是 \"abc\"，所以其长度为 3。\n```\n\n**示例 2:**\n\n```\n输入: s = \"bbbbb\"\n输出: 1\n解释: 因为无重复字符的最长子串是 \"b\"，所以其长度为 1。\n```\n\n**示例 3:**\n\n```\n输入: s = \"pwwkew\"\n输出: 3\n解释: 因为无重复字符的最长子串是 \"wke\"，所以其长度为 3。\n     请注意，你的答案必须是 子串 的长度，\"pwke\" 是一个子序列，不是子串。\n```\n\n**提示：**\n\n- `0 <= s.length <= 5 * 104`\n- `s` 由英文字母、数字、符号和空格组成\n\n采用**滑动窗口法**解决，\n\n如何移动？我们只要把队列的左边的元素移出就行了，直到满足题目要求！\n\n```cpp\nclass Solution {\npublic:\n    int lengthOfLongestSubstring(string s) {\n        int l = 0, r = 1;\n        int res = 0;\n        int n = s.size();\n        while (r <= s.size()) {\n            res = max(res, r-l);\n            for (int i = l; i < r; i++) {\n                if(s[i] == s[r]){\n                    l = i + 1;\n                    break;\n                }\n            }\n            r++;\n        }\n        return res;\n    }\n};\n```\n\n# 9 杨辉三角\n\n给定一个非负整数 *`numRows`，*生成「杨辉三角」的前 *`numRows`* 行。\n\n在「杨辉三角」中，每个数是它左上方和右上方的数的和。\n\n![img](LeetCode-top-100/1626927345-DZmfxB-PascalTriangleAnimated2.gif)\n\n \n\n**示例 1:**\n\n```\n输入: numRows = 5\n输出: [[1],[1,1],[1,2,1],[1,3,3,1],[1,4,6,4,1]]\n```\n\n**示例 2:**\n\n```\n输入: numRows = 1\n输出: [[1]]\n```\n\n```cpp\nclass Solution {\npublic:\n    vector<vector<int>> generate(int numRows) {\n        vector<vector<int>> res;\n        for (int i = 0; i < numRows; i++) {\n            vector<int> tmp;\n            for (int j = 0; j <= i; j++) {\n                if (j == 0 || i == j)\n                    tmp.push_back(1);\n                else {\n                    tmp.push_back(res[i-1][j]+res[i-1][j-1]);\n                }\n            }\n            res.push_back(tmp);\n        }\n        return res;\n    }\n};\n```\n\n# 10 搜索插入位置\n\n给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。\n\n请必须使用时间复杂度为 `O(log n)` 的算法。\n\n**示例 1:**\n\n```\n输入: nums = [1,3,5,6], target = 5\n输出: 2\n```\n\n**示例 2:**\n\n```\n输入: nums = [1,3,5,6], target = 2\n输出: 1\n```\n\n**示例 3:**\n\n```\n输入: nums = [1,3,5,6], target = 7\n输出: 4\n```\n\n一眼便知是二分查找算法\n\n```cpp\nclass Solution {\npublic:\n    int searchInsert(vector<int>& nums, int target) {\n        int n = nums.size();\n        int l = 0,r = n-1;\n        int mid;\n        while(l <= r){\n            mid = (l + r) >> 1;\n            if(nums[mid] == target) break;\n            if(nums[mid] > target) r = mid - 1;\n            if(nums[mid] < target) l = mid + 1;\n        }\n        return nums[mid]==target?mid:l;\n    }\n};\n\n```\n\n# 11 二叉树的中序遍历\n\n给定一个二叉树的根节点 `root` ，返回 *它的 **中序** 遍历* 。\n\n**示例 1：**\n\n![img](LeetCode-top-100/inorder_1.jpg)\n\n```\n输入：root = [1,null,2,3]\n输出：[1,3,2]\n```\n\n**示例 2：**\n\n```\n输入：root = []\n输出：[]\n```\n\n**示例 3：**\n\n```\n输入：root = [1]\n输出：[1]\n```\n\n```cpp\nclass Solution {\npublic:\n    void mid_read(TreeNode* a, vector<int> & res){   \n       if(a->left != NULL){//左\n            mid_read(a->left, res);\n        }\n        res.push_back(a->val);//中\n        if(a->right != NULL){//右\n            mid_read(a->right, res);\n        }\n    }\n    vector<int> inorderTraversal(TreeNode* root) {\n        vector<int> res;\n        if(root != NULL) mid_read(root, res);\n        return res;\n    }\n};\n```\n\n# 12 全排列\n\n给定一个不含重复数字的数组 `nums` ，返回其 *所有可能的全排列* 。你可以 **按任意顺序** 返回答案。\n\n**示例 1：**\n\n```\n输入：nums = [1,2,3]\n输出：[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]\n```\n\n**示例 2：**\n\n```\n输入：nums = [0,1]\n输出：[[0,1],[1,0]]\n```\n\n**示例 3：**\n\n```\n输入：nums = [1]\n输出：[[1]]\n```\n\n \n\n```cpp\nclass Solution {\npublic:\n    vector<vector<int>> permute(vector<int>& nums) {\n        sort(nums.begin(),nums.end());\n        vector<vector<int>> res;\n        int N = nums.size();\n        do{\n            vector<int> tmp;\n            for(int i=0;i<N;i++){\n                tmp.push_back(nums[i]);\n            }\n            res.push_back(tmp);\n        }while(next_permutation(nums.begin(),nums.end()));\n\n        return res;\n    }\n};\n```\n\n","tags":["C++"]},{"title":"算法","url":"/2024/03/11/算法/","content":"\n# 1 排序算法\n\n- **稳定**：如果a原本在b前面，而a=b，排序之后a仍然在b的前面。\n\n![img](算法/849589-20180402133438219-1946132192.png)\n\n## 1.1 冒泡排序\n\n![img](算法/849589-20171015223238449-2146169197.gif)\n\n```cpp\n#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n#define N 10\nclass myPrint {\npublic:\n\tvoid operator()(int& val) {\n\t\tcout << val << \" \";\n\t}\n};\nint main(){\n\tvector<int> vec;\n\tsrand((unsigned int)time(NULL));\n\tfor (int i = 0; i < N; i++) {\n\t\tvec.push_back(rand());\n\t}\n\n\tfor (int i = 0; i < N; i++) {\n\t\tfor (int j = 0; j < N - i - 1; j++) {\n\t\t\tif (vec[j] < vec[j + 1]){\n\t\t\t\tint temp = vec[j];\n\t\t\t\tvec[j] = vec[j + 1];\n\t\t\t\tvec[j + 1] = temp;\n\t\t\t}\n\t\t}\n\t}\n\n\tfor_each(vec.begin(), vec.end(), myPrint());\n\tcout << endl;\n\n\treturn 0;\n}\n```\n\n## 1.2 选择排序\n\n首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，\n\n再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。\n\n以此类推，直到所有元素均排序完毕。 \n\n![img](算法/849589-20171015224719590-1433219824.gif)\n\n```cpp\n\tfor (int i = 0; i < N; i++) {\n\t\tint flag = i;\n\t\tfor (int j = i; j < N; j++) {\n\t\t\tif (vec[j] > vec[flag]) {\n\t\t\t\tflag = j;\n\t\t\t}\n\t\t}\n\t\tint temp = vec[flag];\n\t\tvec[flag] = vec[i];\n\t\tvec[i] = temp;\n\t}\n```\n\n## 1.3 插入排序\n\n- 从**第一个元素**开始，该元素可以认为已经被排序；\n- 在已经排序的元素序列中从后向前扫描；\n- 如果该元素（已排序）大于新元素，将该元素移到下一位置；\n\n![img](算法/849589-20171015225645277-1151100000.gif)\n\n```cpp\n\tfor (int i = 1; i < N; i++) {\n\t\tint current_i = i;\n\t\tint count = vec[i];\n\t\twhile (current_i > 0 && count < vec[current_i - 1]) {\n\t\t\tvec[current_i] = vec[current_i - 1];\n\t\t\tcurrent_i--;\n\t\t}\n\t\tvec[current_i] = count;\n\t}\n```\n\n## 1.4 希尔排序(Shell Sort)\n\n直接插入排序算法的一种更**高效**的改进版本\n\n把无序数组通过分组，分组之间比较进行移动，最后形成一个**有序数组** \n\n![在这里插入图片描述](算法/2135ce7a536f4353ba1ca61597b9fc62.gif)\n\n```cpp\n\tfor (int gap = N / 2; gap > 0; gap /= 2) {//为1的时候就不需要继续排序了\n\t\tfor (int i = 0; i < gap; i++) {\n\t\t\t//以下可以看作插入排序的实现\n\t\t\tfor (int j = i; j < N; j += gap) {\n\t\t\t\tint count = vec[j];\n\t\t\t\tint current_j = j;\n\t\t\t\twhile (current_j - gap >= 0 && count > vec[current_j-gap]) {\n\t\t\t\t\tvec[current_j] = vec[current_j - gap];\n\t\t\t\t\tcurrent_j -= gap;\n\t\t\t\t}\n\t\t\t\tvec[current_j] = count;\n\t\t\t}\n\t\t}\n\t}\n```\n\n## 1.5 归并排序\n\n将未排序的列表划分为n个子列表，每个子列表包含一个元素\n\n![img](算法/1024555-20161218163120151-452283750.png)\n\n![img](算法/1024555-20161218194508761-468169540.png)\n\n![img](算法/1024555-20161218194621308-588010220.png)\n\n```cpp\nvoid merge(vector<int> &arr, int* tmp, int left, int right) {\n\tif (left >= right)return;\n    //分\n\tint mid = (left + right) / 2;\n\tmerge(arr, tmp, left, mid);\n\tmerge(arr, tmp, mid + 1, right);\n\t//治\n    int begin_left = left;\n\tint end_left = mid;\n\tint begin_right = mid + 1;\n\tint end_right = right;\n\tint i = begin_left;\n\twhile (begin_left <= end_left && begin_right <= end_right) {\n\t\tif (arr[begin_left] > arr[begin_right]) {\n\t\t\ttmp[i++] = arr[begin_left++];\n\t\t}\n\t\telse {\n\t\t\ttmp[i++] = arr[begin_right++];\n\t\t}\n\t}\n\twhile (begin_left <= end_left) {\n\t\ttmp[i++] = arr[begin_left++];\n\t}\n\n\twhile (begin_right <= end_right) {\n\t\ttmp[i++] = arr[begin_right++];\n\t}\n\t//数据拷贝\n\tfor (int j = left; j <= right; j++) {\n\t\tarr[j] = tmp[j];\n\t}\n}\n\nvoid merge_sort(vector<int> &arr) {\n\tint* tmp = new int[arr.size()];\n\tif (tmp == NULL) {\n\t\tperror(\"内存分配错误，指针指向NULL\");\n\t\texit(-1);\n\t}\n\tmerge(arr, tmp, 0, arr.size() - 1);\n\tdelete[] tmp;\n}\n```\n\n## 1.6 快速排序（Quick Sort）\n\n**注意：**快排必须先从**右边**开始扫描，不然要出错。\n\nwhy？[https://www.cnblogs.com/cai170221/p/13558104.html](https://www.cnblogs.com/cai170221/p/13558104.html)\n\n\n\n### 1.6.1 挖坑法\n\n![20210515183213169.gif#pic_center](算法/20210515183213169.gif)\n\n```cpp\nvoid QuickSort(vector<int> &arr, int left, int right)\n{\n\tif (left >= right)return;\n\tint key = arr[left];\n\tint begin = left;\n\tint end = right;\n\tint flag = left;\n\twhile (begin < end) {\n\t\twhile (begin < end && arr[end] >= key) {\n\t\t\tend--;\n\t\t}\n\t\tarr[flag] = arr[end];\n\t\tflag = end;\n\t\twhile (begin < end && arr[begin] <= key) {\n\t\t\tbegin++;\n\t\t}\n\t\tarr[flag] = arr[begin];\n\t\tflag = begin;\n\t}\n\tarr[flag] = key;\n\tQuickSort(arr, left, flag - 1);\n\tQuickSort(arr, flag + 1, right);\n}\n```\n\n### 1.6.2 霍尔法\n\n![请添加图片描述](算法/77647f2bac1b4d32975d12a60208d443.gif)\n\n```cpp\nvoid QuickSort(vector<int>& arr, int left, int right) {\n    if (left >= right) return;\n    \n    int begin = left;\n    int end = right;\n    int key = arr[left];\n    \n    while (begin < end) {\n\n        while (begin < end && arr[end] >= key) {\n            end--;\n        }\n\t\twhile (begin < end && arr[begin] <= key) {\n\t\t\tbegin++;\n\t\t}\n        swap(arr[begin], arr[end]);\n    }\n    swap(arr[left], arr[begin]);\n    QuickSort01(arr, left, begin - 1);\n    QuickSort01(arr, begin + 1, right);\n}\n\n```\n\n# 2 快速幂与快速乘\n\n$$\n计算3^5\\\\\n(5)_H=(101)_2\\\\\n3^5 = 3^4*3^1\n$$\n\n\n\n```cpp\nint qpow(int a, int n){\n    int ans = 1;\n    while(n){\n        if(n&1)        //如果n的当前末位为1\n            ans *= a;  //ans乘上当前的a\n        a *= a;        //a自乘\n        n >>= 1;       //n往右移一位\n    }\n    return ans;\n}\n```\n\n取模运算规则：\n\n```cpp\n(a + b) % p = (a % p + b % p)%p\n(a - b) % p = (a % p - b % p)%p\n(a * b) % p = ((a % p) * (b % p))%p\n(a ^ b) % p = ((a % p)^b) %p \n```\n\n$$\n计算3^{15}\\%7\n$$\n\n```cpp\nint qpow(int a, int n){\n\tint ans = 1;\n    while(n){\n        if(n&1) ans = (ans * a)%7;\n        a = (a * a)%7;\n        n>>=1;\n    }\n    return ans;\n}\n```\n\n同理，快速乘有类似的算法\n\n```cpp\nint qcg(int a, int b, int p)\n{\n\tint res = 0;\n\twhile (b)\n\t{\n\t\tif (b & 1)res = ((LL)res + a) % p;\n\t\ta = ((LL)a + a) % p;\n\t\tb >>= 1;\n\t}\n\treturn res;\n}\n```\n\n# 3 KMP字符串匹配\n\n### **最长相等前后缀：**\n\n```\n例1：aba\n前缀：a，ab\n后缀：a, ba\n最长相等前后缀：a，最长相等前后缀长度是1\n\n例2：aaaa\n前缀：a，aa, aaa\n后缀：a , aa, aaa\n最长相等前后缀：aaa，最长相等前后缀长度是3\n```\n\n### **next数组：**\n\n数组每一位记录**匹配串**到当前为止的**最长相等前后缀长度**\n\n```\n匹配串：a b a b c a b a b a\n\t   0 0 1 2 0 1 2 3 4 3\n```\n\n```cpp\nvoid get_next(const string str, int* next) {\n    int j = 0;\n    next[0] = 0;\n    for (int i = 1; i < str.size(); i++) {\n        //前后缀不相同怎么处理\n        while (j > 0 && str[i] != str[j]) j = next[j - 1];\n        //前后缀相同怎么处理\n        if (str[i] == str[j]) j++;     \n        \n        next[i] = j;\n    }\n}\n```\n\n### KMP\n\n```cpp\n#include <iostream>\nusing namespace std;\nvoid get_next(const string str, int* next) {\n    int j = 0;\n    next[0] = 0;\n    for (int i = 1; i < str.size(); i++) {\n        //前后缀不相同怎么处理\n        while (j > 0 && str[i] != str[j]) j = next[j - 1];\n        //前后缀相同怎么处理\n        if (str[i] == str[j]) j++;     \n        \n        next[i] = j;\n    }\n}\nint kmp(const string& str, const string& ptr, const int* next) {\n    int j = 0;\n    for (int i = 0; i < str.size(); i++) {\n        while (j > 0 && str[i] != ptr[j])j = next[j - 1];\n        if (str[i] == ptr[j])j++;\n        if (j == ptr.size())return i - j + 1;\n    }\n    return -1;\n}\nint main() {\n    string str = \"ababcababcababdababcababa\";\n    string ptr = \"ababcababa\";\n    int next[13] = { 0 };\n    get_next(ptr, next);\n    cout << kmp(str, ptr, next);\n}\n```\n\n# 4 二分查找算法\n\n```cpp\n##include <iostream>\nusing namespace std;\n\nint main()\n{\n\tint a[] = { 1,2,4,6,12,13,18,22,28,31 };\n\tint key = 31;//查找关键字\n\tint low = 0;\n\tint high = sizeof(a)/sizeof(a[0]);\n\n\twhile (low <= high) {\n\t\tint mid = (low + high) / 2;\n\t\tif (a[mid] == key) {\n\t\t\tcout << \"找到\" << endl;\n\t\t\tbreak;\n\t\t}\n\t\tif (a[mid] > key)high = mid-1;\n\t\telse if (a[mid] < key)low = mid+1;\n\t}\n\tif (low > high)cout << \"未找到\" << endl;\n\treturn 0;\n}\n\n```\n\n# 5 深度优先搜索【DFS】\n\n在一个 w×h 的矩形广场上，每一块 1×1 的地面都铺设了红色或黑色的瓷砖。小林同学站在某一块黑色的瓷砖上，他可以从此处出发，移动到上、下、左、右四个相邻的且是黑色的瓷砖上。现在，他想知道，通过重复上述移动所能经过的黑色瓷砖数。\n\n【输入格式】\n\n第 1 行为 h、w，2≤w、h≤50，之间由一个空格隔开。  \n\n以下为一个 w 行 h 列的二维字符矩阵，每个字符为“.”“#”“@”，分别表示该位置为黑色的瓷砖、红色的瓷砖，以及小林的初始位置。\n\n【输出格式】\n\n输出一行一个整数，表示小林从初始位置出发可以到达的瓷砖数。\n\n【输入输出样例】\n\n11 9\n\n.#.........\n\n.#.#######.\n\n.#.#.....#.\n\n.#.#.###.#.\n\n.#.#..@#.#.\n\n.#.#####.#.\n\n.#.......#.\n\n.#########.\n\n...........\n\n```cpp\n#include <iostream>\nusing namespace std;\nint m, n, x, y, nx, ny, sum = 1;\nint cx[4] = { 0,0,1,-1 };\nint cy[4] = { 1,-1,0,0 };\nchar ma[23][23];\nint mo[23][23];\nvoid dfs(int sx, int sy)\n{\n\tfor (int i = 0; i < 4; i++)\n\t{\n\t\tnx = sx + cx[i];\n\t\tny = sy + cy[i];\n\t\tif (nx >= 0 && nx <= m && ny >= 0 && ny <= n && mo[nx][ny] == 0 && ma[nx][ny] == '.')\n\t\t{\n\t\t\tsum++;\n\t\t\tmo[nx][ny] = 1;\n\t\t\tdfs(nx, ny);\n\t\t\tmo[nx][ny] = 0;\n\t\t}\n\t}\n}\nint main()\n{\n\tcin >> n >> m;\n\tfor (int i = 0; i < m; i++)\n\t{\n\t\tfor (int j = 0; j < n; j++)\n\t\t{\n\t\t\tcin >> ma[i][j];\n\t\t\tif (ma[i][j] == '@')\n\t\t\t{\n\t\t\t\tx = i;\n\t\t\t\ty = j;\n\t\t\t}\n\t\t}\n\t}\n\tdfs(x, y);\n\n\tcout << sum;\n\treturn 0;\n}\n```\n\n# 6 广度优先搜索【BFS】\n\n```cpp\nint cx[4]={0,0,-1,1};\nint cy[4]={1,-1,0,0};\nint bfs(int sx,int sy){\n    int cnt = 0;\n    q.push(node{sx,sy,0});//压入队列\n    \n    while(!q.empty()){//队列不为空\n        node p=q.top();//取出队列第一个元素\n        q.pop();//弹出\n        if(p.x == ex,p.y == ey){//找到终点然后直接返回路径的长度\n            return p.k;\n        }\n        \n        if(vis[p.x][p.y]) continue;//已去过\n        \n        vis[p.x][p.y] = true;//标记已去过\n        \n        for(int i=0;i < 4;++i){\n            int nx = x + cx[i];\n            int ny = y + cy[i];\n            if( check(nx,ny) ){\n                q.push(node{nx,ny,p.k+1});\n            }\n        }\n    }\n    return -1;//没有路径的\n}\n\n```\n\n","tags":["C++"]},{"title":"套接字Soket网络编程","url":"/2024/03/08/套接字Soket网络编程/","content":"\n# 1 前序知识\n\n## 1.1 局域网和广域网\n\n**局域网：**将一定区域内的设备（计算机、外部设备、数据库等）连接起来形成的计算机通信的私有网络\n\n**广域网：**又称为外网和公网。连接不同地区局域网或城域网的远程公用网络\n\n## 1.2 IP地址\n\n分为`ipv4`和`ipv6`地址\n\n### 1.2.1 IPv4\n\n- 使用一个32位的整型数表示一个IP地址，4字节，int型\n- 使用点分十进制表示IP地址：`192.168.1.1`\n- 分成了4份，每份1字节(8bit)，最大值为255\n\n因此，一共可用IP地址 2^32^ 个\n\n### 1.2.2 IPv6\n\n- 使用128位表示一个IP地址，16字节\n- 使用字符串描述IP：`2001:0db8:3c4d:0015:0000:0000:1a2f:1a2b`\n- 分成了8份，每份2字节，每一部分都按16进制表示\n\n共2^128^个可用IP地址\n\n## 1.3 端口\n\n端口的作用是定位主机上的一个进程，进程可以通过这个端口进行网络通信\n\n端口是一个短整型无符号数`usigned short`，16位有效数，范围`0~65535`\n\n**注意：**\n\n- 并不是所有进程都需要绑定端口，如果某个进程不需要网络通信，就无需绑定\n- 一个端口只能给一个进程使用，**不能多进程公用**\n\n## 1.4 网络分层模型\n\n[ISO/OSI网络模型-哔哩哔哩讲解](https://www.bilibili.com/video/BV1EU4y1v7ju/?spm_id_from=333.337.search-card.all.click&vd_source=10960c964c9089624e6f92b8d20ed3e0)\n\n![image-20240308220727062](套接字Soket网络编程/image-20240308220727062.png)\n\n**数据流通过程：**\n\n![image-20240308235500469](套接字Soket网络编程/image-20240308235500469.png)\n\n------\n\n![image-20240309000750086](套接字Soket网络编程/image-20240309000750086.png)\n\n- **物理层**：数据比特流的传输\n- **数据链路层**：负责将数据分帧和封装成帧，并进行差错控制和流量控制，提供介质访问和链路管理。\n- **网络层**：IP选址及路由选择。\n- **传输层：**建立端到端的连接\n- **会话层**：建立、管理和维护表示层实体的会话。\n- **表示层**：数据格式转化，对数据进行加密。\n- **应用层**：为应用程序提供服务。\n\n## 1.5 三次握手四次挥手\n\nTCP协议是一个**可靠的**、**面向连接的**流式传输协议，所谓的面向连接就是三次握手\n\n![img](套接字Soket网络编程/1460000039165594.png)\n\n![img](套接字Soket网络编程/1460000039165595.png)\n\n- `SYN`：连接请求/接收 报文段\n- `seq`：发送的第一个字节的序号\n- `ACK`：确认报文段\n- `ack`：确认号。希望收到的下一个数据的第一个字节的序号\n\n### 1.5.1 为什么是三次握手？\n\n三次握手的作用：**确认双方连接正常。**\n\n1. 第一次握手：Client 什么都不能确认；Server 确认了对方发送正常，自己接收正常\n2. 第二次握手：Client 确认了：自己发送、接收正常，对方发送、接收正常；Server 确认了：对方发送正常，自己接收正常\n3. 第三次握手：Client 确认了：自己发送、接收正常，对方发送、接收正常；Server 确认了：自己发送、接收正常，对方发送、接收正常\n\n如果不采用三次握手，客户端发送连接请求，但是网络产生了延迟，此时客户端可能会认为连接未能建立成功，又重新发起了新的连接请求。服务器接收到客户端发来的两个连接请求都给予了回应确认，就会建立两个相互独立的连接。导致资源浪费和数据混乱。\n\n### 1.5.2 为什么是四次挥手？\n\n四次挥手的作用：**确保双方都能够安全地关闭TCP连接**\n\n 1、客户端执行主动关闭，发送 FIN的包（FIN），表示客户端的数据发送完毕。\n\n 2、服务端执行被动关闭，发送确认 ACK 包。\n\n 3、服务端给客户端发送 FIN，告诉客户端我也要关闭。\n\n 4、客户端确认服务端的ACK的包，确认服务端关闭。\n\n### 1.5.3 2MSL的作用？\n\n**MSL是报文的最大生存时间**（单向数据传输最大有效时间，根据跳数设定值）\n\nTIME_WAIT状态也就是2MSL等待状态。\n\n客户端发出的第四次挥手ACK报文，最大有效时间为MSL，也就是说必须在MSL的时间内达到服务端。超过这个时间服务端就会重传第三次挥手的FIN报文，相同的必须在MSL时间内到达。\n\n若出现ACK报文丢失，客户端在发出第四次挥手ACK报文和接收到重传的第三次挥手FIN报文的时间间隔就为2MSL。\n\n所以等待2MSL是确保连接双方关闭完成。\n\n# 2 网络编程\n\n![img](套接字Soket网络编程/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3BvbGFyaXNfMTE5,size_16,color_FFFFFF,t_70.png)\n\n## 2.1 创建socket\n\n```cpp\nint socket(int domain, int type, int protocal);\n```\n\n- **domain** 通信的协议家族\n  - <u>PF_INET：ipv4</u>\n  - PF_INET6：ipv6\n  - PF_LOCAL：本地通信的协议族\n  - PF_PACKET：内核底层协议族\n  - PF_IPX：IPX Novell协议族\n-  **type** 数据传输的类型\n  - SOCK_STREAM：面向连接的socket\n  - SOCK_DGRAM：无连接的socket\n- **protocal** 最终使用的协议\n  - IPPROTO_TCP\n  - IPPROTO_UDP\n  - 可以填0，编译器会自动识别类型\n\n```cpp\nsocket(PF_INET, SOCK_STREAM, 0);\nsocket(PF_INET, SOCK_STREAM, IPPROTO_TCP)//等效\n\nsocket(PF_INET, SOCK_DEGRAM, 0);\nsocket(PF_INET, SOCK_DEGRAM, IPPROTO_UDP);\n```\n\n返回值：\n\n- 成功：返回对应的sockfd文件描述符\n- 失败：返回-1\n\n## 2.2 主机字节序和网络字节序\n\n大端序：低位字节存放在高位，高位字节存放在低位\n\n```cpp\n0x001\t0x12\n0x002\t0x34\n0x003\t0x56\n存放123456\n```\n\n小端序：低位字节存放在低位，高位字节存放在高位\n\n```cpp\n0x001\t0x56\n0x002\t0x34\n0x003\t0x12\n```\n\n小端序更便于CPU进行处理，大端序便于人类查看\n\n### 2.2.0 相关函数\n\n不同的主机可能是采用不同的字节序，因此出现了**网络字节序**，本质上是大端序\n\n#### 2.2.0.1 htons/htonl\n\n```cpp\n#include <arpa/inet.h>　\nuint16_t htons(uint16_t hostshort);\nuint32_t htonl(uint32_t hostlong);\n\nuint16_t ntohs(uint16_t netshort);\nuint32_t ntohl(uint32_t netlong);\n```\n\n- h：host 主机\n- to：转换\n- n：network 网络\n- s：short（2字节，16位整数）\n- l：long（4字节，32位整数）\n\n长整型用于转换IP地址，短整型用于转换端口号，但平时IP地址都是用点分十进制形式表示，因此，需要使用其他函数将点分十进制转换为整数型\n\n#### 2.2.0.2 inet_pton 和 inet_ntop\n\np：people read人类可读\n\n```cpp\nint inet_pton(int af, const char *src, void *dst);\n```\n\n- af：协议族，AF_INET或AF_INET6\n- src：点分十进制的地址\n- dst：接收转换后的数据\n\n返回值：\n\n- 成功：1\n- 失败：负数\n- 格式不对：0\n\n```cpp\nchar *inet_ntop(int af, const void *src, char *dst, size_t len);\n```\n\n- af：AF_INET或AF_INET6\n- src：指向网络字节序的指针\n- dst：指向转换后的字符串指针\n- len：目标大小，防止溢出\n\n返回值：\n\n- 成功：结果指针\n- 出错：NULL\n\n\n\nIPv4地址采用4字节的整数存放，端口号用2字节的整数存放（0~65536）\n\n### 2.2.1 结构体\n\n#### 2.2.1.1 sockaddr 结构体\n\n存放协议族、端口和地址信息，客户端`connect()`和服务端`bind()`需要此结构体\n\n```cpp\nstruct sockaddr{\n\tunsigned short sa_family; \n    //协议族，AF_INET,和socket()的第一个参数相同，\n    //AF和PF数值上没区别，可以混用\n    unsigned char sa_data[14];\n    //14字节的端口和地址\n}\n```\n\n#### 2.2.1.2 sockaddr_in 结构体\n\nsockaddr结构体操作不方便，所以出现了sockaddr_in\n\n两者大小相等，因此可以进行强制类型转换\n\n```cpp\nstruct sockaddr_in{\n\tunsigned short sin_family;//协议族\n    unsigned short sin_port;//16位端口号\n    struct in_addr sin_addr; //32位的地址\n    unsigned char sin_zero[8]; //未使用，为了保持与sockaddr长度一样而设置\n}\n\nstruct in_addr{\n    unsigned int s_addr;//32位的地址\n}\n```\n\n## 2.3 bind函数\n\n```cpp\nint bind(int sockfd, struct sockaddr* addr, socklen_t addrlen);\n```\n\n- **sockfd**：服务端监听文件描述符\n- **addr**：包含ip地址和端口号的sockaddr结构体\n- **addrlen**：第二个参数（结构体）的长度（sizeof）\n\n## 2.4 listen函数\n\n```cpp\nint listen(int sockfd, int backlog);\n```\n\n- **sockfd**：服务端文件描述符\n- **backlog**：最大连接数目\n\n## 2.5 connect函数\n\n```cpp\nint connect(int sockfd, struct sockaddr* addr, socklen_t addrlen);\n```\n\n- **sockfd**：客户端通信文件描述符\n- **addr**：包含ip地址和端口号的sockaddr结构体\n- **addrlen**：第二个参数（结构体）的长度（sizeof）\n\n## 2.6 accept函数\n\n```cpp\nint accept(int sockfd, struct sockaddr* addr, socklen_t* addrlen);\n```\n\n- sockfd：服务端监听文件描述符\n- addr：传出参数，记录连接成功的客户端信息地址和端口号\n- addrlen：第二个参数的长度\n\n返回值：\n\n- 成功：服务端用于通信的文件描述符\n- 失败：-1\n\n## 2.7 read、write函数\n\n```cpp\nssize_t write(int fd, const void *buf, size_t count);      // 写数据 \nssize_t read(int fd, void *buf, size_t count);             // 读数据\n```\n\n网络I/O操作不止是read和write\n\n```cpp\nread()/write()\nrecv()/send()\nreadv()/writev()\nrecvmsg()/sendmsg()\nrecvfrom()/sendto()\n```\n\n声明如下\n\n```cpp\nssize_t read(int fd, void *buf, size_t count);\nssize_t write(int fd, const void *buf, size_t count);\n \nssize_t send(int sockfd, const void *buf, size_t len, int flags);\nssize_t recv(int sockfd, void *buf, size_t len, int flags);\n \nssize_t sendto(int sockfd, const void *buf, size_t len, int flags,\n\t\t\t  const struct sockaddr *dest_addr, socklen_t addrlen);\nssize_t recvfrom(int sockfd, void *buf, size_t len, int flags,\n\t\t\t\tstruct sockaddr *src_addr, socklen_t *addrlen);\n \nssize_t sendmsg(int sockfd, const struct msghdr *msg, int flags);\nssize_t recvmsg(int sockfd, struct msghdr *msg, int flags);\n```\n\n## 2.8 close函数\n\n```cpp\nint close(int fd);\n```\n\n## 2.9 实例\n\n### 2.9.1 客户端\n\n```cpp\n#include<stdio.h>\n#include<stdlib.h>\n#include<errno.h>\n#include<string.h>\n#include<sys/types.h>\n#include<netinet/in.h>\n#include<sys/socket.h>\n#include<sys/wait.h>\n \n#define SERVER_PORT 8888\n \nint main()\n{\n \n   //客户端只需要一个套接字文件描述符，用于和服务器通信\n   int serverSocket;\n    \n   //描述服务器的socket\n   struct sockaddr_in serverAddr;\n    \n   char sendbuf[200]; //存储 发送的信息 \n   char recvbuf[200]; //存储 接收到的信息 \n    \n   int iDataNum;\n   \n \n  /*********************************************************************/\n  /*                          1-创建客户端套接字                        */\n  /*********************************************************************/\n   if((serverSocket = socket(AF_INET,SOCK_STREAM,IPPROTO_TCP)) < 0)\n   {\n      perror(\"socket\");\n      return 1;\n   }\n    \n   serverAddr.sin_family = AF_INET;\n   serverAddr.sin_port = htons(SERVER_PORT);\n    \n   //指定服务器端的ip，本地测试：127.0.0.1\n   //inet_addr()函数，将点分十进制IP转换成网络字节序IP\n   serverAddr.sin_addr.s_addr = inet_addr(\"127.0.0.1\");\n  \n  /*********************************************************************/\n  /*                          2-连接服务端                              */\n  /*********************************************************************/  \n   if(connect(serverSocket, (struct sockaddr *)&serverAddr, sizeof(serverAddr)) < 0)\n   {\n      perror(\"connect\");\n      return 1;\n   }\n    \n   printf(\"连接到主机...\\n\");\n    \n  /*********************************************************************/\n  /*                          3-发送接收消息                            */\n  /*********************************************************************/ \n   while(1)\n   {\n      printf(\"发送消息:\");\n      scanf(\"%s\", sendbuf);\n      printf(\"\\n\");\n      write(serverSocket, sendbuf, strlen(sendbuf)); //向服务端发送消息\n      if(strcmp(sendbuf, \"quit\") == 0) break;\n      printf(\"读取消息:\");\n      recvbuf[0] = '\\0';\n      iDataNum = read(serverSocket, recvbuf, 200); //接收服务端发来的消息\n      recvbuf[iDataNum] = '\\0';\n      printf(\"%s\\n\", recvbuf);\n   }\n \n   close(serverSocket);\n   \n   return 0;\n}\n```\n\n### 2.9.2 服务端\n\n```cpp\n#include <stdio.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <string.h>\n#include <sys/types.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <sys/wait.h>\n#include <arpa/inet.h>\n \n#define SERVER_PORT 8888\n \n/*\n监听后，一直处于accept阻塞状态，\n直到有客户端连接，\n当客户端如close后，断开与客户端的连接\n*/\n \nint main()\n{\n   \n   //调用socket函数返回的文件描述符\n   int serverSocket;\n    \n   //声明两个套接字sockaddr_in结构体变量，分别表示客户端和服务器\n   struct sockaddr_in server_addr;\n   struct sockaddr_in clientAddr;\n    \n   int addr_len = sizeof(clientAddr);\n   int clientSocket;\n   char buffer[200]; //存储 发送和接收的信息 \n   int iDataNum;\n \n   \n  /*********************************************************************/\n  /*                          1-创建服务端套接字                        */\n  /*********************************************************************/\n   if((serverSocket = socket(AF_INET,SOCK_STREAM,IPPROTO_TCP)) < 0)\n   {\n      perror(\"socket\");\n      return 1;\n   }\n   memset(&server_addr,0, sizeof(server_addr));\n    \n   //初始化服务器端的套接字，并用htons和htonl将端口和地址转成网络字节序\n   server_addr.sin_family = AF_INET;\n   server_addr.sin_port = htons(SERVER_PORT);\n    \n   //ip可是是本服务器的ip，也可以用宏INADDR_ANY代替，代表0.0.0.0，表明所有地址\n   server_addr.sin_addr.s_addr = htonl(INADDR_ANY);\n \n \n \n   //对于bind，accept之类的函数，里面套接字参数都是需要强制转换成(struct sockaddr *)\n   //bind三个参数：服务器端的套接字的文件描述符\n  /*********************************************************************/\n  /*                          2-服务端绑定监听的IP和por                  */\n  /*********************************************************************/  \n   if(bind(serverSocket, (struct sockaddr *)&server_addr, sizeof(server_addr)) < 0)\n   {\n      perror(\"connect\");\n      return 1;\n   }\n    \n \n  /*********************************************************************/\n  /*                          3-服务端开始监听                          */\n  /*********************************************************************/ \n   if(listen(serverSocket, 5) < 0)//开启监听 ，第二个参数是最大监听数\n   {\n      perror(\"listen\");\n      return 1;\n   }\n   \n  /*********************************************************************/\n  /*                          4-接收发送消息                            */\n  /*********************************************************************/  \n  printf(\"监听端口: %d\\n\", SERVER_PORT);\n  \n  //调用accept函数后，会进入阻塞状态\n  //accept返回一个套接字的文件描述符，这样服务器端便有两个套接字的文件描述符，\n  //serverSocket和client。\n  //serverSocket仍然继续在监听状态，client则负责接收和发送数据\n  //clientAddr是一个传出参数，accept返回时，传出客户端的地址和端口号\n  //addr_len是一个传入-传出参数，传入的是调用者提供的缓冲区的clientAddr的长度，以避免缓冲区溢出。\n  //传出的是客户端地址结构体的实际长度。\n  //出错返回-1\n  \n  clientSocket = accept(serverSocket, (struct sockaddr*)&clientAddr, (socklen_t*)&addr_len);\n  \n  if(clientSocket < 0)\n  {\n     perror(\"accept\");\n     \n  }\n   \n  printf(\"等待消息...\\n\");\n  \n  //inet_ntoa ip地址转换函数，将网络字节序IP转换为点分十进制IP\n  //表达式：char *inet_ntoa (struct in_addr);\n  printf(\"IP is %s\\n\", inet_ntoa(clientAddr.sin_addr)); //把来访问的客户端的IP地址打出来\n  printf(\"Port is %d\\n\", htons(clientAddr.sin_port)); \n   \n  while(1)\n  {\n       buffer[0] = '\\0';\n       iDataNum = read(clientSocket, buffer, 1024);\n       if(iDataNum < 0)\n       {\n          continue;\n       }\n       buffer[iDataNum] = '\\0';\n       if(strcmp(buffer, \"quit\") == 0) break;\n       printf(\"收到消息: %s\\n\", buffer);\n       printf(\"发送消息:\");\n       scanf(\"%s\", buffer);\n       write(clientSocket, buffer, strlen(buffer)); //服务端也向客户端发送消息 \n       if(strcmp(buffer, \"quit\") == 0) break; //输入quit停止服务端程序 \n  }\n \n   close(clientSocket);\n   close(serverSocket);\n   \n   return 0;\n    \n}\n```\n\n","tags":["C++"]},{"title":"STL","url":"/2024/03/08/STL/","content":"\n# 1 STL初识\n\n## 1.1 STL基本概念\n\nSTL（Standard Template Library）**标准模板库**\n\nSTL从广义上分为：**容器(container) 算法(algorithm) 迭代器(iterator)**\n\n**容器**和**算法**之间通过**迭代器**进行无缝连接\n\n## 1.2 STL六大组件\n\n**容器、算法、迭代器、仿函数、适配器、空间配置器**\n\n- 容器：各种数据结构，如vector、list、deque、set、map等，用来存放数据\n- 算法：各种常用算法，如sort、find、copy、for_each等\n- 迭代器：扮演了容器与算法之间的胶合剂\n- 仿函数：行嘞类似函数，可作为算法的某种策略\n- 适配器：用来修饰容器或仿函数或迭代器接口的东西。\n- 空间配置器：负责空间配置和管理\n\n## 1.3 算法和迭代器\n\n### 1.3.1 算法\n\n- 质变算法：运算过程会更改区间内的元素内容，如拷贝、替换、删除等\n- 非质变算法：运算过程不会改变区间内的元素内容，如查找，计数，遍历等\n\n### 1.3.2 迭代器\n\n每一个容器都有属于自己的迭代器（迭代器与指针非常类似）\n\n![image-20240308164731980](STL/image-20240308164731980.png)\n\n常用的容器迭代器类型为**双向迭代器**和**随机访问迭代器**\n\n```cpp\n#include <vector>\n#include <algorithm>\nvoid myPrint(int val){\n    cout << val;\n}\nvoid main(){\n    vector<int> a;\n    a.push_back(10);\n    vector<int>::iterator itBegin = v.begin();\n    vector<int>::iterator itEnd = v.end();\n    //第一种遍历方式\n    while(itBegin!=itEnd){\n        cout<<*itBegin<<endl;\n        itBegin++;\n    }\n    //第二种遍历方式\n    for(vector<int>::iterator it = v.begin(); it!=v.end(); it++){\n        cout<<*it<<endl;\n    }\n    //第三种遍历方式\n    for_each(v.begin(), v.end(), myPrint);\n}\n```\n\n# 2 STL常用容器\n\n## 2.1 string容器\n\nstring本质上是一个类，是C++风格的字符串\n\n**string 和 char *的区别**\n\n- char *是一个指针\n- string是一个类，类的内部封装了char *，管理这个字符串\n\n### 2.1.1 string的构造函数\n\n- `string();`\t\t\t\t\t\t\t\t\t//创建一个空字符串\n- `string(const char* s);`\t\t//使用字符串s初始化\n- `string(const string& str);`//使用string对象初始化\n- `string(int n, char c);`\t\t//使用n个字符c初始化\n\n```cpp\n//括号法\nstring s1;\nstring s2(\"vicczyq\");\nstring s3(s2);\nstring s4(10,'1');\n\n//显示法\nstring s1 = string(\"vicczyq\");\n\n//隐式转换法\nstring s1 = \"vicczyq\";\nstring s2 = s1;\n```\n\n### 2.1.2 string赋值操作\n\n```cpp\nstring &operator=(const char *s);\nstring &operator=(const string &s);\nstring &operator=(char c);//把一个字符赋值给string\nstring &assign(const char *s);\nstring &assign(const char *s, int n);//把前n个字符赋值给string\nstring &assign(const string &s);\nstring &assign(int n,char c);\n```\n\n```cpp\nstring s1,s2,s3;\ns1 = \"vicczyq\";\ns2 = s1;\ns3 = 'a';\ns1.assign(\"vicczyq\");\ns1.assign(\"vicczyq\",2);\ns1.assign(s2);\ns1.assgin(10,'a');\n```\n\n### 2.1.3 string拼接\n\n```cpp\nstring &operator+=(const char *s);\nstring &operator+=(const char c);\nstring &operator+=(const string &s);\nstring &append(const char *s);\nstring &append(const char c);\nstring &append(const string &s);\nstring &append(const string &s, int pos, int n);\n//字符串s中从pos开始的n个字符连接到末尾\n```\n\n### 2.1.4 string查找和替换\n\n```cpp\nint find(const string &str, int pos = 0) const;\n\n//查找s的前n个字符第一次出现的位置\nint find(const char* s,int pos=0, int n)const;\n\n//查找str最后出现的位置\nint rfind(const string &str, int pos = npos)const;\n\n//从pos开始查找s的前n个字符最后一次出现的位置\nint rfind(const char* s,int pos, int n)const;\n```\n\n```cpp\nstring &replace(int pos, int n, const string &str);\n//从pos开始n个字符替换为str\n```\n\n**巧记：**“字符串在前为查找，在后为替换，所以是查找和替换”\n\n### 2.1.5 stirng字符串比较\n\n根据字符串ASCII码值进行比较\n\n**等于**返回0，**大于**返回1，**小于**返回-1\n\n函数原型：\n\n- int compare(const string &s)const;\n- int compare(const char *s);\n\n```cpp\nstring s1 = \"vicczyq\", s2=\"vicczyq\";\nif(s1.compare(s2)==0)cout<<\"yes!\"<<endl;\n```\n\n也可以用运算符重载\n\n```cpp\nif(s1==s2)cout<<\"yes\"<<endl;\n```\n\n### 2.1.6 string字符存取\n\n有两种方式：\n\n- `char &operator[](int n)`\n- `char &at(int n)`\n\n取：\n\n```cpp\nstring s1=\"vicczyq\";\ncout<<s1[0]<<endl;\ncout<<s1.at(0)<<endl;\n```\n\n存：\n\n```cpp\ns1[0]='V';\ns1.at(0)='v';\n```\n\n### 2.1.7 string插入和删除\n\n- `string& insert(int pos, const char* s)`\t\t\t//插入字符串\n- `string& inster(int pos, const string &str)`\n- `string& insert(int pos, int n, char c)`\t\t\t//在指定位置插入n个c\n- `string& erase(int pos, int n=npos)`\t\t\t\t\t//删除从pos开始的n个字符\n\n### 2.1.8 string子串获取\n\n`string substr(int pos=0, int n=npos)const;`\n\n//从pos开始，多少个字符作为子串，返回\n\n### 2.1.9 string迭代器\n\n```cpp\n\tstring str = \"vicczyq\";\n\tfor(string::iterator it = str.begin(); it != str.end(); it++){\n\t\tcout << *it << endl;//vicczyq\n\t}\n\tfor (string::reverse_iterator it = str.rbegin(); it != str.rend(); it++){\n\t\tcout << *it << endl;//qyzcciv\n\t}\n```\n\n## 2.2 vector容器\n\nvector数据结构和数组非常相似，也成为**单端数组**\n\n普通数组用的是静态空间，而vector采用**动态扩展**\n\n### 2.2.0 动态扩展\n\n动态扩展并不是在元空间的基础上续接新空间，而是找到更大的内存空间，将原数据拷贝到新空间，并释放原空间。\n\n可能会多扩展一些，具体是STL内部算法实现。\n\n### 2.2.1 基本结构\n\n采用模板类实现的。\n\n![image-20240309123617832](STL/image-20240309123617832.png)\n\n```cpp\nvector<T> v;\t//默认构造\nvector<T> v1(v.begin(),v.end());//区间拷贝构造\nvector<T> v2(n, elem);//将n个elem拷贝给本身\nvector<T> v3(const vector &vec);//拷贝构造\n```\n\n### 2.2.2 赋值操作\n\n```cpp\nvector &operator=(const vector &vec);//重载等号赋值\nassign(beg, end); //将[beg,end)之间的数据拷贝赋值给自身\nassign(n, elem);//将n个elem赋值给本身\n```\n\n```cpp\nvector<int> v1(10,100),v2;\nv2 = v1;\nv2.assign(v1.begin(),v1.end());\nv2.assign(10,100);\n```\n\n### 2.2.3 容量和大小\n\n```cpp\nempty();\t\t\t\t\t//判断是否为空\ncapacity()\t\t\t\t\t//容器容量\nsize()\t\t\t\t\t\t//容器中元素个数\nresize(int num);\t\t//重新指定容器的长度为num，若容器变短，末尾超出的元素会被删除，若变长则以默认值填充\nresize(int num, elem);\t//重新指定容器的长度为num，若容器变短，末尾超出的元素会被删除，若变长则以elem填充新位置\n```\n\n### 2.2.4 插入和删除\n\n```cpp\npush_back(elem);\t\t\t\t\t//尾部插入elem\npop_back();\t\t\t\t\t\t\t//删除最后一个元素\ninsert(const_iterator pos, elem);\t\t\t//向迭代器指向的pos位置插入elem\ninsert(const_iterator pos, int n, elem);\t//向迭代器指向的位置插入n个elem\nerase(const_iterator pos);\t\t\t\t\t//删除迭代器指向的元素\nerase(const_iterator start, const_iterator end);//删除区间内的元素\nclear();\t\t\t\t\t\t\t\t\t//删除容器内所有元素\n```\n\n### 2.2.5 数据存取\n\n```cpp\nat(int idx);\t//返回索引idx所指的数据\noperator[];\t\t\nfront();\t\t//返回第一个数据元素\nback();\t\t\t//返回最后一个数据元素\n```\n\n### 2.2.6 vector互换容器\n\n```cpp\nswap(vec);\t\t//将vec与本身的元素进行互换\n```\n\n**实际用途：**巧用swap可以收缩内存空间\n\n解释：\n\n```cpp\nfor(int i=0; i<100000; i++){\n\tv.push_back(i);\n}\ncout << \"v的容量：\"<< v.capacity() << endl;\ncout << \"v的大小：\"<< v.size() << endl;\n```\n\n![image-20240309131309430](STL/image-20240309131309430.png)\n\n虽然只存入了10000个数据，但是vector会多扩展一些内存空间\n\n```cpp\n//此时使用\nv.resize(3);\ncout << \"v的容量：\"<< v.capacity() << endl;\ncout << \"v的大小：\"<< v.size() << endl;\n```\n\n![image-20240309131553262](STL/image-20240309131553262.png)\n\n容量并不会变小，这样会导致**空间过于浪费**\n\n```cpp\nvector<int>(v).swap(v);\n```\n\n![image-20240309132257980](STL/image-20240309132257980.png)\n\n`vector<int>(v1)`为匿名对象，通过拷贝构造创建，创建时会按照v的元素个数进行设置容量，再和v进行交换。\n\n如果新创建一个普通对象来交换会存在更大的空间浪费，但是匿名对象就可以解决\n\n**匿名对象：**当前行执行完成，系统会自动进行回收\n\n### 2.2.7 vector预留空间\n\n```cpp\nreserve(int len);//容器预留len个元素长度，预留位置不会初始化，元素不可访问\n```\n\n可以减少内存重新分配的次数\n\n```cpp\n\tvector<int> v;\n\tint num = 0;\n\tint* p = NULL;\n\tfor (int i = 0; i < 1e6; i++) {\n\t\tv.push_back(i);\n\t\tif (p != &v[0]) {\n\t\t\tnum++;\n\t\t\tp = &v[0];\n\t\t}\n\t}\n\tcout << num << endl;//此时需要多次动态扩展\n```\n\n```cpp\n\tvector<int> v;\n\tv.reserve(1e6);//进行空间预留操作\n\tint num = 0;\n\tint* p = NULL;\n\tfor (int i = 0; i < 1e6; i++) {\n\t\tv.push_back(i);\n\t\tif (p != &v[0]) {\n\t\t\tnum++;\n\t\t\tp = &v[0];\n\t\t}\n\t}\n\tcout << num << endl;//此时只需要1次内存分配\n```\n\n## 2.3 deque容器\n\n双端数组，可以对头端和尾端进行插入和删除\n\n**与vector的区别：**\n\n- vector对于头部插入效率低，deque对头部的插入和删除速度快\n- vector访问元素的速度比deque快（与各自的实现原理有关）\n\n![image-20240309152351353](STL/image-20240309152351353.png)\n\n**实现原理：**\n\n![image-20240309152642579](STL/image-20240309152642579.png)\n\n中空气维护每个缓冲区的地址，使得deque**像**一片连续的内存空间\n\n缓冲区中存放真实的数据。\n\n### 2.3.1 构造函数\n\n```cpp\ndeque<T> deq0;\ndeque<T> deq1(deq0.begin(),deq0.end());\ndeque<T> deq2(n, elem);\ndeque<T> deq3(const deque &deq);\n```\n\n### 2.3.2 赋值操作\n\n```cpp\ndeque &operator(const deque &deq);\nassign(beg,end);\nassign(n, elem);\n```\n\n### 2.3.3 容量和大小\n\n```cpp\nempty();\nsize();\nresize(int num);\nresize(int num, elem);\n```\n\ndeque不像vector有capacity\n\n### 2.3.4 插入和删除\n\n两端插入删除操作：\n\n```cpp\npush_back(elem);\npush_front(elem);\npop_back(elem);\npush_front(elem);\n```\n\n指定位置的操作\n\n```cpp\ninsert(const_iterator pos, elem);//返回新数据的位置\ninsert(const_iterator pos, n, elem);//无返回值\ninsert(const_iterator pos, const_iterator begin, const_iterator end);//插入[begin,end)之间的数据，无返回值\nclear();\nerase(const_iterator pos);\nerase(const_iterator beg,const_iterator end);\n```\n\n### 2.3.5 数据存取\n\n```cpp\nat(int idx);\noperator[];\nfront();\nback();\n```\n\n```cpp\ndeque<int> deq;\ndeq.push_front(100);\ndeq.push_back(200);\ndeq.front()=0;\ndeq[0]=0;\ndeq.at(0)=0;\ncout<<deq[0]<<deq.at(0)<<deq.front()<<deq.back();\n```\n\n## 2.4 stack 容器\n\n先进后出（FILO）数据结构——**栈**\n\n只有栈顶元素才可以被外界使用，因此栈**不允许被遍历**\n\n![image-20240309161606134](STL/image-20240309161606134.png)\n\n```cpp\n构造函数：\n    stack<T> stk;//默认构造\n\tstack<T> stk(const stack &stk);//拷贝构造\n赋值操作：\n    stack& operator=(const stack &stk);\n数据存取：\n    push(elem);\n\tpop();\n\ttop();\n空间和大小：\n    empty();\n\tsize();\n```\n\n## 2.5 queue 容器\n\n先进先出FIFIO数据结构——**队列**\n\n![image-20240309162359585](STL/image-20240309162359585.png)\n\n只有队头和队尾才能被外界使用，**不能遍历**\n\n```cpp\n构造函数：\n    queue<T> que;\n\tqueue<T> que(const queue &que);\n赋值操作：\n    queue& operator=(const queue &que);\n数据存取：\n    push(elem);\t\t//入队\n\tpop();\t\t\t//出队\n\tback();\t\t\t//返回最后一个元素\n\tfront();\t\t//返回第一个元素\n大小操作：\n    empty();\n\tsize();\n```\n\n## 2.6 list容器\n\n将数据进行链式存储，链表\n\n链表是由一系列的结点组成的，结点=**数据域**+**指针域**\n\nSTL中的链表是一个双向循环链表\n\n![image-20240309224548260](STL/image-20240309224548260.png)\n\n链表的存储方式并不是连续的内存空间，因此链表的迭代器只支持前移和后移，属于**双向迭代器**\n\nlist的优点：\n\n- 采用动态的内存分配，不会造成内存的浪费和溢出\n- 链表插入和删除十分方便，不需要移动大量元素\n\nlist的缺点：\n\n- 空间和时间耗费较大\n\n\n\nList有一个重要的性质，插入和删除操作不会造成原有的list迭代器失效，vector会造成失效\n\n（由于vector插入的时候如果capacity大小不够的话就会重新申请一个空间，并将数据拷贝到新空间，而原本的迭代器任指向原空间地址）\n\n### 2.6.1 list构造函数\n\n```cpp\nlist<T> lst;\t\t\t\t\t\t\t//默认构造\nlist<T> lst1(lst.begin(), lst.end());\t//将lst[begin,end)区间的元素拷贝\nlist<T> lst2(n, elem);\t\t\t\t\t//将n个elem拷贝给lst2\nlist<T> lst3(const list &lst);\t\t\t//拷贝构造函数\n```\n\n### 2.6.2 list赋值和交换\n\n```cpp\nassign(lst.begin(),lst.end());\nassign(n , elem);\nlist &operator=(const list &lst);\nswap(lst);\t\t\t\t\t\t\t//将lst与本身元素进行交换\n```\n\n### 2.6.3 list空间和大小\n\n```\nsize();\nempty();\nresize(num);\nresize(num, elem);\n```\n\n### 2.6.4 list插入和删除\n\n```cpp\npush_back(elem);\npop_back();\npush_front(elem);\npop_front();\ninsert(const_operator pos, elem);\ninsert(const_operator pos, n, elem);\ninsert(const_operator pos, const_operator beg, const_operator end);\nclear();\nerase(const_operator beg, const_operator end);\nerase(const_operator pos);\nremove(elem);//删除容器中所有与elem值匹配的元素\n```\n\n### 2.6.5 数据存取\n\n```cpp\nfront();\t//返回第一个元素\nback();\t\t//返回最后一个元素\n```\n\n### 2.6.6 list反转和排序\n\n```cpp\nreverse();\n```\n\n```cpp\nlst.sort();\n//lst不支持随机访问迭代器，不可以用标准的排序算法\n//但是一般内部都会有提供\n```\n\n## 2.7 set/multiset/unordered_set容器\n\n所有元素都会在插入时候自动排序\n\n**本质：**\n\nset、multiset属于**关联式容器**，底层结构都是二叉树实现\n\n`set`不允许容器内有重复的元素，`multiset`允许容器内有重复元素，`unordered_set`不排序要去重\n\n### 2.7.1 set的构造和赋值\n\n```cpp\nset<T> st;\nset<T> st1(st);\n```\n\n```cpp\nset& operator=(const set &st);\n```\n\n### 2.7.2 set大小和交换\n\n```cpp\nsize();\nempty();\nswap(st);\t//交换两个集合容器\n```\n\n不允许重新指定大小resize\n\n### 2.7.3 set插入和删除\n\n```cpp\ninsert(elem);\nerase(iterator pos);\nerase(iterator begin, iterator end);\nerase(elem);\t//删除值为elem的元素\nclear();\n```\n\n### 2.7.4 set查找和统计\n\n```cpp\nfind(key);\t//检查key是否存在，若存在则返回元素迭代器，不存在则返回st.end();\ncount(key);\t//统计key元素的个数\n```\n\n### 2.7.5 set容器排序\n\n默认排序规则为从小到大，\n\n利用仿函数改变排序规则。\n\n**1.内置数据类型：**\n\n```cpp\nclass MyCompare{\npublic:\n    bool operator()(int v1, int v2){//采用仿函数\n        return v1 > v2;\n    } \n}\nvoid main(){\n    set<int,MyCompare> s;\n    for(set<int,MyCompare>::iterator it=s.begin();it!=s.end();it++){\n        cout<<*it<<endl;\n    }\n}\n```\n\n**2.自定义数据类型：**\n\n```cpp\nclass Person{\npublic:\n   Person(string name,int age){\n       m_Name = name;\n       m_Age = age;\n   }\n   string m_Name;\n   int m_Age;\n}\nclass comparePerson{\npublic:\n    bool operator()(const Person &p1, const Person &p2){\n        return p1.m_Age>p2.m_Age;\n    }\n}\nvoid main(){\n    set<Person,comparePerson> s;\n    s.insert(Person(\"vicczyq\",18));\n    \n}\n```\n\n## 2.8 map/multimap容器\n\n- map中全部元素都是pair对组\n- pair第一个元素为key(键值)，起到索引作用，第二个为value(实值)\n- 所有元素都会根据元素的键(key)**自动排序**\n\nmap、multimap属于关联式容器，底层是用二叉树实现。\n\nmap不允许重复key值，multimap可以有重复key\n\n### 2.8.1 map构造和赋值\n\n```cpp\nmap<string,int> mp;\nmap<string,int> mp1(mp);\n```\n\n```cpp\nmap<string,int>& operator=(const map &mp);\n```\n\n### 2.8.2 map的大小和交换\n\n```cpp\nsize();\nempty();\nswap(st);\n```\n\n### 2.8.3 map的插入和删除\n\n```cpp\ninsert(pair);\t//如下代码段，有几种方法\nclear();\nerase(iterator pos);\nerase(iterator beg, iterator end);\nerase(key);\n```\n\n```cpp\nm.insert(pair<int,int>(1,10));\t//第一种\nm.insert(make_pair(1,10));\t\t//第二种\nm[1]=10;\t\t\t\t\t\t//第三种：key为4,value为10\n```\n\n不建议采用第三种，但可以利用key访问value\n\n**原因：**如果没有赋值value，直接用`m[1]`，这样他会默认创建一个m[1]=0\n\n### 2.8.4 map的查找和统计\n\n```cpp\nfind(key);\t//查找，返回元素迭代器，如果没查到返回mp.end();\ncount(key); //统计key元素个数\n```\n\n### 2.8.5 map的排序\n\n利用仿函数改变排序规则\n\n```cpp\nclass myCompare{\npublic:\n\tbool operator()(int v1, int v2){\n\t\treturn v1>v2;\n\t}\n}\n\nmap<int,myCompare> mp;\n```\n\n# 3 函数对象\n\n在`algorithm`算法库中有许多函数，如sort、for_each、find_if等\n\n都需要传入一个函数指针\n\n```cpp\nbool Find(const int &x){\n\treturn x==3;\n}\nint main(){\n\tint a[10]={1,2,3,4,5,6,7,8,9,10};\n\tcout << *(find_if(a,a+10,Find));\n}\n```\n\n这里查找的固定值是**3**，但是如果不固定呢，就需要把他当做一个变量\n\n**解决方法：**\n\n- 给函数再加一个形参：但是这里传的是函数指针，形参赋值不了\n- 作为局部变量：不能在调用的时候传入，扩展性不强\n- 作为全局变量：维护起来不方便\n- **成员变量：可以在构造里传参，将参数保护到成员变量，易于维护**\n\n```cpp\ntemplate<typename T> class Find{\npublic:\n    T num;\n    Find(const T& n){\n        num = n;\n    }\n    bool operator()(const T& x){\n        return x==num;\n    }\n}\n```\n\n## 3.1 函数对象概念\n\n- 重载**函数调用操作符**的类，其对象称为**函数对象**\n- 函数对象使用重载的()时，行为类似于函数调用，也叫**仿函数**\n\n**本质：**\n\n函数对象是一个类，不是一个函数\n\n```cpp\n//函数对象在使用时，可以像普通函数那样调用，可以有参数和返回值\nclass myAdd{\npublic:\n\tint operator()(int v1, int v2){\n\t\treturn v1+v2;\n\t}\n}\n\nmyAdd myadd;\ncout << myadd(10,10) << endl;\n\n//函数对象超出了普通函数的概念，可以拥有自己的状态\nclass myPrint{\npublic:\n    myPrint(){\n        this->count=0;\n    }\n    void operator()(string &a){\n        cout << a << endl;\n        count++;\n    }\n \tint count = 0;//自己内部状态\n}\n\n//函数对象可以作为参数进行传递\n```\n\n## 3.2 谓词\n\n返回**bool类型**的**仿函数**称为**谓词**\n\n一元谓词：operator接受的是一个参数\n\n二元谓词：operator接受的是两个参数\n\n```cpp\nclass myPrint{//一元谓词\npublic:\n\tbool operator()(string &a){\n\t\t//\n\t}\n}\n\nclass myCompare{//二元谓词\npublic:\n    bool operator()(int &a,int &b){\n        return a>b;\n    }\n}\n\nvoid main(){\n    vector<int> a;\n\t//一系列的插入操作   \n    sort(a.begin(),a.end(),myCompare());\n}\n```\n\n## 3.3 内建函数对象\n\n**分类：**\n\n- 算数仿函数\n- 关系仿函数\n- 逻辑仿函数\n\n使用内建函数对象的会后，需要引入头文件`#include <functional>`\n\n### 3.3.1 算数仿函数\n\n```cpp\ntemplate<typename T> T plus<T>\t\t\t//加法仿函数\ntemplate<typename T> T minus<T>\t\t\t//减法仿函数\ntemplate<typename T> T multiplies<T>\t//乘加仿函数\ntemplate<typename T> T divides<T>\t\t//除法仿函数\ntemplate<typename T> T modulus<T>\t\t//取模仿函数\ntemplate<typename T> T negate<T>\t\t//取反仿函数（一元）\n```\n\n```cpp\n#include <functional>\nvoid main(){\n    nagate<int> n1;\n    n1(50);//取反\n    plus<int> n2;\n    n2(10,20);//相加\n}\n```\n\n### 3.3.2 关系仿函数\n\n```cpp\ntemplate<typename T> bool equal_to<T>\t\t//等于\ntemplate<typename T> bool not_equal_to<T>\t//不等于\ntemplate<typename T> bool greater<T>\t\t//大于\ntemplate<typename T> bool greater_equal<T>\t//大于等于\ntemplate<typename T> bool less<T>\t\t\t//小于\ntemplate<typename T> bool less_equal<T>\t\t//小于等于\n```\n\n```cpp\n#include <functional>\nvoid main(){\n    sort(a, a+10, greater<int>());\n}\n```\n\n### 3.3.3 逻辑仿函数\n\n```cpp\ntemplate<typename T> bool logical_and<T>\t//与\ntemplate<typename T> bool logical_or<T>\t\t//或\ntemplate<typename T> bool logical_not<T>\t//非\n```\n\n# 4  算法\n\n主要由`algorithm`、`functional`、`numeric`组成\n\n- `<algorihtm>`：STL中最大的一个，涉及到比较、交换、查找、遍历、复制、修改等\n- `<functional>`：定义了一些模板类，用于声明函数对象\n- `<numeric>`：体积很小，只包括几个序列上面进行简单数学算数运算的模板函数\n\n## 4.1 遍历算法\n\n- `for_each`：遍历容器\n- `transform`：搬运容器到另外一个容器中\n\n### 4.1.1 for_each\n\n```cpp\nfor_each(iterator beg, iterator end, _func);\n```\n\n```cpp\n#include <algorithm>\n#include <vector>\nusing namespace std;\n//普通函数方式\nvoid print01(int &val){\n    cout<<val<<endl;\n}\n//仿函数\nclass print02{\npublic:\n    void operator()(int &val){\n        cout<<val<<endl;\n    }\n}\n\nvoid main(){\n    vector<int> vec;\n    for(int i=0;i<10;i++){\n    \tvec.push_back(i);\n    }\n    for_each(vec.begin(),vec.end(), print01);//普通函数方式\n    for_each(vec.begin(),vec.end(), print02());//仿函数方式(函数对象方式)\n}\n```\n\n### 4.1.2 transform\n\n搬运容器到另外一个容器中\n\n```cpp\ntransform(iterator beg1, iterator end1, iterator beg2, _func);\n```\n\n_func可以实现在搬运过程中对数据进行处理，可以用**普通函数**或**函数对象**\n\n```cpp\n#include <algorithm>\n#include <vector>\nusing namespace std;\nclass Transform{\npublic:\n    int operator()(int v){\n        return v;\n    }\n}\n\nvoid main(){\n    vector<int> vec;\n    for(int i=0;i<10;i++)vec.push_back(i);\n    \n    vector<int> vTarget;\n    vTarget.resize(10);\n    transform(vec.begin(),vec.end(),vTarget.begin(),Transform());\n}\n```\n\n## 4.2 查找算法\n\n- `find`：查找元素\n- `find_if`：按条件查找\n- `adjacent_find`：查找相邻重复元素\n- `binary_search`：二分查找法\n- `count`：统计元素个数\n- `count_if`：按条件统计元素个数\n\n### 4.2.1 find\n\n查找指定元素，找到返回指定元素的迭代器，找不到返回结束迭代器.end()\n\n```cpp\nfind(iterator beg, iterator end, value)\n```\n\n```cpp\nclass Person{\npublic:\n    string m_Name;\n    int m_Age;\n    Person(string &name, int &age){\n        m_Name=name;\n        m_Age=age;\n    }\n    bool operator==(const Person &p){\n        if(m_Name==p.m_name && m_Age==p.m_Age){\n            return true;\n        }\n    }\n}\nvoid main(){\n    //。。。\n    vector<int>::iterator it =find(vec.begin(),vec.end(),Person(\"bbb\",18));\n    //。。。\n}\n```\n\n### 4.2.2 find_if\n\n```cpp\nfind_if(iterator beg, iterator end, _Pred);\n```\n\n查找元素，有过存在返回迭代器，不存在返回end()\n\n```cpp\n#include <functional>\n#include <algorithm>\n#include <vector>\nusing namespace std;\nclass GreaterFive{\npublic:\n    bool operator()(int val){\n        return val>5;\n    }\n}\nfind_if(vec.begin(),vec.end(),GreaterFive());\n//此时不能用内置的greater，因为greater是二元\n```\n\n### 4.2.3 adjacent_find\n\n查找相邻的重复元素\n\n```cpp\niterator &adjacent_find(iterator beg, iterator end,);\n```\n\n返回相邻元素的第一个位置的迭代器\n\n### 4.2.4 binary_search\n\n二分查找，返回值为bool，查找指定元素是否存在\n\n```cpp\nbool binary_search(iterator beg, iterator end, value);\n```\n\n### 4.2.5 count\n\n统计元素个数，返回值为整数型\n\n```cpp\ncount(iterator beg, iterator end, value);\n```\n\n### 4.2.6 count_if\n\n按条件统计元素个数\n\n```cpp\ncount(iterator beg, iterator end, _Pred);\n```\n\n_Pred为谓词\n\n```cpp\nclass MyCount{\npublic:\n\tbool operator()(int val){\n\t\treturn val>5;\n\t}\n}\n\nvector<int> vec;\nfor(int i=0;i<10;i++)vec.push_back(i);\nint c = count(vec.begin(), vec.end(), myCount());\ncout << \"vec中大于5的元素个数:\" << c <<endl;\n```\n\n## 4.3 排序算法\n\n### 4.3.1 sort\n\n```cpp\nsort(iterator beg, iterator end, _Pred);\n```\n\n_Pred选填，谓词，默认为升序排序\n\n```cpp\nclass mySort{\npublic:\n    bool operator()(int &a, int &b){\n        return a>b;\n    }\n}\nvector<int> vec;\nfor(int i=0;i<10;i++)vec.push_back(i);\nsort(vec.begin(),vec.end(),greater<int>());//内置仿函数\nsort(vec.begin(),vec.end(),mySort());//自定义仿函数\n```\n\n### 4.3.2 random_shuffle\n\n洗牌，指定范围元素随机调整次序\n\n```cpp\n#include <ctime>\nsrand((unsigned int)time(NULL));//随机数种子\nrandom_shuffle(iterator beg, iterator end);\n```\n\n### 4.3.3 merge\n\n将两个容器合并，并存储到另外一个容器\n\n```cpp\nmerge(iterator beg1, iterator end1, iterator beg2, iterator end2, iterator dest_beg);\n```\n\n**注意：**两个容器必须是**有序的**\n\n```cpp\nvector<int> v1,v2,vTarget;\nfor(int i=0; i<10;i++){\n\tv1.push_back(i);\n\tv2.push_back(i+1);\n}\nvTarget.resize(20);\nmerge(v1.begin(),v1.end(),v2.begin(),v2.end(),vTarget.begin());\n```\n\n输出：0,1,1,2,2,3,3,4,4,5.......\n\n### 4.3.4 reverse\n\n反转\n\n```cpp\nreverse(iterator beg, iterator end);\n```\n\n## 4.4 拷贝和替换\n\n### 4.4.1 copy\n\n```cpp\ncopy(iterator beg, iterator end, iterator dest_beg);\n```\n\n### 4.4.2 replace\n\n```cpp\nreplace(iterator beg, iterator end, old_value, new_value);\n```\n\n### 4.4.3 replace_if\n\n```cpp\nreplace_if(iterator beg, iterator end, _Pred, new_value);\n```\n\n### 4.4.4 swap\n\n```cpp\nswap(container c1, container c2);\n```\n\n注意：容器必须为同种类型\n\n## 4.5算数生成算法\n\n头文件`#include <numeric>`\n\n### 4.5.1 accumulate\n\n```cpp\naccumulate(iterator beg, iterator end, value);\n//value为起始值\n```\n\n```cpp\nvector<int> vec;\nfor(int i =0;i<10;i++)vec.push_back(i);\nint n = accumulate(vec.begin(),vec.end(),0);\ncout << n << endl;\n```\n\n### 4.5.2 fill\n\n向容器内填充指定的容器\n\n```cpp\nfill(iterator beg, iterator end, value);\n```\n\n## 4.6 集合算法\n\n容器**必须有序**\n\n### 4.6.1 set_intersection\n\n求两个容器的交集\n\n```cpp\nset_intersection(iterator beg1, iterator end1, iterator beg2, iterator end2, iterator Target_beg);\n```\n\n```cpp\nvector<int> v1,v2,vTarget;\nfor(int i=0;i<10;i++){\n    v1.push_back(i);\n    v2.push_back(i+5);\n}\nvTarget.resize(min(v1.size(),v2.size()));\nvector<int>::iterator it = set_intersection(v1.begin(),v1.end(),v2.begin(,v2.end(),vTarget.begin());//返回的是交集最后一个元素的位置\nfor_each(vTarget.begin(), it, myPrint);\n```\n\n\n\n### 4.6.2 set_union\n\n求两个容器的并集，必须是**有序序列**！\n\n```cpp\nset_union(iterator beg1, iterator end1, iterator beg2, iterator end2, iterator Target_beg);\n```\n\n### 4.6.3 set_difference\n\n求两个容器的差集\n\n```cpp\nset_difference(iterator beg1, iterator end1, iterator beg2, iterator end2, iterator Target_beg);\n```\n\n","tags":["C++"]},{"title":"C++知识补充","url":"/2024/03/07/C-plus-plus/","content":"\n# 1.函数\n\n## 1.1 内联函数inline\n\n为了提高程序运行的速度，引入内联关键字`inline`\n\n编译器会将调用函数的地方直接替换为函数代码。这样程序就无需跳转到函数地址再跳回来。因此速度更快，但是**代价是需要占用更多的内存**\n\n```cpp\ninline double square(double x){return x*x}\n\nint main(){\n    double a = 13.0;\n    double b = square(a);//此处就会进行函数替换\n}\n```\n\n## 1.2 引用&\n\n引用可以理解为变量的**别名**，使得函数使用原始数据，而不是副本。\n\n主要的用途是**用作函数的形参**\n\n```cpp\nvoid func(int &b){\n\t//此时b和a的地址都是相同的，不会进行副本创建\n}\nvoid main(){\n\tint a=10;\n\tfunc(a);\n}\n```\n\n**注意**：引用在声明的时候就要进行初始化，而且后面不能改变，“忠一”\n\n如果对象是数组，则使用const指针(常量指针)\n\n## 1.3 函数重载\n\n可以有多个同名的函数，但是他们有不同返回值或不同的参数列表\n\n```cpp\nint func();\nint func(int a);\nint func(double a);\nvoid func();\nvoid func(int a,int b);\n```\n\n函数重载**不会区分const**关键字以及引用&\n\n比如`void func(cont double a)`和`void func(double a)`以及`void func(double &a)`都是一样的\n\n# 2.基本语法\n\n## 2.1 cin、cin.get、cin.getline的使用\n\n`cin`输入后换行符会留在输入缓冲区中\n\n`cin.getline(name,length)`输入一行后会丢弃换行符，用空字符'\\0'替换换行符\n\n`cin.get(name,length)`输入一行后不丢弃换行符，同时会把换行符留在输入缓冲区中\n\n但是，同时使用cin输入时，**>>会自动跳过空字符**(包括换行符)\n\n```cpp\nstring str;\ncin >> str;//此时换行符会留在缓冲区中\ncin.get();//获得换行符\ncin.getline(str,10);\n```\n\n```cpp\ncin.get(str,10).get();\n//可以实现类似于geiline的效果\n```\n\n### 2.2 共用体Union\n\n共用体常用于节省内存，可以说是对一个内存的复用\n\n```cpp\nUnion m_Union{\n\tint int_val;\n\tdouble double_val;\n\tlong long_val;\n};\n```\n\n申请的空间长度等于共用体内最长的数据类型的大小。\n\n```cpp\nvoid main(){\n    m_Union a;\n    a.int_val=10;\n}\n```\n\n## 2.3 extern \"C\"\n\nextern “C” 主要作用就是为了能够正确实现 C++ 代码调用其他 [C 语言](https://www.codersrc.com/c语言基础)代码。\n\n[extern “C”](https://www.codersrc.com/archives/9358.html) 会指示编译器这部分代码按 C 语言的进行编译，而不是 C++。\n\n# 3.线程和进程\n\n线程是轻量级的进程\n\n**区别：**\n\n- **进程**拥有自己独立的地址空间，多个**线程**公用同一个地址空间\n- **进程**是资源分配的最小单位，**线程**是操作系统的最小调度单位\n- 线程在CPU上的上下文切换速度更快\n\n## 3.1 线程\n\n创建线程需要包含`<pthread>`头文件，需要链接动态库`-lpthread`\n\n每一个线程都有唯一的线程id，数据类型为`pthread_t`\n\n可以通过`pthread_self()`函数获取当前线程id\n\n```cpp\npthread_t tid = pthread_self(void);\n```\n\n### 3.1.1 创建\n\n```cpp\nint pthread_create(pthread_t *tid, NULL, void *func, void *arg);\n```\n\n- tid：线程创建成功会写入线程id到此处\n- 线程的属性, 一般情况下使用默认属性即可, 写NULL\n- func：函数指针，创建出的子线程的处理动作\n- arg：作为实参传递到 start_routine 指针指向的函数内部\n- 返回值：线程创建成功返回0，创建失败返回对应的错误号\n\n```cpp\n// pthread_create.c \n#include <stdio.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <string.h>\n#include <pthread.h>\n\n// 子线程的处理代码\nvoid* working(void* arg)\n{\n    printf(\"我是子线程, 线程ID: %ld\\n\", pthread_self());\n    for(int i=0; i<9; ++i)\n    {\n        printf(\"child == i: = %d\\n\", i);\n    }\n    return NULL;\n}\n\nint main()\n{\n    // 1. 创建一个子线程\n    pthread_t tid;\n    pthread_create(&tid, NULL, working, NULL);\n\n    printf(\"子线程创建成功, 线程ID: %ld\\n\", tid);\n    \n    // 2. 子线程不会执行下边的代码, 主线程执行\n    printf(\"我是主线程, 线程ID: %ld\\n\", pthread_self());\n    for(int i=0; i<3; ++i)\n    {\n        printf(\"i = %d\\n\", i);\n    }\n    return 0;\n}\n\n```\n\n### 3.1.2 退出\n\n上述例子中，子线程被创建出来之后需要抢cpu时间片, 抢不到就不能运行，一旦主线程退出了, 虚拟地址空间就被释放了, 子线程就一并被销毁了。\n\n如果想要让线程退出，但是不会导致虚拟地址空间的释放（针对于主线程），我们就可以调用线程库中的线程退出函数，只要调用该函数当前线程就马上退出了，并且不会影响到其他线程的正常运行，不管是在子线程或者主线程中都可以使用。\n\n```cpp\n#include <pthread.h>\nvoid pthread_exit(void *retval);\n```\n\n- \n  参数: 线程退出的时候携带的数据，当前子线程的主线程会得到该数据。如果不需要使用，指定为NULL\n\n```cpp\n#include <stdio.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <string.h>\n#include <pthread.h>\n\n// 子线程的处理代码\nvoid* working(void* arg)\n{\n    sleep(1);\n    printf(\"我是子线程, 线程ID: %ld\\n\", pthread_self());\n    for(int i=0; i<9; ++i)\n    {\n        if(i==6)\n        {\n            pthread_exit(NULL);\t// 直接退出子线程\n        } \n        printf(\"child == i: = %d\\n\", i);\n    }\n    return NULL;\n}\n\nint main()\n{\n    // 1. 创建一个子线程\n    pthread_t tid;\n    pthread_create(&tid, NULL, working, NULL);\n\n    printf(\"子线程创建成功, 线程ID: %ld\\n\", tid);\n    // 2. 子线程不会执行下边的代码, 主线程执行\n    printf(\"我是主线程, 线程ID: %ld\\n\", pthread_self());\n    for(int i=0; i<3; ++i)\n    {\n        printf(\"i = %d\\n\", i);\n    }\n\n    // 主线程调用退出函数退出, 地址空间不会被释放\n    pthread_exit(NULL);\n    \n    return 0;\n}\n```\n\n### 3.1.3 回收\n\n子线程退出时，内核资源主要由主线程回收，通过`pthread_join()`函数实现\n\n此函数为阻塞函数，函数被调用一次，只能回收一个子线程，如果有多个子线程则需要循环进行回收。\n\n```cpp\n#include <pthread.h>\n// 这是一个阻塞函数, 子线程在运行这个函数就阻塞\n// 子线程退出, 函数解除阻塞, 回收对应的子线程资源, 类似于回收进程使用的函数 wait()\nint pthread_join(pthread_t thread, void **retval);\n```\n\n```cpp\n// pthread_join.c\n#include <stdio.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <string.h>\n#include <pthread.h>\n\n// 定义结构\nstruct Persion\n{\n    int id;\n    char name[36];\n    int age;\n};\n\n// 子线程的处理代码\nvoid* working(void* arg)\n{\n    printf(\"我是子线程, 线程ID: %ld\\n\", pthread_self());\n    for(int i=0; i<9; ++i)\n    {\n        printf(\"child == i: = %d\\n\", i);\n        if(i == 6)\n        {\n            struct Persion p;\n            p.age  =12;\n            strcpy(p.name, \"tom\");\n            p.id = 100;\n            // 该函数的参数将这个地址传递给了主线程的pthread_join()\n            pthread_exit(&p);\n        }\n    }\n    return NULL;\t// 代码执行不到这个位置就退出了\n}\n\nint main()\n{\n    // 1. 创建一个子线程\n    pthread_t tid;\n    pthread_create(&tid, NULL, working, NULL);\n\n    printf(\"子线程创建成功, 线程ID: %ld\\n\", tid);\n    // 2. 子线程不会执行下边的代码, 主线程执行\n    printf(\"我是主线程, 线程ID: %ld\\n\", pthread_self());\n    for(int i=0; i<3; ++i)\n    {\n        printf(\"i = %d\\n\", i);\n    }\n\n    // 阻塞等待子线程退出\n    void* ptr = NULL;\n    // ptr是一个传出参数, 在函数内部让这个指针指向一块有效内存\n    // 这个内存地址就是pthread_exit() 参数指向的内存\n    pthread_join(tid, &ptr);\n    // 打印信息\n    struct Persion* pp = (struct Persion*)ptr;\n    printf(\"子线程返回数据: name: %s, age: %d, id: %d\\n\", pp->name, pp->age, pp->id);\n    printf(\"子线程资源被成功回收...\\n\");\n    \n    return 0;\n}\n```\n\n### 3.1.4 线程分离\n\n如果采用`pthread_join()`，主线程就会一直阻塞等待子线程运行完成，\n\n采用`pthread_detach()`即可完成线程分离，调用这个函数之后指定的子线程就可以和主线程分离，当子线程退出的时候，其占用的内核资源就被**系统的其他进程**接管并回收了。线程分离之后在主线程中使用`pthread_join()`就回收不到子线程资源了。\n\n```cpp\n#include <stdio.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <string.h>\n#include <pthread.h>\n\n// 子线程的处理代码\nvoid* working(void* arg)\n{\n    printf(\"我是子线程, 线程ID: %ld\\n\", pthread_self());\n    for(int i=0; i<9; ++i)\n    {\n        printf(\"child == i: = %d\\n\", i);\n    }\n    return NULL;\n}\n\nint main()\n{\n    // 1. 创建一个子线程\n    pthread_t tid;\n    pthread_create(&tid, NULL, working, NULL);\n\n    printf(\"子线程创建成功, 线程ID: %ld\\n\", tid);\n    // 2. 子线程不会执行下边的代码, 主线程执行\n    printf(\"我是主线程, 线程ID: %ld\\n\", pthread_self());\n    for(int i=0; i<3; ++i)\n    {\n        printf(\"i = %d\\n\", i);\n    }\n\n    // 设置子线程和主线程分离\n    pthread_detach(tid);\n\n    // 让主线程自己退出即可\n    pthread_exit(NULL);\n    \n    return 0;\n}\n```\n\n### 3.1.5 线程取消\n\n```cpp\n#include <pthread.h>\n// 参数是子线程的线程ID\nint pthread_cancel(pthread_t thread);\n```\n\n- 参数：要杀死的线程的线程ID\n- 返回值：函数调用成功返回0，调用失败返回非0错误号。\n\n### 3.1.6 pthread_t的比较\n\n```cpp\n#include <pthread.h>\nint pthread_equal(pthread_t t1, pthread_t t2);\n```\n\n- 参数：t1 和 t2 是要比较的线程的线程ID\n- 返回值：如果两个线程ID相等返回非0值，如果不相等返回0\n\n# 4.C++11新特性\n\n## 4.1 lamada\n\n本质是匿名函数可以让代码变得简洁.并且可以提高代码的可读性\n\n```cpp\n#include <algorithm>\n#include <cmath>\n\nvoid abssort(float* x, unsigned n) {\n    std::sort(x, x + n,\n        // 下面是一个简单的 `Lambda 表达式`\n        [](float a, float b) {\n            return (std::abs(a) < std::abs(b));\n        } \n    ); \n}\n\n```\n\n> **捕获列表**：（capture list）（在 C++ 规范中也称为 Lambda 引导。）\n> **参数列表：**（parameters list）（可选）。 （也称为 Lambda 声明符）\n> **mutable 规范：**（可选）。\n> **异常说明：**exception-specification（可选）。\n> **返回类型：**trailing-return-type（可选）。\n> **Lambda 体：**也就是函数体。\n\n![标识 lambda 表达式的各个部分的示意图。](C-plus-plus/b8cd9d17b7074f4785cb2dcdb59c9bf3.png)\n\n![在这里插入图片描述](C-plus-plus/0c46c0d657aa4b378267aa0eb397b081.png)\n\nLambda表达式的捕获列表用于指定Lambda表达式中使用的外部变量。捕获列表可以为空，也可以包含以下内容：\n\n- []：不捕获任何外部变量；\n- [&]：以引用方式捕获所有外部变量；\n- [=]：以值方式捕获所有外部变量；\n- [var1, var2, ...]：指定捕获特定的外部变量；\n- [&, var1, var2, ...]：以引用方式捕获所有外部变量，并指定捕获特定的外部变量；\n- [=, &var1, &var2, ...]：以值方式捕获所有外部变量，并以引用方式捕获特定的外部变量。\n\n捕获可以说是引用，传参是传副本。\n\n## 4.2 auto\n\nauto关键字可以进行自动类型推导，节省代码量\n\n```cpp\nvector<int> vec;\nvector<int>::iterator it = vec.begin();//原来\nauto it = vec.begin();//C++11 auto\n```\n\n## 4.3 区域for循环\n\n```cpp\nfor(const auto & num : nums){\n\tcout << num << endl;\n}\n```\n\n## 4.4 智能指针\n\n### 4.4.1 unique_ptr\n\n头文件为`<memory>`\n\n对`*`和`->`运算符进行重载，使unique_ptr对象具有指针一样的行为。\n\n构造函数和拷贝赋值函数后面加上`=delete`，防止外部进行调用\n\n#### 4.4.1.1 模拟实现\n\n```cpp\n\ttemplate<class T>\n\tclass unique_ptr\n\t{\n\tpublic:\n\t\t// RAII\n\t\t// 保存资源\n\t\tunique_ptr(T* ptr)\n\t\t\t:_ptr(ptr)\n\t\t{}\n\t\t// 释放资源\n\t\t~unique_ptr()\n\t\t{\n\t\t\t//delete[] _ptr;\n\t\t\tdelete _ptr;\n\t\t\tcout << _ptr << endl;\n\t\t}\n\n\t\tunique_ptr(const unique_ptr<T>& up) = delete;\n\t\tunique_ptr<T>& operator=(const unique_ptr<T>& up) = delete;\n\n\t\t// 像指针一样\n\t\tT& operator*()\n\t\t{\n\t\t\treturn *_ptr;\n\t\t}\n\n\t\tT* operator->()\n\t\t{\n\t\t\treturn return _ptr;\n\t\t}\n\n\t\tT& operator[](size_t pos)\n\t\t{\n\t\t\treturn _ptr[pos];\n\t\t}\n\tprivate:\n\t\tT* _ptr;\n\t};\n\n```\n\n#### 4.4.1.2 声明\n\n```cpp\nstd::unique_ptr<int> up1(new int(0));\n```\n\n### 4.4.2 shared_ptr\n\nshared_ptr是C++11的智能指针，通过引用计数的方式解决智能指针的拷贝问题。\n\n引用计数的方式能够支持多个对象一起管理一个资源，也就支持智能指针的拷贝，只有当资源的引用计数减为0时才会释放，保证了同一个资源不会被多次释放：\n\n```cpp\nint main()\n{\n\tstd::shared_ptr<int> sp1(new int(1));\n\tstd::shared_ptr<int> sp2(sp1);\n\t*sp1 = 10;\n\t*sp2 = 20;\n\tcout << sp1.use_count() << endl; //2\n    //use_count：用于获取当前对象管理的资源对应的引用计数。\n\tstd::shared_ptr<int> sp3(new int(1));\n\tstd::shared_ptr<int> sp4(new int(2));\n\tsp3 = sp4;\n\tcout << sp3.use_count() << endl; //2\n\treturn 0;\n}\n\n```\n\n#### 4.4.2.1模拟实现\n\n```cpp\n\ttemplate<class T>\n\tclass shared_ptr\n\t{\n\tpublic:\n\t\t// RAII\n\t\t// 保存资源\n\t\tshared_ptr(T* ptr):_ptr(ptr), _pcount(new int(1)){}\n\t\t// 释放资源\n\t\t~shared_ptr(){\n\t\t\tRelease();\n\t\t}\n\n\t\tshared_ptr(const shared_ptr<T>& sp):_ptr(sp._ptr), _pcount(sp._pcount){\n\t\t\t++(*_pcount);\n\t\t}\n\n\t\tvoid Release(){\n\t\t\tif (--(*_pcount) == 0){\n\t\t\t\tdelete _pcount;\n\t\t\t\tdelete _ptr;\n\t\t\t}\n\t\t}\n        \n        //sp1 = sp1;\n        //sp1 = sp2;//sp2如果是sp1的拷贝呢？\n\t\tshared_ptr<T>& operator=(const shared_ptr<T>& sp){\n\t\t\tif (_ptr != sp._ptr)//资源地址不一样\n\t\t\t{\n\t\t\t\tRelease();\n\t\t\t\t_pcount = sp._pcount;\n\t\t\t\t_ptr = sp._ptr;\n\t\t\t\t++(*_pcount);\n\t\t\t}\n\n\t\t\treturn *this;\n\t\t}\n        \n        int use_count()\n\t\t{\n\t\t\treturn *_pcount;\n\t\t}\n\n\t\t// 像指针一样\n\t\tT& operator*()\n\t\t{\n\t\t\treturn *_ptr;\n\t\t}\n\n\t\tT* operator->()\n\t\t{\n\t\t\treturn _ptr;\n\t\t}\n\n\t\tT& operator[](size_t pos)\n\t\t{\n\t\t\treturn _ptr[pos];\n\t\t}\n\tprivate:\n\t\tT* _ptr;\n\t\tint* _pcount;\n\t};\n\n```\n\n","tags":["C++"]},{"title":"Makefile和CMake","url":"/2024/03/06/Makefile和CMake/","content":"\nCMake用于自动生成`Makefile`文件\n\n![img](Makefile和CMake/1702265901352-3cfb487d-7d91-438d-9f32-6fa0a1de8403.jpeg)\n\nMakefile通常依赖于当前的编译平台，而且编写 makefile 的工作量比较大，解决依赖关系时也容易出错。\n\n**CMake的优点：**跨平台、能够管理大型项目、简化编译构建过程和编译过程、可扩展（可以为 cmake 编写特定功能的模块，扩充 cmake 功能）\n\n### 1、Cmake的使用\n\n前言：`Cmake`不区分大小写，在编写`CMakelists.txt`随缘\n\n#### 1.1注释\n\n```cmake\n#这是要注释的内容\ncmake_minimum_required(VERSION 3.0.0)\n#[[ 这是一个 CMakeLists.txt 文件。\n这是一个 CMakeLists.txt 文件\n这是一个 CMakeLists.txt 文件]]\ncmake_minimum_required(VERSION 3.0.0)\n```\n\n#### 1.2源文件\n\n假设在某处存在如下几个源文件\n\n```c\n#include <stdio.h>\n#include \"head.h\"\n\nint add(int a, int b)\n{\n    return a+b;\n}\n#include <stdio.h>\n#include \"head.h\"\n\n// 你好\nint subtract(int a, int b)\n{\n    return a-b;\n}\n#include <stdio.h>\n#include \"head.h\"\n\nint multiply(int a, int b)\n{\n    return a*b;\n}\n#include <stdio.h>\n#include \"head.h\"\n\ndouble divide(int a, int b)\n{\n    return (double)a/b;\n}\n#include <stdio.h>\n#include \"head.h\"\n\nint main()\n{\n    int a = 20;\n    int b = 12;\n    printf(\"a = %d, b = %d\\n\", a, b);\n    printf(\"a + b = %d\\n\", add(a, b));\n    printf(\"a - b = %d\\n\", subtract(a, b));\n    printf(\"a * b = %d\\n\", multiply(a, b));\n    printf(\"a / b = %f\\n\", divide(a, b));\n    return 0;\n}\n#ifndef _HEAD_H\n#define _HEAD_H\n// 加法\nint add(int a, int b);\n// 减法\nint subtract(int a, int b);\n// 乘法\nint multiply(int a, int b);\n// 除法\ndouble divide(int a, int b);\n#endif\n```\n\n目录结构如下：\n\n![img](Makefile和CMake/1702265727682-b726d840-5930-44a1-9e14-6d772a785bd1.png)\n\n##### 1.2.1编写CMakeLists.txt\n\n在同级目录创建`CMakeLists.txt`文件\n\n**内容如下：**\n\n```cmake\ncmake_minimum_required(VERSION 3.0)\t#指定使用的 cmake 的最低版本,可选非必须，不加可能会有警告\nproject(CALC)\t\nadd_executable(app add.c div.c main.c mult.c sub.c)#定义工程会生成一个可执行程序\n```\n\nproject：定义工程名称，并可指定工程的版本、工程描述、web主页地址、支持的语言（默认情况支持所有语言），如果不需要这些都是可以忽略的，只需要指定出工程名字即可。\n\n```cmake\n# PROJECT 指令的语法是：\nproject(<PROJECT-NAME> [<language-name>...])\nproject(<PROJECT-NAME>\n       [VERSION <major>[.<minor>[.<patch>[.<tweak>]]]]\n       [DESCRIPTION <project-description-string>]\n       [HOMEPAGE_URL <url-string>]\n       [LANGUAGES <language-name>...])\n```\n\nadd_executable：生成可执行程序\n\n```cmake\nadd_executable(可执行程序名 源文件名称)\n\n可以是一个或者多个源文件，如果有多个之间用空格或“;”隔开\n# 样式1\nadd_executable(app add.c div.c main.c mult.c sub.c)\n# 样式2\nadd_executable(app add.c;div.c;main.c;mult.c;sub.c)\n```\n\n注意：可执行程序名和project中的项目名没有任何关系\n\n##### 1.2.2执行cmake\n\n```powershell\ncmake CMakeLists.txt文件所在路径\n```\n\n![img](Makefile和CMake/1702266095713-a4473858-5cb5-4732-9121-c57ce8f3c11f.png)\n\n执行完成后，可以看到当前目录多了许多文件，其中就包括`Makefile`文件\n\n![img](Makefile和CMake/1702266185034-23049925-8629-4bdc-8aed-e41ec0728328.png)\n\n执行`make`即可得到目标执行程序文件\n\n![img](Makefile和CMake/1702266259478-008c3471-c721-4d11-8dcc-469b0023fbc1.png)\n\n##### 1.2.3独立CMake相关文件\n\n如果在`CMakeLists.txt`文件所在目录执行了`cmake`命令之后就会生成一些目录和文件（包括 makefile 文件），如果再基于makefile文件执行make命令，程序在编译过程中还会生成一些中间文件和一个可执行文件，这样会导致整个项目目录看起来很混乱，不太容易管理和维护，此时我们就可以把生成的这些与项目源码无关的文件统一放到一个对应的目录里边，比如将这个目录命名为build：\n\n```powershell\nmakedir build\ncd build\ncmake ..\n```\n\n当命令执行完毕之后，在build目录中会生成一个makefile文件\n\n#### 1.3定义变量\n\n在上面的例子中一共提供了5个源文件，假设这五个源文件需要反复被使用，每次都直接将它们的名字写出来确实是很麻烦，此时我们就需要定义一个变量，将文件名对应的字符串存储起来，在cmake里定义变量需要使用set。\n\n```cmake\n# SET 指令的语法是：\n# [] 中的参数为可选项, 如不需要可以不写\nSET(VAR [VALUE] [CACHE TYPE DOCSTRING [FORCE]])\n```\n\n- VAR：变量名\n- VALUE：变量值\n\n```cmake\n# 方式1: 各个源文件之间使用空格间隔\nset(SRC_LIST add.c  div.c   main.c  mult.c  sub.c)\n\n# 方式2: 各个源文件之间使用分号 ; 间隔\nset(SRC_LIST add.c;div.c;main.c;mult.c;sub.c)\nadd_executable(app  ${SRC_LIST})\n```\n\n#### 1.4指定C++版本\n\n```cmake\n$ g++ *.cpp -std=c++11 -o app\n```\n\n上面的例子中通过参数-std=c++11指定出要使用c++11标准编译程序\n\nC++标准对应有一宏叫做`DCMAKE_CXX_STANDARD`。\n\n**在CMake中想要指定C++标准有两种方式：**\n\n1. 在 CMakeLists.txt 中通过 set 命令指定\n\n```cmake\n#增加-std=c++11\nset(CMAKE_CXX_STANDARD 11)\n#增加-std=c++14\nset(CMAKE_CXX_STANDARD 14)\n#增加-std=c++17\nset(CMAKE_CXX_STANDARD 17)\n```\n\n1. 在执行 cmake 命令的时候指定出这个宏的值\n\n```shell\n#增加-std=c++11\ncmake CMakeLists.txt文件路径 -DCMAKE_CXX_STANDARD=11\n#增加-std=c++14\ncmake CMakeLists.txt文件路径 -DCMAKE_CXX_STANDARD=14\n#增加-std=c++17\ncmake CMakeLists.txt文件路径 -DCMAKE_CXX_STANDARD=17\n```\n\n#### 1.5指定输出路径\n\n在CMake中指定可执行程序输出的路径，也对应一个宏，叫做`EXECUTABLE_OUTPUT_PATH`，它的值通过set命令进行设置:\n\n```shell\nset(HOME /home/robin/Linux/Sort)\nset(EXECUTABLE_OUTPUT_PATH ${HOME}/bin)\n```\n\n如果这个路径中的子目录不存在，会自动生成，无需自己手动创建\n\n#### 1.7搜索文件\n\n在编写CMakeLists.txt文件的时候不可能将项目目录的各个文件罗列出来，这样太麻烦也不现实。\n\n所以，在CMake中为我们提供了搜索文件的命令，可以使用`aux_source_directory`命令或者`file`命令。\n\n##### 1.7.1 aux_source_directory方式\n\n命令格式：`aux_source_directory(< dir > < variable >)`\n\n- dir：要搜索的目录\n- variable：将从dir目录下搜索到的源文件列表存储到该变量中\n\n```shell\ncmake_minimum_required(VERSION 3.0)\nproject(CALC)\ninclude_directories(${PROJECT_SOURCE_DIR}/include)\n# 搜索 src 目录下的源文件\naux_source_directory(${CMAKE_CURRENT_SOURCE_DIR}/src SRC_LIST)\nadd_executable(app  ${SRC_LIST})\n```\n\n##### 1.7.2 file方式\n\n命令格式：`file(GLOB/GLOB_RECURSE 变量名 要搜索的文件路径和文件类型)`\n\n- GLOB: 将指定目录下搜索到的满足条件的所有文件名生成一个列表，并将其存储到变量中。\n- GLOB_RECURSE：递归搜索指定目录，将搜索到的满足条件的文件名生成一个列表，并将其存储到变量中。\n\n```shell\nfile(GLOB MAIN_SRC ${CMAKE_CURRENT_SOURCE_DIR}/src/*.cpp)\nfile(GLOB MAIN_HEAD ${CMAKE_CURRENT_SOURCE_DIR}/include/*.h)\n```\n\n注释：`CMAKE_CURRENT_SOURCE_DIR` 宏表示当前访问的 CMakeLists.txt 文件所在的路径。\n\n\n\n#### 1.8头文件\n\n在编译项目源文件的时候，很多时候都需要将源文件对应的头文件路径指定出来，这样才能保证在编译过程中编译器能够找到这些头文件，并顺利通过编译。在CMake通过`include_directories`即可指定\n\n```shell\n基本格式：include_directories(headpath)\n例：\ninclude_directories(${PROJECT_SOURCE_DIR}/include)\n#PROJECT_SOURCE_DIR宏对应的值就是我们在使用cmake命令时，后面紧跟的目录，一般是工程的根目录\n```\n\n#### 1.9制作静态库和动态库\n\n命令格式：`add_library(库名称 STATIC 源文件1 [源文件2] ...)`\n\n静态库名字分为三部分：lib+库名字+.a，此处只需要指定出库名字即可\n\n```shell\ncmake_minimum_required(VERSION 3.0)\nproject(CALC)\ninclude_directories(${PROJECT_SOURCE_DIR}/include)\nfile(GLOB SRC_LIST \"${CMAKE_CURRENT_SOURCE_DIR}/src/*.cpp\")\n#制作静态库,生成libcalc.a\nadd_library(calc STATIC ${SRC_LIST})\n#制作动态库,生成libcalc.so\nadd_library(calc SHARED ${SRC_LIST})\n```\n\n这样最终就会生成对应的静态库文件`libcalc.a`和`libcalc.so`。\n\n##### 1.9.1指定静态库和动态库的输出路径：\n\n使用`LIBRARY_OUTPUT_PATH`，这个宏对应静态库文件和动态库文件都适用。\n\n```shell\ncmake_minimum_required(VERSION 3.0)\nproject(CALC)\ninclude_directories(${PROJECT_SOURCE_DIR}/include)\nfile(GLOB SRC_LIST \"${CMAKE_CURRENT_SOURCE_DIR}/src/*.cpp\")\n# 设置动态库/静态库生成路径\nset(LIBRARY_OUTPUT_PATH ${PROJECT_SOURCE_DIR}/lib)\n# 生成动态库\n#add_library(calc SHARED ${SRC_LIST})\n# 生成静态库\nadd_library(calc STATIC ${SRC_LIST})\n```\n\n#### 1.10链接静态库和动态库\n\n##### 1.10.1链接静态库\n\n命令格式：`link_libraries(<static lib> [<static lib>...])`\n\n- 可以是全名 libxxx.a\n- 也可以是掐头（lib）去尾（.a）之后的名字 xxx\n\n如果该静态库不是系统提供的（自己制作或者使用第三方提供的静态库）可能出现静态库找不到的情况，此时可以将静态库的路径也指定出来：`link_directories(<lib path>)`\n\n```shell\ncmake_minimum_required(VERSION 3.0)\nproject(CALC)\n# 搜索指定目录下源文件\nfile(GLOB SRC_LIST ${CMAKE_CURRENT_SOURCE_DIR}/src/*.cpp)\n# 包含头文件路径\ninclude_directories(${PROJECT_SOURCE_DIR}/include)\n# 包含静态库路径\nlink_directories(${PROJECT_SOURCE_DIR}/lib)\n# 链接静态库\nlink_libraries(calc)\nadd_executable(app ${SRC_LIST})\n```\n\n##### 1.10.2链接动态库\n\n```cmake\ntarget_link_libraries(\n    <target> \n    <PRIVATE|PUBLIC|INTERFACE> <item>... \n    [<PRIVATE|PUBLIC|INTERFACE> <item>...]...)\n```\n\n- target：动态库名；\n- PRIVATE|PUBLIC|INTERFACE：动态库可视权限，默认为PUBLIC\n\n动态库的`链接具有传递性`，如果动态库 A 链接了动态库B、C，动态库D链接了动态库A，此时动态库D相当于也链接了B、C\n\n```cmake\ncmake_minimum_required(VERSION 3.0)\nproject(TEST)\nfile(GLOB SRC_LIST ${CMAKE_CURRENT_SOURCE_DIR}/*.cpp)\n# 指定源文件或者动态库对应的头文件路径\ninclude_directories(${PROJECT_SOURCE_DIR}/include)\n# 指定要链接的动态库的路径\nlink_directories(${PROJECT_SOURCE_DIR}/lib)\n# 添加并生成一个可执行程序\nadd_executable(app ${SRC_LIST})\n# 指定要链接的动态库\ntarget_link_libraries(app pthread calc)\n```\n\n### 2、日志message\n\n`message`函数可以为用户打印一条消息\n\n```cmake\nmessage([STATUS|WARNING|AUTHOR_WARNING|FATAL_ERROR|SEND_ERROR] \"message to display\" ...)\n```\n\n- (无) ：重要消息\n- STATUS ：非重要消息\n- WARNING：CMake 警告, 会继续执行\n- AUTHOR_WARNING：CMake 警告 (dev), 会继续执行\n- SEND_ERROR：CMake 错误, 继续执行，但是会跳过生成的步骤\n- FATAL_ERROR：CMake 错误, 终止所有处理过程\n\n### 3、变量操作\n\n#### 3.1拼接\n\n```cmake\ncmake_minimum_required(VERSION 3.0)\nproject(TEST)\nset(TEMP \"hello,world\")\nfile(GLOB SRC_1 ${PROJECT_SOURCE_DIR}/src1/*.cpp)\nfile(GLOB SRC_2 ${PROJECT_SOURCE_DIR}/src2/*.cpp)\n# 追加(拼接)\nset(SRC_1 ${SRC_1} ${SRC_2} ${TEMP})\nmessage(STATUS \"message: ${SRC_1}\")\ncmake_minimum_required(VERSION 3.0)\nproject(TEST)\nset(TEMP \"hello,world\")\nfile(GLOB SRC_1 ${PROJECT_SOURCE_DIR}/src1/*.cpp)\nfile(GLOB SRC_2 ${PROJECT_SOURCE_DIR}/src2/*.cpp)\n# 追加(拼接)\nlist(APPEND SRC_1 ${SRC_1} ${SRC_2} ${TEMP})\nmessage(STATUS \"message: ${SRC_1}\")\n```\n\n#### 3.2字符串移除\n\n```cmake\ncmake_minimum_required(VERSION 3.0)\nproject(TEST)\nset(TEMP \"hello,world\")\nfile(GLOB SRC_1 ${PROJECT_SOURCE_DIR}/*.cpp)\n# 移除前日志\nmessage(STATUS \"message: ${SRC_1}\")\n# 移除 main.cpp\nlist(REMOVE_ITEM SRC_1 ${PROJECT_SOURCE_DIR}/main.cpp)\n# 移除后日志\nmessage(STATUS \"message: ${SRC_1}\")\n```\n\n### 4、宏定义\n\n```c\n#include <stdio.h>\n#define NUMBER  3\nint main()\n{\n    int a = 10;\n    #ifdef DEBUG\n    printf(\"我是一个程序猿, 我不会爬树...\\n\");\n    #endif\n    for(int i=0; i<NUMBER; ++i)\n    {\n        printf(\"hello, GCC!!!\\n\");\n    }\n    return 0;\n}\n```\n\n为了让测试更灵活，我们可以不在代码中定义这个宏，而是在测试的时候去把它定义出来，其中一种方式就是在gcc/g++命令中去指定，如下：\n\n```\n$ gcc test.c -DDEBUG -o app\n```\n\n在gcc/g++命令中通过参数 `-D`指定出要定义的宏的名字，其名字为`DEBUG`。\n\n在CMake中我们也可以做类似的事情，对应的命令叫做`add_definitions`\n\n```c\ncmake_minimum_required(VERSION 3.0)\nproject(TEST)\n# 自定义 DEBUG 宏\nadd_definitions(-DDEBUG)\nadd_executable(app ./test.c)\n```\n\n### 5、预定义宏\n\n![image-20240306212818441](Makefile和CMake/image-20240306212818441.png)\n\n### 6、嵌套的CMake\n\n如果项目很大，或者项目中有很多的源码目录，就得给每个源码目录都添加一个`CMakeLists.txt`文件（头文件目录不需要），这样每个文件都不会太复杂，而且更灵活，更容易维护。\n\n```c\n$ tree\n.\n├── build\n├── calc\n│   ├── add.cpp\n│   ├── CMakeLists.txt\n│   ├── div.cpp\n│   ├── mult.cpp\n│   └── sub.cpp\n├── CMakeLists.txt\n├── include\n│   ├── calc.h\n│   └── sort.h\n├── sort\n│   ├── CMakeLists.txt\n│   ├── insert.cpp\n│   └── select.cpp\n├── test1\n│   ├── calc.cpp\n│   └── CMakeLists.txt\n└── test2\n    ├── CMakeLists.txt\n    └── sort.cpp\n\n6 directories, 15 files\n```\n\n可以通过add_subdirectory建立父子节点关系\n\n```\nadd_subdirectory(source_dir [binary_dir] [EXCLUDE_FROM_ALL])\n```\n\n注：子节点可以使用读取父节点中的变量\n\n```cmake\ncmake_minimum_required(VERSION 3.0)\nproject(test)\n# 定义变量\n# 静态库生成的路径\nset(LIB_PATH ${CMAKE_CURRENT_SOURCE_DIR}/lib)\n# 测试程序生成的路径\nset(EXEC_PATH ${CMAKE_CURRENT_SOURCE_DIR}/bin)\n# 头文件目录\nset(HEAD_PATH ${CMAKE_CURRENT_SOURCE_DIR}/include)\n# 静态库的名字\nset(CALC_LIB calc)\nset(SORT_LIB sort)\n# 可执行程序的名字\nset(APP_NAME_1 test1)\nset(APP_NAME_2 test2)\n# 添加子目录\nadd_subdirectory(calc)\nadd_subdirectory(sort)\nadd_subdirectory(test1)\nadd_subdirectory(test2)\ncmake_minimum_required(VERSION 3.0)\nproject(CALCLIB)\naux_source_directory(./ SRC)\ninclude_directories(${HEAD_PATH})\nset(LIBRARY_OUTPUT_PATH ${LIB_PATH})\nadd_library(${CALC_LIB} STATIC ${SRC})\ncmake_minimum_required(VERSION 3.0)\nproject(SORTLIB)\naux_source_directory(./ SRC)\ninclude_directories(${HEAD_PATH})\nset(LIBRARY_OUTPUT_PATH ${LIB_PATH})\nadd_library(${SORT_LIB} SHARED ${SRC})\ncmake_minimum_required(VERSION 3.0)\nproject(CALCTEST)\naux_source_directory(./ SRC)\ninclude_directories(${HEAD_PATH})\nlink_directories(${LIB_PATH})\nlink_libraries(${CALC_LIB})\nset(EXECUTABLE_OUTPUT_PATH ${EXEC_PATH})\nadd_executable(${APP_NAME_1} ${SRC})\ncmake_minimum_required(VERSION 3.0)\nproject(SORTTEST)\naux_source_directory(./ SRC)\ninclude_directories(${HEAD_PATH})\nset(EXECUTABLE_OUTPUT_PATH ${EXEC_PATH})\nlink_directories(${LIB_PATH})\nadd_executable(${APP_NAME_2} ${SRC})\ntarget_link_libraries(${APP_NAME_2} ${SORT_LIB})\n```\n\n### 7、流程控制\n\n#### 7.1条件判断\n\n##### 7.1.1基本表达式\n\n```cmake\nif(<condition>)\n  <commands>\nelseif(<condition>) # 可选快, 可以重复\n  <commands>\nelse()              # 可选快\n  <commands>\nendif()\n```\n\n`if`和`endif`必须成对出现\n\n##### 7.1.2逻辑判断\n\n```cmake\nif(<cond1> AND <cond2>)且\nif(<cond1> OR <cond2>)或\nif(NOT <conditon>)非\n```\n\n##### 7.1.3比较\n\n```cmake\n小于：if(<variable|string> LESS <variable|string>)\n大于：if(<variable|string> GREATER <variable|string>)\n等于：if(<variable|string> EQUAL <variable|string>)\n小于等于：if(<variable|string> LESS_EQUAL <variable|string>)\n大于等于：if(<variable|string> GREATER_EQUAL <variable|string>)\n```\n\n##### 7.1.4文件操作\n\n```cmake\n#判断文件或目录是否存在\nif(EXISTS path-to-file-or-directory)\n#判断是否是目录\nif(IS_DIRECTORY path)\n#判断是否是软链接\nif(IS_SYMLINK file-name)\n#判断是否为绝对路径\nif(IS_ABSOLUTE path)\n```\n\n#### 7.2循环\n"},{"title":"Git使用方法","url":"/2024/03/06/Git使用方法/","content":"\nGitee和GitHub都为 **代码托管平台**\n\n### 生成公私钥\n\n```\nssh-keygen -t rsa -C \"xxxxx@xxx.xx\"\n```\n\nxxxxx@xxxxx.xx是你自己的账号邮箱。\n\n查看公钥`cat ~/.ssh/id_rsa.pub`\n\n### 将key添加到gitee\n\n打开Gitee->设置->ssh公钥\n\n![img](Git使用方法/1699105694521-5d268d30-726b-4b5a-9895-2d45fd23ef52.png)\n\n粘贴生成的公钥到gitee\n\n![img](Git使用方法/1699105780347-636db41e-af68-422d-89b8-e1588fffa6b2.png)\n\n### 克隆\n\n找到空白文件夹右键打开“open git bash here”\n\n```\ngit clone xx@xxxxxxxxxx:xx/xx\n```\n\n其中“xx@xxxxxxxxxx:xx/xx”在gitee项目可以找到\n\n![img](Git使用方法/1699105942560-56328cfc-867f-4c7d-9368-e7b10435a1fa.png)\n\n![img](Git使用方法/1699105982587-6855caff-ae6e-4da1-9d59-b298c2ded13c.png)\n\n### 关联本地工程到远程仓库\n\n我们如果本地有了工程文件，然后再在gitee上创建仓库。\n此时，可在本地库上使用命令 git remote add把它和 gitee 的远程库关联，如下\n\n```\ngit remote add 本地工程 git@gitee.com:vicczyq/test.git\n```\n\n`git remote -v`查看远程库信息\n\n`git remote rm 库名`删除已有的远程库\n\n### 添加文件\n\n![img](Git使用方法/1699106355673-79f18f62-a1da-4157-8619-6d830a0982e5.png)\n\n### 常用命令\n\n```cpp\ngit init \t\t\t\t\t#把当前目录变成git可以管理的仓库\ngit clone git地址 \t\t\t#克隆项目\ngit add readme.txt \t\t\t#添加一个文件，也可以添加文件夹\ngit add -A \t\t\t\t\t#添加全部文件\ngit rm test.txt \t\t\t#删除一个文件，也可以删除文件夹\ngit commit -a -m “some commit” #提交修改\ngit status \t\t\t\t\t#查看是否还有未提交\ngit log \t\t\t\t\t#查看最近日志\ngit reset --hard HEAD^ \t\t#版本回退一个版本\ngit reset --hard HEAD^^ \t#版本回退两个版本\ngit reset --hard HEAD~100 \t#版本回退多个版本\ngit remote add origin +地址 #远程仓库的提交（第一次链接）\ngit push -u origin master\t#仓库关联\ngit push \t\t\t\t\t#远程仓库的提交（第二次及之后）\ngit fetch \t\t\t\t\t#从远程获取代码库\ngit tag xxx \t\t\t\t#打tag\ngit tag \t\t\t\t\t#显示所有tag\ngit push --tag \t\t\t\t#提交tag\ngit branch -a \t\t\t\t#显示所有分支\ngit checkout 分支名 \t\t#切换分支\ngit merge git分支 \t\t\t#合并分支\n 然后继续执行以下命令\n //1、初始化仓库    \n $ git init\n //2、把本地文件放入暂存区\n $ git add .\n //3、把 暂存区文件放入本地仓库\n git commit -m \"个人主页\"\n //4、git remote add origin 你的仓库地址\n git remote add origin https://gitee.com/.......\n //5.把本地仓库的网站推送到码云远程仓库\n git push -u origin master\n```\n"},{"title":"QT6开发","url":"/2024/03/04/QT6开发/","content":"\n[爱编程的大丙](https://subingwen.cn/qt/qt-primer/)\n\n# 简介\n\nQt是一个**跨平台的应用程序开发框架**，也是主流的C++框架\n\nQT = 开发工具 + 库类\n\n# 1 项目创建\n\n- 项目工程路径不要有特殊符号，不要有中文\n- 创建类的基类：**带菜单栏的窗口**（QMainWindow），**空白窗口**（QWidget），**对话框窗口**（QDialog）\n\n![image-20240313172002211](QT6开发/image-20240313172002211.png)\n\n# 2 基础知识\n\n## 2.1 窗口显示\n\n![窗口类继承关系](QT6开发/image-20200909165056959-9643bd7ed74c4966a3cb02f59a3366fd.png)\n\n**内嵌窗口：**\n\n- 窗口依附于某一个大窗口，作为大窗口的一部分\n- 大窗口就是这个内嵌窗口的父窗口\n- **父窗口显示的时候，内嵌窗口就被显示出来了**\n\n```cpp\n#include \"widget.h\"\n#include \"ui_widget.h\"\n#include \"testwindow.h\"\nWidget::Widget(QWidget *parent) :\n    QWidget(parent),\n    ui(new Ui::Widget)\n{\n    ui->setupUi(this);\n    TestWindow *t=new TestWindow(this);//内嵌窗口，无需show\n}\n\nWidget::~Widget()\n{\n    delete ui;\n}\n```\n\n**非内嵌窗口：**\n\n- 需要调用show()函数才可以显示\n\n### 2.1.1 Dialog的模态和非模态\n\n```cpp\nTestWindow *t=new TestWindow(this);\nt->show();//非模态，鼠标聚焦不会锁定\nt->exec();//模态，鼠标聚焦会锁定\n```\n\n模态时候不关闭当前窗口，其他窗口无法点击\n\n## 2.2 坐标体系\n\n![image-20240313181750885](QT6开发/image-20240313181750885.png)\n\n子窗口的初始位置采用的是**父窗口的坐标系**\n\n![image-20240313182128608](QT6开发/image-20240313182128608.png)\n\n## 2.3 内存回收机制\n\n![对象树](QT6开发/image-20200909165237496-61f1fa9d723c49ebb21df56de70f04b1.png)\n\nQt中有内存回收机制, 但是不是所有被new出的对象被自动回收, 满足条件才可以回收\n\n- 创建的对象必须是QObject类的子类(间接子类也可以)\n\n- 创建出的类对象, 必须要指定其父对象是谁, 一般情况下有两种操作方式:\n\n```cpp\n// 方式1: 通过构造函数\n// parent: 当前窗口的父对象, 找构造函数中的 parent 参数即可\nQWidget::QWidget(QWidget *parent = Q_NULLPTR, Qt::WindowFlags f = Qt::WindowFlags());\nQTimer::QTimer(QObject *parent = nullptr);\n\n// 方式2: 通过setParent()方法\n// 假设这个控件没有在构造的时候指定符对象, 可以调用QWidget的api指定父窗口对象\nvoid QWidget::setParent(QWidget *parent);\nvoid QObject::setParent(QObject *parent);\n```\n\nQObject类是没有父类的, Qt中有很大一部分类都是从这个类派生出去的\n\nQt中使用频率很高的窗口类和控件都是 QObject 的直接或间接的子类\n\n## 2.4 QT数据\n\n### 2.4.1 基础数据类型\n\nQt中也定义了一些属于自己的数据类型, 定义在`#include <QtGlobal>` 中,\n\n具体见：[QT基本数据类型](https://subingwen.cn/qt/qt-basetype/#1-%E5%9F%BA%E7%A1%80%E7%B1%BB%E5%9E%8B)\n\n### 2.4.2 日志输出\n\n> 在Qt中进行log输出, 一般不使用c中的`printf`, 也不是使用C++中的`cout`,\n>\n> Qt框架提供了专门用于日志输出的类, 头文件名为 `QDebug`\n\n```cpp\n#include <QDebug>\n// 包含了QDebug头文件, 直接通过全局函数 qDebug() 就可以进行日志输出了\nqDebug() << \"芜湖\" << endl;\n```\n\n如果要在生成的exe运行时，看到debug的信息，可做以下操作\n\n在`.pro`构建文件中修改`CONFIG`，设置`CONFIG += console`\n\n不仅有`qDebug()`，还有`qWarning()`、`qInfo()`、`qCritical() `\n\n### 2.4.3 字符串类型\n\n> C => char *\n>\n> C++ => string\n>\n> QT => QByteArray、QString\n\n#### 2.4.3.1 QBtreArray\n\n构造函数\n\n```cpp\n// 构造空对象, 里边没有数据\nQByteArray::QByteArray();\n// 将data中的size个字符进行构造, 得到一个字节数组对象\n// 如果 size==-1 函数内部自动计算字符串长度, 计算方式为: strlen(data)\nQByteArray::QByteArray(const char *data, int size = -1);\n// 构造一个长度为size个字节, 并且每个字节值都为ch的字节数组\nQByteArray::QByteArray(int size, char ch);\n```\n\n数据操作\n\n```cpp\n// 在尾部追加数据\nQByteArray &QByteArray::append(const QByteArray &ba);\nvoid QByteArray::push_back(const QByteArray &other);\n\n// 头部添加数据\nQByteArray &QByteArray::prepend(const QByteArray &ba);\nvoid QByteArray::push_front(const QByteArray &other);\n\n// 插入数据, 将ba插入到数组第 i 个字节的位置(从0开始)\nQByteArray &QByteArray::insert(int i, const QByteArray &ba);\n\n// 删除数据\n// 从大字符串中删除len个字符, 从第pos个字符的位置开始删除\nQByteArray &QByteArray::remove(int pos, int len);\n// 从字符数组的尾部删除 n 个字节\nvoid QByteArray::chop(int n);\n// 从字节数组的 pos 位置将数组截断 (前边部分留下, 后边部分被删除)\nvoid QByteArray::truncate(int pos);\n// 将对象中的数据清空, 使其为null\nvoid QByteArray::clear();\n\n// 字符串替换\n// 将字节数组中的 子字符串 before 替换为 after\nQByteArray &QByteArray::replace(const QByteArray &before, const QByteArray &after);\n```\n\n查找和判断\n\n```cpp\n// 判断字节数组中是否包含子字符串 ba, 包含返回true, 否则返回false\nbool QByteArray::contains(const QByteArray &ba) const;\nbool QByteArray::contains(const char *ba) const;\n// 判断字节数组中是否包含子字符 ch, 包含返回true, 否则返回false\nbool QByteArray::contains(char ch) const;\n\n// 判断字节数组是否以字符串 ba 开始, 是返回true, 不是返回false\nbool QByteArray::startsWith(const QByteArray &ba) const;\nbool QByteArray::startsWith(const char *ba) const;\n// 判断字节数组是否以字符 ch 开始, 是返回true, 不是返回false\nbool QByteArray::startsWith(char ch) const;\n\n// 判断字节数组是否以字符串 ba 结尾, 是返回true, 不是返回false\nbool QByteArray::endsWith(const QByteArray &ba) const;\nbool QByteArray::endsWith(const char *ba) const;\n// 判断字节数组是否以字符 ch 结尾, 是返回true, 不是返回false\nbool QByteArray::endsWith(char ch) const;\n```\n\n遍历\n\n```cpp\n// 使用迭代器\niterator QByteArray::begin();\niterator QByteArray::end();\n\n// 使用数组的方式进行遍历\n// i的取值范围 0 <= i < size()\nchar QByteArray::at(int i) const;\nchar QByteArray::operator[](int i) const;\n```\n\n空间和大小\n\n```cpp\n// 返回字节数组对象中字符的个数\nint QByteArray::length() const;\nint QByteArray::size() const;\nint QByteArray::count() const;\n\n// 返回字节数组对象中 子字符串ba 出现的次数\nint QByteArray::count(const QByteArray &ba) const;\nint QByteArray::count(const char *ba) const;\n// 返回字节数组对象中 字符串ch 出现的次数\nint QByteArray::count(char ch) const;\n```\n\n数据类型转换\n\n```cpp\n// 将QByteArray类型的字符串 转换为 char* 类型\nchar *QByteArray::data();\nconst char *QByteArray::data() const;\n\n// int, short, long, float, double -> QByteArray\nQByteArray &QByteArray::setNum(int n, int base = 10);\nQByteArray &QByteArray::setNum(short n, int base = 10);\nQByteArray &QByteArray::setNum(qlonglong n, int base = 10);\nQByteArray &QByteArray::setNum(float n, char f = 'g', int prec = 6);\nQByteArray &QByteArray::setNum(double n, char f = 'g', int prec = 6);\n[static] QByteArray QByteArray::number(int n, int base = 10);\n[static] QByteArray QByteArray::number(qlonglong n, int base = 10);\n[static] QByteArray QByteArray::number(double n, char f = 'g', int prec = 6);\n\n// QByteArray -> int, short, long, float, double\nint QByteArray::toInt(bool *ok = Q_NULLPTR, int base = 10) const;\nshort QByteArray::toShort(bool *ok = Q_NULLPTR, int base = 10) const;\nlong QByteArray::toLong(bool *ok = Q_NULLPTR, int base = 10) const;\nfloat QByteArray::toFloat(bool *ok = Q_NULLPTR) const;\ndouble QByteArray::toDouble(bool *ok = Q_NULLPTR) const;\n\n// std::string -> QByteArray\n[static] QByteArray QByteArray::fromStdString(const std::string &str);\n// QByteArray -> std::string\nstd::string QByteArray::toStdString() const;\n\n// 所有字符转换为大写\nQByteArray QByteArray::toUpper() const;\n// 所有字符转换为小写\nQByteArray QByteArray::toLower() const;\n```\n\n#### 2.4.3.2 QString\n\n构造函数\n\n```cpp\n// 构造一个空字符串对象\nQString::QString();\n// 将 char* 字符串 转换为 QString 类型\nQString::QString(const char *str);\n// 将 QByteArray 转换为 QString 类型\nQString::QString(const QByteArray &ba);\n```\n\n数据操作\n\n```cpp\n// 尾部追加数据\nQString &QString::append(const QString &str);\nQString &QString::append(const char *str);\nQString &QString::append(const QByteArray &ba);\nvoid QString::push_back(const QString &other);\n\n// 头部添加数据\nQString &QString::prepend(const QString &str);\nQString &QString::prepend(const char *str);\nQString &QString::prepend(const QByteArray &ba);\nvoid QString::push_front(const QString &other);\n\n// 插入数据, 将 str 插入到字符串第 position 个字符的位置(从0开始)\nQString &QString::insert(int position, const QString &str);\nQString &QString::insert(int position, const char *str);\nQString &QString::insert(int position, const QByteArray &str);\n\n// 删除数据\n// 从大字符串中删除len个字符, 从第pos个字符的位置开始删除\nQString &QString::remove(int position, int n);\n\n// 从字符串的尾部删除 n 个字符\nvoid QString::chop(int n);\n// 从字节串的 position 位置将字符串截断 (前边部分留下, 后边部分被删除)\nvoid QString::truncate(int position);\n// 将对象中的数据清空, 使其为null\nvoid QString::clear();\n\n// 字符串替换\n// 将字节数组中的 子字符串 before 替换为 after\n// 参数 cs 为是否区分大小写, 默认区分大小写\nQString &QString::replace(const QString &before, const QString &after, Qt::CaseSensitivity cs = Qt::CaseSensitive);\n```\n\n查找和判断\n\n```cpp\n// 参数 cs 为是否区分大小写, 默认区分大小写\n\n// 判断字符串中是否包含子字符串 str, 包含返回true, 否则返回false\nbool QString::contains(const QString &str, Qt::CaseSensitivity cs = Qt::CaseSensitive) const;\n\n// 判断字符串是否以字符串 ba 开始, 是返回true, 不是返回false\nbool QString::startsWith(const QString &s, Qt::CaseSensitivity cs = Qt::CaseSensitive) const;\n\n// 判断字符串是否以字符串 ba 结尾, 是返回true, 不是返回false\nbool QString::endsWith(const QString &s, Qt::CaseSensitivity cs = Qt::CaseSensitive) const;\n```\n\n遍历\n\n```cpp\n// 使用迭代器\niterator QString::begin();\niterator QString::end();\n\n// 使用数组的方式进行遍历\n// i的取值范围 0 <= position < size()\nconst QChar QString::at(int position) const\nconst QChar QString::operator[](int position) const;\n```\n\n空间和大小\n\n```cpp\n// 返回字节数组对象中字符的个数 (字符个数和字节个数是不同的概念)\nint QString::length() const;\nint QString::size() const;\nint QString::count() const;\n\n// 返回字节串对象中 子字符串 str 出现的次数\n// 参数 cs 为是否区分大小写, 默认区分大小写\nint QString::count(const QStringRef &str, Qt::CaseSensitivity cs = Qt::CaseSensitive) const;\n```\n\n数据类型转换\n\n```cpp\n// 将int, short, long, float, double 转换为 QString 类型\nQString &QString::setNum(int n, int base = 10);\nQString &QString::setNum(short n, int base = 10);\nQString &QString::setNum(long n, int base = 10);\nQString &QString::setNum(float n, char format = 'g', int precision = 6);\nQString &QString::setNum(double n, char format = 'g', int precision = 6);\n[static] QString QString::number(long n, int base = 10);\n[static] QString QString::number(int n, int base = 10);\n[static] QString QString::number(double n, char format = 'g', int precision = 6);\n\n// 将 QString 转换为 int, short, long, float, double 类型\nint QString::toInt(bool *ok = Q_NULLPTR, int base = 10) const;\nshort QString::toShort(bool *ok = Q_NULLPTR, int base = 10) const;\nlong QString::toLong(bool *ok = Q_NULLPTR, int base = 10) const\nfloat QString::toFloat(bool *ok = Q_NULLPTR) const;\ndouble QString::toDouble(bool *ok = Q_NULLPTR) const;\n\n// 将标准C++中的 std::string 类型 转换为 QString 类型\n[static] QString QString::fromStdString(const std::string &str);\n// 将 QString 转换为 标准C++中的 std::string 类型\nstd::string QString::toStdString() const;\n\n// QString -> QByteArray\n// 转换为本地编码, 跟随操作系统\nQByteArray QString::toLocal8Bit() const;\n// 转换为 Latin-1 编码的字符串 不支持中文\nQByteArray QString::toLatin1() const;\n// 转换为 utf8 编码格式的字符串 (常用)\nQByteArray QString::toUtf8() const;\n\n// 所有字符转换为大写\nQString QString::toUpper() const;\n// 所有字符转换为小写\nQString QString::toLower() const;\n```\n\n### 2.4.4 QVariant\n\n几种不同的数据类型需要传递，如果用结构体，又不大方便，容器保存的也只是一种数据类型，而QVariant则可以统统搞定。\n","tags":["C++"]},{"title":"C++","url":"/2024/02/29/C/","content":"\n# 前序知识\n\n**变量**：给一段指定的内存空间起名，方便操作这段内存。\n\n\n\nC++定义常量的两种方式：\n\n1. **#define**宏常量：`#define 常量名 常量值`\n2. **const**修饰的变量：`const 数据类型 常量名 = 常量值`\n\n\n\n标识符的命名规则：\n\n- 标识符不能是关键字\n- 标识符只能由<u>字母、数字、下划线</u>组成\n- 第一个字符必须为字母或下划线\n- 标识符字母区分大小写\n\n\n\n# 1 初识知识\n\n## 1.1数据类型\n\n数据类型存在的意义：给变量分配合适的内存空间\n\n### 1.1.1整型\n\n![image-20240229211305122](C/image-20240229211305122.png)\n\n### 1.1.2浮点型\n\n![image-20240229211916435](C/image-20240229211916435.png)\n\n### 1.1.3字符型\n\n字符型变量用于显示单个字符\n\n语法：`char ch = 'a'`\n\n注意：\n\n- C和C++中字符型变量只占用1个字节\n- 字符型变量并不是把字符本身放到内存中进行存储，而是将对应的ASCII码存储\n\n### 1.1.4转义字符\n\n用于表示一些不能显示出来的ASCII字符\n\n![image-20240229212521459](C/image-20240229212521459.png)\n\n### 1.1.5字符串\n\nC风格字符串：`char str[ ] = \"abcdefg\"`\n\nC++风格字符串：`string str = \"abcdefg\"`\n\n```cpp\n#include <iostream>\n#include <string>\n//注意，C++风格要加string头文件\nusing namespace std;\nint main()\n{\n    char str1[]=\"abcd\";\n    string str2=\"abcd\";\n    return 0;\n}\n```\n\n### 1.1.6布尔类型\n\n**作用：**布尔数据类型代表真或者假的值\n\nbool占用1个字节的大小\n\n### 1.1.7数据的输入和输出\n\n关键字：cin、cout\n\n语法：`cin >> 变量名`和`cout << 变量名`\n\n### 1.1.8程序的流程结构\n\nC/C++支持最基本的三种程序运行结构：==顺序结构==、==选择结构==、==循环结构==\n\n### 1.1.9一维数组\n\n一维素组定义的三种方式：\n\n- `int a[10]={1,2,3,4}`\n- `int a[]={1,2,3,4} `\n\n### 1.1.10一维数组-冒泡排序\n\n```cpp\n#include <iostream>\nusing namespace std;\nint main()\n{\n\tint a[] = {4,5,3,10,2,8,32};\n    //寻找n轮最大值\n\tfor (int i = 0; i < 7; i++)\n\t{\n        //每一轮进行n-i-1次判断和交换，得出该轮的最大值\n\t\tfor (int j = 0; j < 7-i-1; j++)\n\t\t{\n\t\t\tif (a[j] < a[j + 1])\n\t\t\t{\n\t\t\t\tint temp = a[j];\n\t\t\t\ta[j] = a[j + 1];\n\t\t\t\ta[j + 1] = temp;\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 0; i < 7; i++)cout << a[i] << '\\t';\n\treturn 0;\n}\n```\n\n- 比较相邻的元素。如果第一个比第二个大，就交换他们两个。\n- 对每一对相邻元素做同样的工作，执行完毕后，找到第一个最大值。\n- 重复上面的步骤，每次比较数-1，直到不需要比较。\n\n![img](C/afb80e39ce7684d6330fdc66b0873abd.gif)\n\n### 1.1.11二维数组\n\n**定义方式：**\n\n`int a[2][2]={{数据1,数据2},{数据3,数据4}}`\n\n`int a[2][2]={数据1,数据2,数据3,数据4}`\n\n`int a[][2]={数据1,数据2,数据3,数据4}`\n\n注意：必须要指明**列数**，行数可以无需指明\n\n### *1.1.12函数的分文件编写\n\n步骤：\n\n- 创建后缀名为.h的头文件，在头文件中写函数声明\n- 创建后缀名为.cpp的源文件，在源文件中写函数的实现\n\nmain文件\n\n```cpp\n#include <iostream>\n#include \"swap.h\"\nusing namespace std;\nint main()\n{\n    int a=0,b=1;\n    swap(&a,&b);\n    cout<<a<<b<<endl;\n    return 0;\n}\n```\n\nswap.h\n\n```cpp\nvoid swap(int *a,int *b);\n```\n\nswap.cpp\n\n```cpp\n#include \"swap.h\"\nvoid swap(int *a,int *b)\n{\n\tint temp=*a;\n    *a=*b;\n    *b=temp;\n}\n```\n\n### 1.1.13指针相关\n\n指针的本质就是一个十六进制的数，用于表示地址，在32位下占用4字节，64位下占用8字节\n\n**空指针**：指向编号为0的空间，用于初始化指针变量，`int *a = NULL`，\n\n注意：空指针是==不可访问的==，0~255之间的编号是系统占用的，因此不可访问\n\n**野指针**：指向非法的内存空间（不是自己申请的空间），`int *p=(int *)0x1100`\n\n**const修饰指针**：\n\n1. const修饰指针：**常量指针**`const int * p`\n2. const修饰常量：**指针常量** `int * const p `\n3. const既修饰指针，又修饰常量`const int * const p`\n\n```cpp\nconst int *p = &a; //常量指针\np = &b;\n*p = 20;//这个操作是错误的\n//特点:指针指向可以改，但指针指向的值不可以改\n```\n\n```cpp\nint * const p = &a;//指针常量\np = &b;//这个操作是错误的\n*p = 20;\n//特点：指针的指向不可以改，但指针指向的值可以改\n```\n\n```cpp\nconst int* const p=&a;\n//特点：指针指向和值都不可以改\n```\n\n看const位置，只要**const紧跟**的就可以修改，可以理解为锁定变量指针\n\n### 1.1.14结构体\n\n语法：`struct 结构体名 {成员列表}`\n\n```cpp\nstruct student\n{\n\tstring name;\n\tint age;\n\tint score;\n};\n\nint main()\n{\n    struct student Stu1={\"ZhangSan\",18,90};\n    //C++中结构体创建struct关键字可以省略\n    student Stu2 = {\"LiSi\",18,80};\n    return 0;\n}\n```\n\n```cpp\nstruct student\n{\n\tstring name;\n\tint age;\n\tint score;\n}Stu;//顺便定义\n\nint main()\n{\n    Stu.name=\"ZhangSan\";\n    Stu.age=18;\n    Stu.score=90;\n    return 0;\n}\n```\n\n## 1.2 climits头文件\n\n定义了各种整型数据的最大值和最小值\n\n```cpp\n#include <climits>\n```\n\n![image-20240305105400635](C/image-20240305105400635.png)\n\n![image-20240305105423398](C/image-20240305105423398.png)\n\n```cpp\n#define INT_MAX 2147483647\n```\n\n头文件中有许多如上的指令\n\n`#define`也是一个预处理编译指令，告诉编译器将INT_MAX替换为2147483647\n\n# 2 C++核心编程\n\n## 2.1内存分区模型\n\nC++程序在执行时，将内存大方向划分为**4个区域**\n\n- 代码区：用于存放函数的二进制代码，由操作系统进行管理\n- 全局区：存放全局变量和静态变量(static)以及常量(const)\n- 栈区：由编译器自动分配释放，存放函数参数和局部变量等\n- 堆区：由程序员分配和释放，若程序员不释放，程序结束由操作系统回收\n\n内存分区的意义：不同区域存放的数据，赋予不同的生命周期，更为灵活的编程\n\n代码区和全局区都是在**程序运行前**就存在，栈区和堆区都在**程序运行时**才会分配\n\n### 2.1.1堆区开辟和释放\n\n```cpp\nint * p1 = new int(10);//p1指向一个值为10的int数\nint * p2 = new int[20];//开辟20长度的数组空间\nint * p3 = (int *)malloc(20*sizeof(int));\n//指针p1,p2,p3本质上还是一个局部变量，放在栈上的，但指针指向的空间在堆区\n```\n\n```cpp\ndelete(p1);\nfree(p2);\n```\n\n## 2.2引用&\n\n本质就是指针常量(`int* const ref = &a`)，**指向不可改变，值可改**\n\n```cpp\nint a=10;\nint &b=a;\n```\n\n注意，b并不是指针，是对a的引用，**给一个变量起别名**\n\n区别就在于，引用**必须初始化**，创建后不可以改变指向，指针可以修改指向\n\n**注意**：引用可以用作函数返回值，但是不要返回局部变量的引用，因为在函数结束后，栈区会释放。\n\n## 2.3函数提高\n\n### 2.3.1函数形参\n\n在C++中，函数的形参列表可以设置默认值\n\n```cpp\nint func(int a,int b = 10, int c=20)\n{\n\t//默认值，如果没有传入b/c就按默认值来\n    //注意：此时的a必须传入，否则会报错\n}\n```\n\n如果某个位置已经有了默认参数，那么从这个位置往后，都必须有默认参数\n\n```cpp\nint func(int a,int b =10, int c)//这种情况会报错\n```\n\n函数的声明和实现**只能一个有默认参数**，不能同时有\n\n```cpp\nint func(int a,int b=10,int c=20);//声明\nint func(int a, int b,int c){\t}//实现\n\nint func(int a, int b,int c);//声明\nint func(int a, int b=10, int c=20){ }//实现\n```\n\n### 2.3.2占位参数\n\n```cpp\nvoid func(int a, int){ }\n```\n\n调用函数时必须填补该参数\n\n```cpp\nfunc(1,100);//100即填充，可以填任意数\n```\n\n### 2.3.3函数重载\n\n**作用：**函数名可以相同，提高复用性\n\n- 同一个作用域下，函数名相同\n- 函数参数 **类型不同** 或 **个数不同** 或 **顺序不同**\n\n```cpp\nvoid func(int a)\n{\n\tcout<<\"int函数:\"<<a<<endl;\n}\nvoid func(double a)\n{\n\tcout<<\"double函数：\"<<a<<endl;\n}\n```\n\n**注意：**\n\n函数重载碰到默认参数时，默认参数是不计的\n\n```cpp\nint func(int a,int b=10,int c=20){ }\nint func(int a);\n//上面代码是错误的，无法发生函数重载\n```\n\n函数重载碰到引用时，\n\n```cpp\nvoid func(int &a)//调用func(a)变量\n\nvoid func(const int &a)//调用func(10)常量\n```\n\n## 2.4类和对象\n\nC++面向对象的三大特征：**<u>封装</u>**、**<u>继承</u>**、**<u>多态</u>**\n\n万事万物皆为对象，对象上有其属性和行为\n\n- struct 默认权限为公共 public\n- class 默认权限为私有 private\n\n### 2.4.1封装\n\n封装的意义：\n\n- 将属性和行为作为一个整体，表现生活中的事物\n- 将属性和行为加以权限控制\n\n```cpp\n#include <iostream>\n#include <string>\nusing namespace std;\nclass circle\n{\npublic://访问权限：公共权限\n    double r;\n    const double PI = 3.1415926;//属性\n    \n    double calculateZC()//行为\n    {\n        return 2 * PI * r;\n    }\n};//注意这里的分号\nint main()\n{\n    circle c1;//创建对象(实例化)\n    c1.r = 1.0;//赋值\n    cout << c1.calculateZC() << endl;\n    return 0;\n}\n```\n\n### 2.4.2权限\n\n- **public** 公共权限\n- **protected** 保护权限\n- **private** 私有权限（默认）\n\n```cpp\n//公共权限\tpublic\t\t类内可以访问，类外也可以访问\n//保护权限\tprotected\t类内可以访问，类外不可以访问(子类可以访问)\n//私有权限\tprivate\t\t类内可以访问，类外不可以访问(子类不能访问)\nclass Person\n{\npublic:\n\tstring name;    \nprotected:\n    string id;\nprivate:\n    int password;\n};\n```\n\n类中成员的默认权限为**private**\n\n```cpp\n#include <iostream>\n#include <string>\nusing namespace std;\nclass Cube\n{\nprivate:\n    double l, w, h;\npublic:\n    void setLWH(double ll, double ww, double hh)\n    {\n        l = ll;\n        w = ww;\n        h = hh;\n    }\n    double getV()\n    {\n        return l * w * h;\n    }\n    double getA()\n    {\n        return 2 * (l * w + w * h + l * h);\n    }\n    bool ifequ(Cube x)\n    {\n        return x.l == l && x.h == h && x.w == w ? true : false;\n    }\n};\nint main()\n{\n    Cube a,b;\n    a.setLWH(1, 2, 3);\n    b.setLWH(1, 2, 3);\n    cout << \"面积为：\" << a.getA() << \"体积为：\" << a.getV() << endl;\n    cout << \"是否相等\" << a.ifequ(b) << endl;\n    return 0;\n}\n```\n\n### 2.4.3对象的初始化和清理(构造和析构)\n\n如果我们不提供构造函数和析构函数，编译器会提供**空实现**的构造函数和析构函数\n\n- **构造函数：**主要作用在于创建对象时为对象成员属性赋值，构造函数由编译器自动调用，无需手动调用\n- **析构函数：**主要作用在于对象销毁前系统自动调用，执行一些清理工作\n\n构造函数可以**有参数**，可以发生重载\n\n析构函数**不能有参数**，不能发生重载\n\n```cpp\nclass Person\n{\npublic:\n    Person()//构造函数\n    {\n        \n    }\n    ~Person()//析构函数\n    {\n        \n    }\n};\n```\n\n#### 2.4.3.1构造函数的分类及调用\n\n**分类：**有参构造、无参构造（普通构造）/拷贝构造\n\n**调用：**括号法、显示法、隐式转换法\n\n```cpp\nclass Person\n{\npublic:\n    int age;\n    Person()//普通构造\n    {\n        cout<<\"无参构造函数调用\"<<endl;\n    }\n    Person(int a)//普通构造\n    {\n        age = a;\n        cout<<\"有参构造函数调用\"<<endl;\n    }\n    Person(const Person &p )//拷贝构造\n    {\n        age = p.age;\n    }\n}\n```\n\n```cpp\nvoid test()\n{\n    1、括号法\n    Person p1;//默认构造函数，不需要加()，如果加了()编译器会认为是一个函数声明\n    Person p2(10);//有参构造函数\n    Person p3(p2);//拷贝构造函数\n\n\t2、显示法\n    Person p2 = Person(10);\n    Person p3 = Person(p2);\n    \t补充：Person(10);//匿名对象 特点：当前行执行结束就回收\n    \n    3、隐式转换法\n    Person p4 = 10;\n    Person p5 = p4;\n}\n```\n\n#### 2.4.3.2拷贝构造函数调用时机\n\n- 使用一个已经创建完毕的对象来初始化新对象\n- 值传递的方式给函数参数传值\n- 以值方式返回局部对象\n\n```cpp\nvoid test01()\n{\n\tPerson p;\n\tPerson p1(p);\n}\n```\n\n```cpp\nvoid doWork(Person p)\n{\n}\nvoid test02()\n{\n\tPerson p;\n\tdoWork(p);\n}\n```\n\n```cpp\nPerson doWork()\n{\n\tPerson p3;\n\treturn p3;\n}\nvoid test03()\n{\n    Person p = doWork();\n}\n```\n\n#### 2.4.3.3构造函数的调用规则\n\n默认的拷贝构造函数会进行**值拷贝**，其他的构造函数都是空实现的\n\n- 如果用户定义了有参构造函数，C++不再提供默认的无参构造函数，但会提供默认的拷贝构造\n- 如果用户定义了拷贝构造函数，C++不会再提供其他构造函数\n\n#### 2.4.3.4深拷贝和浅拷贝\n\n**浅拷贝**：简单的赋值拷贝操作(=)\n\n**深拷贝**：在堆区重新申请内存空间，进行拷贝操作\n\n拷贝构造带来的问题：\n\n```cpp\n#include <iostream>\n#include <string>\nusing namespace std;\nclass Stu\n{\npublic:\n\tstring name;\n\tint* m_height;\n\tStu(string a, int height)\n\t{\n\t\tname = a;\n\t\tm_height = new int(height);\n\t}\n\t~Stu()\n\t{\n\t\tif (m_height != NULL)\n\t\t{\n\t\t\tdelete(m_height);\n\t\t\tm_height = NULL;\n\t\t}\n\t}\n};\nint main()\n{\n\tStu c1(\"vicczyq\", 172);\n\tStu c2(c1);\n\treturn 0;\n}\n\n```\n\n这段代码，c2会拷贝c1的值，但是他拷贝的是**指针**，是同一个地址，当c2先析构后，c1析构时候释放内存会出错崩溃\n\n![image-20240301224532559](C/image-20240301224532559.png)\n\n因此，在进行拷贝时，要新申请一个空间，这样才能解决\n\n```cpp\n#include <iostream>\n#include <string>\nusing namespace std;\nclass Stu\n{\npublic:\n\tstring name;\n\tint* m_height;\n\tStu(string a, int height)\n\t{\n\t\tname = a;\n\t\tm_height = new int(height);\n\t}\n    Stu(const Stu &p)\n    {\n        //m_height = p.m_height;//浅拷贝(不会申请新的空间)\n        m_height = new int(*p.m_height);//深拷贝(申请新空间)\n        name = p.name;\n    }\n\t~Stu()\n\t{\n\t\tif (m_height != NULL)\n\t\t{\n\t\t\tdelete(m_height);\n\t\t\tm_height = NULL;\n\t\t}\n\t}\n};\nint main()\n{\n\tStu c1(\"vicczyq\", 172);\n\tStu c2(c1);\n\treturn 0;\n}\n```\n\n#### 2.4.3.5初始化列表\n\n```cpp\nclass Person\n{\npublic:\n\tint m_a,m_b,m_c;\n\tPerson(int a, int b, int c) : m_a(a),m_b(b),m_c(c)\n\t{\n\t\n\t}\n};\n```\n\n#### 2.4.3.6类对象作为类成员\n\n```cpp\n#include <iostream>\n#include <string>\nusing namespace std;\nclass A\n{\npublic:\n\tA()\n\t{\n\t\tcout << \"A构造\" << endl;\n\t}\n};\nclass B\n{\n\tA a;\npublic:\n\tB()\n\t{\n\t\tcout << \"B构造\" << endl;\n\t}\n};\nint main()\n{\n\tB x;\n\treturn 0;\n}\n```\n\n![image-20240301230820745](C/image-20240301230820745.png)\n\n证明，构造B时，需要先完成A的构造\n\n#### 2.4.3.7 static静态成员变量\n\n- 所有对象都共享同一份数据。\n\n- 编译阶段就会进行内存分配（全局区）\n- 类内声明，类外进行初始化操作\n\n```cpp\nclass Person\n{\npublic:\n\tstatic int m_A;//类内声明\n}\nint Person::m_A = 100;//类外初始化\n\nvoid test()\n{\n    Person p1;\n    cout<< p1.m_A <<endl;//输出100\n    Person p2;\n    p2.m_A=200;\n    cout << p1.m_A << endl;//访问的任然是p1,但输出200\n}\n```\n\n静态成员变量不属于任何一个对象，所有对象都**共享一份数据**。\n\n所以可以通过两种方式进行访问：\n\n```cpp\nPerson p1;\ncout << p1.m_A << endl;//创建对象进行访问\ncout << Person::m_A <<endl;//通过类名进行访问\n```\n\n#### 2.4.3.8 static静态成员函数\n\n所有对象都共享一个函数，并且函数只能访问静态成员变量\n\n```cpp\nclass Person\n{\npublic:\n\tstatic int m_A;\n\t\n\tstatic void func()\n\t{\n\t\tcout << \"static void func调用\" << endl;\n        cout << m_A << endl; //只能访问静态成员变量\n\t}\n}\nint Person::m_A = 100;\n\nvoid test()\n{\n\tPerson p1;\n    p1.func();//通过对象访问\n    \n    Person::func();//通过类名访问\n}\n```\n\n### 2.4.4 C++对象模型和this指针\n\n#### 2.4.4.1 成员变量和成员函数分开存储\n\n注意：静态成员变量或函数不属于任何一个对象上。\n\n空对象占用的内存空间大小为：**1**\n\n只有非静态成员变量**属于**类的对象上，\n\n其他(静态成员变量、成员函数)都不属于类的对象上，也就是说只有一份。\n\n#### 2.4.4.2 this指针\n\n由2.4.4.1可知，多个对象会共享（静态成员变量、静态成员函数和非静态成员函数）。\n\n可以通过**this**指针区分对象调用\n\nthis指针指向**被调用的成员函数所属的对象**\n\n**用途：**\n\n- 当函数形参和成员变量同名时，可以用this来区分\n- 当类的非静态成员函数返回对象本身时，可以用`return *this`\n\n```cpp\nclass Person\n{\npublic:\n\tstring name;\n\tvoid setName(string name)\n    {\n    \tthis->name = name;\n    }\n    Person getInfo()\n    {\n        return *this;\n    }\n}\n```\n\n### 2.4.5 const修饰成员函数(常函数)\n\n- 常函数内不可以修改成员属性\n- 成员属性声明时加关键字`mutable`后，在常函数中依然可以修改\n\n对象创建时，加const称为常对象，常对象只能调用常函数。\n\n**主要是对函数内this指针的限制**\n\n```cpp\nclass Person\n{\npublic:\n\tvoid showPerson() const\n\t{\n\t\tthis -> m_A = 100;//报错，const修饰this指向的值不可修改\n\t\tthis -> m_B = 100;//有mutable关键字可修改\n\t}\n\t\n\tint m_A;\n\tmutable int m_B;\n}\n```\n\n### 2.4.6 友元 friend\n\n让一个函数或者类 访问另一个类中的私有成员\n\n**友元的三种实现：**\n\n- 全局函数做友元\n- 类做友元\n- 成员函数做友元\n\n```cpp\n#include <iostream>\nusing namespace std;\nclass Building{\nfriend void goodGay(Building* building);//声明友元函数\npublic:\n\tstring m_SittingRoom;//客厅\n\tBuilding()\n\t{\n\t\tm_SittingRoom = \"客厅\";\n\t\tm_BedRoom = \"卧室\";\n\t}\nprivate:\n\t string m_BedRoom;//卧室\n};\n\nvoid goodGay(Building *building)\n{\n\tcout << \"Gay:\" << building->m_SittingRoom << endl;\n\tcout << \"Gay:\" << building->m_BedRoom << endl;\n}\nvoid main()\n{\n\tBuilding a;\n\tgoodGay(&a);\n}\n```\n\n```cpp\n#include <iostream>\n#include <string>\nusing namespace std;\nclass Building {\n\tfriend class GoodGay;\npublic:\n\tstring m_SittingRoom;//客厅\n\tBuilding()\n\t{\n\t\tm_SittingRoom = \"客厅\";\n\t\tm_BedRoom = \"卧室\";\n\t}\nprivate:\n\tstring m_BedRoom;\n};\n\nclass GoodGay {\npublic:\n\tBuilding* building = new Building;\n\tvoid visit();//函数声明，可以在类内实现，也可以在类外\n};\n\nvoid GoodGay::visit()//类外实现成员函数\n{\n\tcout << \"Gay:\" << building->m_SittingRoom << endl;\n\tcout << \"Gay:\" << building->m_BedRoom << endl;\n}\n\nvoid main()\n{\n\tGoodGay gay;\n}\n```\n\n```cpp\n#include <iostream>\n#include <string>\nusing namespace std;\nclass Home;\nclass GoodGay {\npublic:\n\tvoid func(Home* home);\n};\nclass Home {\nfriend void GoodGay::func(Home * home);\nprivate:\n\tint id = 10;\n};\n\nvoid GoodGay::func(Home* home)\n{\n\tcout << home->id << endl;\n}\nvoid main()\n{\n\tGoodGay a;\n\tHome home;\n\ta.func(&home);\n}\n```\n\n### 2.4.7 运算符重载\n\n对于内置的数据类型，编译器知道怎么进行数据运算\n\n但是对于其他的数据类型，需要自己定义计算方法\n\n#### 2.4.7.1 加号运算重载\n\n```cpp\nPerson p3 = p1+p2\n```\n\n通过**成员函数**重载”+“\n\n```cpp\nPerson operator+ (Person &p)\n{\n\tPerson temp;\n\ttemp.m_A = this->m_A + p.m_A;\n\ttemp.m_B = this->m_B + p.m_B;\n\treturn temp;\n}\n```\n\n通过**全局函数**重载”+“\n\n```cpp\nPerson operator+ (Person &p1, Person &p2)\n{\n    Person temp;\n    temp.m_A = p1.m_A + p2.m_A;\n    temp.m_B = p1.m_B + p2.m_B;\n    return temp;\n}\n```\n\n#### 2.4.7.2 左移运算符重载\n\n作用：自定义输出内容\n\n只能用全局函数进行重载\n\n```cpp\nostream & operator<<(ostream &cout,Person p)\n{\n\tcout << p.m_A;\n\treturn cout;\n }\n```\n\n#### 2.4.7.3 递增/减运算符重载\n\n作用：通过重载递增运算符，实现自己的整型数据\n\n```cpp\n#include <iostream>\n#include <string>\nusing namespace std;\nclass MyInt {\n\tfriend ostream & operator<<(ostream& out, MyInt& p);\npublic:\n\t//重载前置++运算符\n\t//返回引用的原因是要对同一个数据空间进行操作\n\t//如果不用引用，会复制出一个副本\n\tMyInt &operator++()\n\t{\n\t\ti++;\n\t\treturn *this;\n\t}\n\t//重载后置++运算符\n\tMyInt operator++(int)//返回的是值，因为temp在函数结束后就会释放\n\t{\n\t\tMyInt temp = *this;\n\t\ti++;\n\t\treturn temp;\n\t}\nprivate:\n\tstring name = \"vicczyq\";\n\tint i = 10;\n};\n\nostream & operator<<(ostream &out, MyInt &p)\n{\n\tout << p.name << p.i;\n\treturn out;\n}\nvoid main()\n{\n\tMyInt a;\n\tcout << a << endl;\n\t++(++a);\n\tcout << a << endl;\n}\n```\n\n#### 2.4.7.4 赋值运算符重载\n\n```cpp\nclass Person\n{\npublic:\n\tint *m_age;\n\tPerson(int x)\n\t{\n\t\tm_age = new int(x);\n\t}\n\t\n\tPerson & operator=(Person & p)\n\t{\n\t\tif(m_age!=NULL)\n\t\t{\n\t\t\tdelete m_age;\n\t\t\tm_age = NULL;\n\t\t}\n\t\tm_age = new int(p.m_age);//深拷贝\n\t\treturn *this;\n\t}\n}\n```\n\n#### 2.4.7.5 关系运算符重载\n\n```cpp\nclass Person\n{\npublic:\n\tstring name;\n\tint id;\n\tbool operator==(Person &p)\n\t{\n\t\tif(p.name==name && p.id==id)\n\t\t{\n\t\t\treturn true;\n\t\t}\n\t\telse return false;\n\t}\n}\n```\n\n### 2.4.8 继承\n\n下级别成员拥有上一级的共性，又有自己的特点。**减少重复代码**。\n\n![image-20240303191037932](C/image-20240303191037932.png)\n\n#### 2.4.8.1 继承的基本语法\n\n基本语法：`class 子类 : 继承方式 父类`\n\n子类 也称为 **派生类**\n\n父类 也称为 **基类**\n\n```cpp\n#include <iostream>\n#include <string>\nusing namespace std;\n\nclass BasePage {\npublic:\n\tvoid Print()\n\t{\n\t\tcout << \"父类的打印函数\" << endl;\n\t}\n};\nclass Page1 : public BasePage //此处实现继承操作，注意是一个冒号\n{\n\n};\nvoid main()\n{\n\tPage1 p;\n\tp.Print();//子类对象访问父类的方法\n}\n```\n\n#### 2.4.8.2继承方式\n\n```cpp\nclass A\n{\npublic:\n\tint a;\nprotected:\n\tint b;\nprivate:\n\tint c;\n};\n```\n\n- 公共继承\n\n  ```cpp\n  class B : public A\n  {\n  public:\n  \tint a;\n  protected:\n  \tint b;\n  };\n  ```\n\n- 保护继承\n\n  ```cpp\n  class C : protected A\n  {\n  protected:\n  \tint a;\n  \tint b;\n  }\n  ```\n\n- 私有继承\n\n  ```cpp\n  class D : private A\n  {\n  private:\n  \tint a;\n  \tint b;\n  }\n  ```\n\n所谓的继承方式就是**继承成为对应权限**，除了公共继承需要考虑protected的处理。\n\n注意：父类的private不管怎么样都是不能继承的\n\n#### 2.4.8.3 继承关系\n\n```cpp\nclass BasePage {\npublic:\n\tint a;\nprotected:\n\tint b;\nprivate:\n\tint c;\n};\nclass Page1 : public BasePage\n{\n\t\n};\nvoid main()\n{\n\tPage1 p;\n\tcout << sizeof(p) << endl;\n    //此处会输出12，因此继承了a,b,c但是c被隐藏\n}\n```\n\n父类中所有的非静态成员属性都会被子类继承下去，但是私有的属性被编译器隐藏了。\n\n#### 2.4.8.4 构造和析构顺序\n\n子类继承父类，\n\n```cpp\n#include <iostream>\n#include <string>\nusing namespace std;\nclass BasePage {\npublic:\n\tBasePage()\n\t{\n\t\tcout << \"父类构造函数\" << endl;\n\t}\n\t~BasePage()\n\t{\n\t\tcout << \"父类析构函数\" << endl;\n\t}\n};\nclass Page1 : public BasePage\n{\npublic:\n\tPage1()\n\t{\n\t\tcout << \"子类构造函数\" << endl;\n\t}\n\t~Page1()\n\t{\n\t\tcout << \"子类析构函数\" << endl;\n\t}\n};\nvoid main()\n{\n\tPage1 p;\n}\n```\n\n先调用父类的构造函数，再调用子类的构造函数\n\n先调用子类的析构函数，再调用父类的析构函数\n\n![image-20240303195651224](C/image-20240303195651224.png)\n\n#### 2.4.8.5 同名成员处理方式\n\n- 访问子类中的同名成员：直接访问即可\n- 访问父类中的同名成员：需要添加作用域\n\n```cpp\n#include <iostream>\n#include <string>\nusing namespace std;\n\nclass BasePage {\npublic:\n\tstring str=\"父类\";\n\tvoid func()\n\t{\n\t\tcout << \"同名成员函数：父类\" << endl;\n\t}\n};\nclass Page1 : public BasePage\n{\npublic:\n\tstring str=\"子类\";\n\tvoid func()\n\t{\n\t\tcout << \"同名成员函数：子类\" << endl;\n\t}\n};\nvoid main()\n{\n\tPage1 p;\n\tcout << p.str << endl;\n\tcout << p.BasePage::str << endl;//父类作用域\n\tp.func();\n\tp.BasePage::func();//父类作用域访问同名成员函数\n}\n```\n\n#### 2.4.8.6 多继承语法\n\n语法：``class 子类 : 继承方式 父类1, 继承方式 父类2 ...`\n\n多继承可能会引发父类中同名成员的出现，需要加作用域进行区分，\n\n**C++实际开发中不建议用多继承**\n\n#### 2.4.8.7 菱形继承/虚继承\n\n两个类继承于同一个父类，又有某个类同时集成于这两个类\n\n![img](C/c32a9478f218278aacca70b56bcb83bf.jpeg)\n\n由上图可知，羊驼继承了动物的数据两次，我们真实情况只需要一个数据就行\n\n```cpp\nclass Animal{\npublic:\n\tint m_Age;\n};\nclass Sheep : public Animal{};\nclass Tuo : public Animal{};\nclass SheepTuo : public Sheep, public Tuo{};\nvoid main()\n{\n\tSheepTuo st;\n\tst.Sheep::m_Age = 18;\n\tst.Tuo::m_Age = 28;//会出现两个情况\n}\n```\n\n虚继承即可解决\n\n```cpp\nclass Animal{\npublic:\n\tint m_Age;\n};\nclass Sheep :virtual public Animal{};\nclass Tuo :virtual public Animal{};//利用virtual关键字实现虚继承\nclass SheepTuo : public Sheep, public Tuo{};\nvoid main()\n{\n\tSheepTuo st;\n\tst.Sheep::m_Age = 18;//此时不管访问Sheep还是Tuo都是18\n    st.Tuo::m_Age = 28;//此时不管访问Sheep还是Tuo都是28\n}\n```\n\n### 2.4.9 多态\n\n<u>对于同一个函数，传入不同的参数会反应出不同的状态，即执行不同的内容。</u>\n\n- 静态多态：函数重载 和 运算符重载\n- 动态多态： 子类和虚函数实现运行时的多态\n\n静态多态和动态多态的区别：\n\n- 静态多态：编译阶段确定函数地址（早绑定）\n- 动态多态：运行阶段确定函数地址（晚绑定）\n\n```cpp\nclass Animal{\npublic:\n\tvoid speak()\n\t{\n\t\tcout<<\"动物正在说话\"<<endl;\n\t}\n};\nclass Cat : public Animal{\npublic:\n\tvoid speak()\n\t{\n\t\tcout<<\"小猫在说话\"<<endl;\n\t}\n};\n//地址进行了早绑定，在编译阶段确定了函数地址，\n//输出内容为：“动物在说话”\nvoid doSpeak(Animal & animal)\n{\n\tanimal.speak();\n}\nvoid main()\n{\n\tCat cat;\n\tdoSpeak(cat);\n}\n```\n\n```cpp\nclass Animal{\npublic:\n\tvirtual void speak()//通过virtual，虚函数实现动态多态\n\t{\n\t\tcout<<\"动物正在说话\"<<endl;\n\t}\n};\nclass Cat : public Animal{\npublic:\n\tvoid speak()\n\t{\n\t\tcout<<\"小猫在说话\"<<endl;\n\t}\n};\n//此时输出“小猫在说话”\nvoid doSpeak(Animal & animal)\n{\n\tanimal.speak();\n}\nvoid main()\n{\n\tCat cat;\n\tdoSpeak(cat);\n}\n```\n\n**动态多态满足条件：**\n\n1. 有继承关系\n2. 子类要重写父类的虚函数\n\n重写：函数名、参数、返回值类型都必须相同。\n\n重载：函数名相同，参数、返回值类型可能不同。\n\n#### 2.4.9.1多态的原理剖析\n\n```cpp\nclass Animal\n{\n\tvoid doSpeak()\n\t{\n\t\tcout << \"动物正在说话\" << endl;\n\t}\n};\n此时sizeof(Animal)为1\nclass Animal\n{\n\tvoid virtual doSpeak()\n\t{\n\t\tcout << \"动物正在说话\" << endl;\n\t}\n};\n此时的sizeof(Animal)为4\n```\n\n4个字节的原因是指针占用。\n\n`virtual`关键字会形成一个`vfptr`指针（**虚函数表指针**）virtual function pointer\n\n![image-20240304194459436](C/image-20240304194459436.png)\n\n当子类继承时，会重写doSpeak函数，vfptr的指针指向的地址就会发生改变。\n\n![image-20240304195120122](C/image-20240304195120122.png)\n\n在每次调用时候，会直接调用当前类的函数，所以可以实现多态。\n\n\n\n#### 2.4.9.2 纯虚函数和抽象类\n\n通常发生多态后，父类中的函数就没什么意义，主要是用于调用子类重写内容，\n\n因此可以将虚函数改为**纯虚函数**\n\n语法：`virtual 返回值类型 函数名 (参数列表) = 0; `\n\n当类中有了纯虚函数，这个类就称为**抽象类**。\n\n\n\n**抽象类特点：**无法实例化对象，子类必须重写抽象类中的纯虚函数，否则也属于抽象类\n\n```cpp\nclass Animal{//抽象类\npublic:\n\tvirtual void doSpeak() = 0;//纯虚函数\n};\n\nclass Cat : public Animal{\npublic:\n\tvoid doSpeak()\n\t{\n\t\tcout<<\"小猫在说话\"<<endl;\n\t}\n};\n```\n\n#### 2.4.9.3 虚析构和纯虚析构\n\n多态使用时，如果子类中有开辟到堆区的数据，父类指针在释放时无法调用到子类的析构代码\n\n父类指针在进行析构的时候，不会调用子类中的析构函数，导致子类的堆区数据，出现内存泄漏。\n\n采用 **虚析构** 和 **纯虚析构** 即可解决。\n\n```cpp\n//虚析构\nvirtual ~类名(){\n    //虚析构实现\n}\n\n//纯虚析构，属于抽象类\nvirtual ~类名() = 0; \n/*全局作用域*/\nAnimal::~Animal()\n{\n    //纯虚析构实现\n}\n```\n\n## 2.5文件操作\n\nC++对文件操作需要包含头文件**`<fstream>`**\n\n文本文件以**ASCII码**形式存储在计算机中，二进制文件以**二进制**形式存储\n\n三大类：\n\n- ofstream：写操作\n- ifstream：读操作\n- fstream：读写操作\n\n### 2.5.1 文本文件\n\n**打开方式：**\n\n![image-20240304204659205](C/image-20240304204659205.png)\n\n#### 2.5.1.1 写文件\n\n```cpp\n#include <fstream>\nint main()\n{\n    ofstream ofs;\n    ofs.open(\"文件路径\", ios::out);\n    ofs << \"写入的数据\";\n    ofs.close();\n    return 0;\n}\n```\n\n文件打开方式可以配合使用，如`ios::out | ios::binary`就是以二进制形式写出\n\n#### 2.5.1.2 读文件\n\n```cpp\n#include <fstream>\n#include <iostream>\nint main()\n{\n    ifsteam ifs;\n    ifs.open(\"文件路径\", ios::in);\n    \n    if(!ifs.isopen())\n    {\n        cout<<\"文件打开失败\"<<endl;\n    \treturn 0;\n    }\n    \n    //读数据\n    \n    ifs.close();\n    return 0;\n}\n```\n\n**读数据：**\n\n方法一：\n\n```cpp\nchar buf[1024] = {0};//可以用string\nwhile( ifs >> buf )\n{\n    cout << buf << endl;\n}\n```\n\n方法二：\n\n```cpp\nchar buf[1024] = {0};//可以用string\nwhile( ifs.getline(buf),1024 )//或者用sizeof\n{\n    cout << buf << endl;\n}\n```\n\n方法三：\n\n```cpp\nstring buf;\nwhile( getline(ifs, buf))\n{\n    cout << buf;\n}\n```\n\n方法四：\n\n```cpp\nchar c;\nwhile( (c=ifs.get()) != EOF )\n{\n    cout << c;\n}\n```\n\n**总结**\n\n```cpp\n#include <fstream>\n#include <iostream>\nusing namespace std;\nint main()\n{\n\tofstream ofs;\n\tofs.open(\"test.txt\", ios::out);\n\tofs << \"张三\" << endl;\n\tofs << \"18岁\" << endl;\n\tofs << \"男\" << endl;\n\tofs.close();\n\n\tifstream ifs;\n\tifs.open(\"test.txt\", ios::in);\n\tif (!ifs.is_open())return 0;\n\tstring str;\n\twhile ( ifs>>str )\n\t{\n\t\tcout << str<<endl;\n\t}\n    ifs.close();\n\treturn 0;\n}\n```\n\n### 2.5.2 二进制文件\n\n打开方式需要添加`ios::binary`\n\n#### 2.5.2.1 写文件\n\n```cpp\nPerson p = {\"张三\",18};//列表初始化，等效于p(\"张三\",18)\nofstream ofs;\nofs.open(\"文件地址\", ios::binary | ios::out);\nofs.write((const char*)p, sizeof(Person));\nofs.close();\n```\n\n#### 2.5.2.1 读文件\n\n```cpp\nPerson p;\nifstream ifs;\nifs.open(\"文件地址\", ios::binary | ios::in);\n\nif(!ifs.is_open())return 0;\n\nifs.read((const char*)p, sizeof(Person));\nifs.close();\n```\n\n## 2.6 模板\n\n### 2.6.1基本语法\n\n```cpp\nvoid swapInt(int &a, int &b)\n{\n    int temp = a;\n    a = b;\n    b = temp;\n}\nvoid swapDouble(double &a, double &b)\n{\n    double temp = a;\n    a = b;\n    b = temp;\n}\n```\n\n数据类型不同，但是代码逻辑是相同的，采用模板可以改写为\n\n```cpp\ntemplate <typename T>//声明一个模板，告诉编译器后面的T是一个通用的数据类型\n//typename可以用class代替\nvoid Myswap(T &a, T &b)\n{\n    T temp = a;\n    a = b;\n    b = temp;\n}\n\nvoid main()\n{\n    int a=10,b=20;\n    Myswap(a,b);//自动类型推导\n    Myswap<int>(a,b);//手动指定数据类型\n}\n```\n\n**模板必须要确定出T的数据类型才能正常使用**\n\n案例：选择排序\n\n```cpp\n#include <iostream>\nusing namespace std;\ntemplate <class T>\nvoid Swap_element(T &a,T &b)\n{\n\tT temp;\n\ttemp = a;\n\ta = b;\n\tb = temp;\n}\ntemplate <class T>\nvoid SelectSort(T &arr)\n{\n\tint len = sizeof(arr) / sizeof(arr[0]);\n\tfor (int i = 0; i < len; i++)\n\t{\n\t\tint maxFlag = i;\n\t\tfor (int j = i + 1; j < len; j++)\n\t\t{\n\t\t\tif (arr[j] > arr[maxFlag])\n\t\t\t{\n\t\t\t\tmaxFlag = j;\n\t\t\t}\n\t\t}\n\t\tif (maxFlag != i)\n\t\t{\n\t\t\tSwap_element(arr[maxFlag], arr[i]);\n\t\t}\n\t}\n\tfor (int i = 0; i < len; i++)\n\t{\n\t\tcout << arr[i] << \" \";\n\t}\n}\n\nint main()\n{\n\tint a[] = { 2,3,4,1,0,2,9,10 };\n\tSelectSort(a);\n\tchar str[] = \"gfbseqa\";\n\tSelectSort(str);\n\treturn 0;\n}\n```\n\n### 2.6.2 普通函数与函数模板的区别\n\n普通函数可以发生隐式类型转换\n\n函数模板(自动类型推导)，不可以发生隐式类型转换\n\n函数模板(手动指定类型)，可以发生隐式类型转换\n\n```cpp\nint Add_pt(int &a,int &b){\n    return a+b;\n}\n\ntemplate <typename T>\nT Add_mb(T &a, T &b){\n    return a+b;\n}\n\nvoid main(){\n    int a=1,b=2;\n    char c=3;\n    Add_pt(a,c);//普通函数隐式类型转换，将c转为了int类型\n    Add_mb(a,c);//此处会报错，自动推导\n    add_mb<int>(a,c);//隐式类型转换\n}\n```\n\n### 2.6.3 普通函数和函数模板调用规则\n\n- 如果普通函数和函数模板都可以实现，优先调用**普通函数**\n- 可以通过**空模板参数列表**来强制调用函数模板\n- 函数模板页也可以发生重载\n- 如果函数模板产生更好的匹配，优先调用函数模板\n\n```cpp\nvoid Print(int a,int b){\n\tcout<<\"调用普通函数\"<<endl;\n}\n\ntemplate<class T>\nvoid Print(T a,T b){\n    cout<<\"调用模板函数\"<<endl;\n}\n\ntemplate<typename T>\nvoid Print(T a,T b,T c){\n    cout<<\"调用重载的函数模板\"<<endl;\n}\nvoid main()\n{\n    Print(1,1);//优先调用普通函数\n    Print<>(1,1);//强制调用函数模板\n    Print(1,1,1);//调用重载函数模板\n    Print('a','b');\n    //会优先调用函数模板，产生了更好的匹配，不需要进行类型转换(char->int)\n}\n```\n\n### 2.6.4 模板局限性\n\n模板并不是万能的，如果传入 a和b是一个数组，模板就无法实现\n\n```cpp\ntemplate <class T>\nvoid f(T a, T b){\n\ta = b;\n}\n```\n\n如果传入的是像Person这样的自定义数据类型，也无法正常运行\n\n```cpp\ntemplate <class T>\nbool f(T a,T b){\n\tif(a > b){.....}\n}\n```\n\n**解决方法：**1.运算符重载、2.具体化Person\n\n```cpp\ntemplate<> bool f(Person &p1, Person &p2){\n\tif(p1.m_Name==p2.m_Name)return true;\n\telse return false;\n}\n```\n\n### 2.6.5 类模板\n\n类模板中的成员函数只有在**调用时候**才会进行创建，普通类中的成员函数在一开始就创建在代码区\n\n(可以记成，不同的一组typename就是不同的class，所以在外部访问的时候需要用<>)\n\n#### 2.6.5.1 基本语法\n\n```cpp\n#include <iostream>\nusing namespace std;\n\ntemplate <typename NameType,typename AgeType>\nclass Person {\npublic:\n\tNameType m_Name;\n\tAgeType m_Age;\n\tPerson(NameType name, AgeType age){\n\t\tm_Name = name;\n\t\tm_Age = age;\n\t}\n};\nint main()\n{\t\n\tPerson<string,int> p(\"vicczyq\",18);//必须手动指定类型\n\treturn 0;\n}\n```\n\n#### 2.6.5.2 类模板和函数模板的区别\n\n1. 类模板没有自动类型推导的使用方式\n2. 类模板在木板参数列表中可以有**默认参数**\n\n```cpp\ntemplate <typename NameType, typename AgeType =int>\nclass Person{\npublic:\n    NameType m_Name;\n    AgeType\t m_Age;\n};\n```\n\n#### 2.6.5.3 类模板对象作函数参数\n\n```CPP\ntemplate <typename NameType, typename AgeType>\nclass Person{\npublic:\n    NameType m_Name;\n    AgeType\t m_Age;\n};\n```\n\n- 指定传入类型\t--直接指定对象的数据类型\n\n```cpp\nvoid printPerson(Person<string,int> &p){\n    \n}\nvoid main(){\n    Person<string,int> p(\"vicczyq\",18);\n    printPerson(p);\n}\n```\n\n- 参数模板化        --将对象中的参数变为模板进行传递\n\n```cpp\ntemplate<typename T1, typename T2>\nvoid printPerson(Person<T1,T2> &p){\n    \n}\nvoid main(){\n    Person<string,int> p(\"vicczyq\",18);\n    printPerson(p);\n}\n```\n\n- 整个类模板化    --将这个对象类型模板化进行传递\n\n```cpp\ntemplate<typename T>\nvoid printPerson(T &p){\n    \n}\nvoid main()\n{\n    Person<string,int> p(\"vicczyq\",18);\n    printPerson(p);//利用模板函数自动类型推导\n}\n```\n\n#### 2.6.5.4 类模板继承\n\n当父类是一个类模板时，子类继承需要指出父类中的数据类型\n\n如果想灵活使用数据类型，子类也必须为类模板\n\n```cpp\ntemplate <typename NameType,typename AgeType>\nclass Person{\npublic:\n    NameType m_Name;\n    AgeType m_Age;\n}\n\nclass Son : public Person<string,int>{\n    \n}\n\ntemplate <typename T1, typename T2, typename T3>\nclass Son : public Person<T1,T2>\n{\npublic:\n    T3 sex;\n}\n```\n\n#### 2.6.5.5 类模板成员函数类外实现\n\n```cpp\ntemplate <typename NameType>\nclass Person{\npublic:\n\tNameType m_Name;\n\tvoid getName();\n    Person();\n};\n\ntemplate <typename T>\nT Person<T>::getName()\n{\n\treturn m_Name;\n}\n\ntemplate <typename T>\nPerson<T>::Person(){\n\n}\n```\n\n#### 2.6.5.6 类模板份文件编写\n\n由于类模板中成员函数创建时机是在调用阶段，导致份文件编写时候无法链接。\n\n**解决方法：**\n\n- 解决方法1：直接包含cpp源文件\n\nperson.h\n\n```cpp\ntemplate <typename NameType>\nclass Person{\npublic:\n\tNameType m_Name;\n\tvoid getName();\n    Person();\n};\n```\n\nperson.cpp\n\n```cpp\n#include \"person.h\"\n\ntemplate <typename T>\nT Person<T>::getName()\n{\n\treturn m_Name;\n}\n\ntemplate <typename T>\nPerson<T>::Person(){\n\n}\n```\n\nmain函数\n\n```cpp\n#include \"person.cpp\"\nvoid main(){\n\tPerson<string> p;\n}\n```\n\n- 解决方法2：将声明和实现写到同一个文件中，并更改后缀名为`.hpp`（.hpp只是约定名称，不是强制限制）相当于直接写在了.h文件中\n\nmain函数\n\n```cpp\n#include \"person.hpp\"\nvoid main(){\n\tPerson<string> p;\n}\n```\n\nperson.hpp\n\n```cpp\ntemplate <typename NameType>\nclass Person{\npublic:\n\tNameType m_Name;\n\tvoid getName();\n    Person();\n};\ntemplate <typename T>\nT Person<T>::getName()\n{\n\treturn m_Name;\n}\n\ntemplate <typename T>\nPerson<T>::Person(){\n\n}\n```\n\n#### 2.6.5.7 类模板与友元\n\n```cpp\ntemplate <typename NameType, typename AgeType>\nclass Person{\n    //其实是全局函数，友元函数直接在这里实现\n    friend void PrintInfo(Person<NameType,AgeType> &p)\n    {\n        cout << p.m_Name << p.m_Age;\n    }\n\tprivate:\n    \tNameType m_Name;\n    \tAgeType\t m_Age;\n};\n```\n\n","tags":["C++"]},{"title":"计算机组成原理-(2)","url":"/2024/02/06/计算机组成原理二/","content":"\n# 一、存储系统\n\n## 1.1数据存储和排列\n\n### 1.1.1大小端模式\n\n若有4字节的 int：01 23 45 67 H\n\n多字节数据在内存里一定是占**连续的**几个字节，01为最高有效字节(MSB)，67为最低有效字节(LSB)\n\n**大端方式：**便于人类阅读\n\n![image-20240206163512612](计算机组成原理二/image-20240206163512612.png)\n\n**小端方式：**便于机器处理\n\n![image-20240206163632872](计算机组成原理二/image-20240206163632872.png)\n\n### 1.1.2边界对齐\n\n假设存储字长为32位，则1个字=32bit，半字=16bit。每次访存只能读/写1个字\n\n**边界对齐的方式：**\n\n![image-20240206170756798](计算机组成原理二/image-20240206170756798.png)\n\n**边界不对齐方式：**\n\n![image-20240206170910990](计算机组成原理二/image-20240206170910990.png)\n\n由于边界不对齐，若要读取半字1，则先要读取第一个字(第一行)，再读取第二个字(第二行)，最后将半字1-1和半字1-2拼接。所以访问**一个字/半字**可能需要**两次访存**\n\n采用边界对齐的方式，访问**一个字/半字**都只需要一次访存即可。牺牲掉部分空间，但是能加快访存效率。\n\n## 1.2浮点数的表示和运算\n\n### 1.2.1前言\n\n**定点数的局限性：**定点数可以表示的数字范围有限，但我们不能无限制的增加数据长度\n\n### 1.2.2浮点数的表示\n\n$$\n可以类似于科学计数法，+3.026×10^{+21}\n\\\\+/-表示小数点后移/前移多少位\n\\\\浮点数的真值:N=r^E×M\n\\\\r为阶码的底，通常为2（二进制）\n\\\\E反应浮点数表示范围以及小数点的真是位置\n\\\\M数值部分的位数反应浮点数的精度\n\\\\阶码:常用补码或移码表示的定点整数\n\\\\尾数:常用原码或补码表示的定点小数\n$$\n\n![image-20240206171958125](计算机组成原理二/image-20240206171958125.png)\n\n\n\n### 1.2.3浮点数尾数规格化\n\n![image-20240206174421304](计算机组成原理二/image-20240206174421304.png)\n\n## 1.3存储器\n\n### 1.3.1存储器的层次结构\n\n![image-20240208143405738](计算机组成原理二/image-20240208143405738.png)\n\n**辅存：**磁盘、可移动介质\n\n辅存中的数据要调入到主存中才能被CPU访问\n\n![image-20240208145434194](计算机组成原理二/image-20240208145434194.png)\n\n**缓存：**高速缓冲存储器Cache\n\n**主存-辅存：**实现了虚拟存储系统，解决了主存容量不足的问题\n\n**Cache-主存：**解决了主存与CPU速度不匹配的问题\n\n### 1.3.2存储器的分类\n\n#### 1.3.2.1按计算机中的层次分类\n\n(1)主存储器。简称**主存**，又称为**内存**。用来存放计算机**运行期间**所需的程序和数据，CPU可以直接随机的对其进行访问，也可以利用Cache间接访问。\n\n(2)辅助存储器。简称**辅存**，又称**外存**。用来存放暂时不用的程序和数据，以及一些永久性保存的信息。辅存的内容要调入主存后才能被CPU访问。\n\n(3)高数缓冲存储器。简称**Cache**，用来存放CPU经常使用的指令和数据，CPU可以高速访问他们。\n\n#### 1.3.2.2按存储介质分类\n\n磁表面存储器(磁盘、磁带)、磁芯存储器、半导体存储器(MOS型存储器、双极型存储器)和光存储器(光盘)\n\n#### 1.3.2.3按信息的可保存性分类\n\n易失性存储器：RAM\n\n非易失性存储器：ROM\n\n### 1.3.3存储器芯片的基本原理\n\n ![image-20240209152642087](计算机组成原理二/image-20240209152642087.png)\n$$\n控制电路：等待MAR稳定后才进行译码操作，等待MDR稳定后才进行读写操作\n\\\\片选线 (\\overline{CS}或\\overline{CE})：一个内存条上可能包含多块存储芯片,用于选择芯片(Chip Select或Chip Enable)\n\\\\读控制线(\\overline{WE})：允许写\n\\\\写控制线(\\overline{OE})：允许读\n$$\n\n### 1.3.4DRAM和SRAM\n\nDynamic Random Access Memory，即**动态RAM**\n\nStatic Random Access Memory，即**静态RAM**\n\nDRAM用于主存，SRAM用于Cache\n\n\n\nDRAM依靠<font color=red>栅极电容</font>实现，SRAM依靠<font color=green>双稳态触发器</font>实现\n\n![image-20240225134448490](计算机组成原理二/image-20240225134448490.png)\n\n```\n栅极电容放电信息会被破坏，是破坏性读出。读出后需要“重写”操作，也成为“再生”。\n双稳态触发器无需重写，是非破坏性读出。\n```\n\n由于SRAM不需要重新所以读出速度更快，但是成本更高。并且由于存储元制造更复杂，集成度就更低。\n\n**注意：**DRAM和SRAM都是易失性的（断电后信息会消失）\n\n#### 1.3.4.1 DRAM的刷新\n\n由于DRAM电容内的电荷只能维持2ms。即便不断电，2ms后信息也会消失，所以要不断的进行刷新(充电)\n\n### 1.3.5 ROM\n\nROM芯片--非易失，断电后数据仍然可以保存\n\n```\nMROM:掩模式只读存储器(厂家按客户需求在生产过程中写入，之后不可重写)\nPROM:可编程只读存储器(用户可以用专门的写入器写入信息，之后不可重写)\nEPROM:可擦除可编程只读存储器(允许用户写入，之后擦除，可以多次重写)\nUVEPROM:紫外线照射可擦除所有信息\nEEPROM:电擦除，可擦除特定的字\n\nFlash Memory:闪速存储器(U盘，SD卡)\n注意：闪存需要先擦除再写入，因此\"写\"速度比\"读\"速度更慢\nSSD：固态硬盘(由控制单元和Flash芯片构成)\n```\n\n计算机启动时，主存RAM没有任何指令，所以需要主板上的BIOS芯片(ROM)存储了\"自举装入程序\"，负责引导装入操作系统\n\n### 1.3.6 内存扩展\n\n#### 1.3.6.1 位扩展-增加主存的存储字长\n\n![image-20240229103326507](计算机组成原理二/image-20240229103326507.png)\n\n以此类推，拓展为8位，连接方式如下：\n\n![image-20240229103815314](计算机组成原理二/image-20240229103815314.png)\n\n8片8Kx1位的存储芯片 -> 8Kx8位的存储器，容量为8KB(64Kbit)\n\n#### 1.3.6.2 字扩展-增加主存的存储字数\n\n利用片选使能线进行，(1-2译码器)，利用A13的两种状态进行选择\n\n![image-20240229105813018](计算机组成原理二/image-20240229105813018.png)\n\n利用2-4译码器进行扩展：\n\n![image-20240229110201046](计算机组成原理二/image-20240229110201046.png)\n\n#### 1.3.6.3 字位同时扩展\n\n![image-20240229110325854](计算机组成原理二/image-20240229110325854.png)\n\n## 1.4 Cache\n\n### 1.4.1 Cache的基本概念和原理\n\n#### 1.4.1.0 概念理解\n\nCPU需要从主存一条一条地读取指令，CPU处理速度很快，内存(主存)的读写速度很慢，导致速度不匹配，执行效率就会很低，因此引入Cache\n\n![image-20240229111235187](计算机组成原理二/image-20240229111235187.png)Cache的读写速度很快，可以缓和速度矛盾\n\n**空间局限性：**在最近的未来要用到的信息(指令和数据)，很可能与现在正在使用的信息在存储空间上是相邻的\n\n**时间局限性：**在最近的未来要用到的信息，很可能是现在正在使用的信息\n\n根据两个原理可以发现，可以把CPU目前访问地址\"周围\"的部分数据放到Cache中。\n\n#### 1.4.1.1性能分析\n\n$$\n设t_c为访问一次Cache所需时间，t_m为访问一次主存锁需要的时间\\\\\n命中率H：CPU访问的信息已在Cache中的概率\\\\\n缺失率M=1-H\\\\\n系统的平均访问时间t为:\\\\\nt=Ht_c+(1-H)(t_c+t_m)\n$$\n\n上述例子CPU会优先访问Cache，若Cache missed(未命中)再访问主存\n\n还存在一种CPU<font color=red>同时访问</font>Cache和主存，若Cache命中则立即停止访问主存的方式\n$$\nt=Ht_c+(1-H)t_m\\\\\n$$\n\n#### 1.4.1.2数据交换\n\n将主存的存储空间进行\"分块\"，如：每1KB为一块，主存和Cache之间以\"<font color=green>块</font>\"为单位进行数据交换\n\n![image-20240229113716226](计算机组成原理二/image-20240229113716226.png)\n\n注意：每次被访问的主存块，一定会被立即调入Cache\n\n#### 1.4.1.3Cache和主存的映射方式\n\n**(1)全相联映射(随意放)**\n\n标记：记录主存块的索引\n\n![image-20240229122754368](计算机组成原理二/image-20240229122754368.png)\n$$\n假设某个计算机内存地址空间大小为256MB，按字节编址，其数据Cache有8个Cache行(即Cache块)，行长为64B\\\\\n256MB=2^{28}B\\\\\n默认一个存储单元为1字节(1B)因此有2^{28}个地址\\\\\n因此，块内地址为6位，主存块号有22位\n$$\n访存过程：\n\n①主存地址的前22位对比Cache中所有块的标记\n\n②若标记匹配且有效位为1，则Cache命中，访问块内地址单元\n\n③若未命中则正常进行访问主存\n\n**(2)直接映射**\n\n每个主存块只能放到一个特定的位置：\n$$\nCache块号=主存块号\\%Cache总块数\n$$\n![image-20240229123419792](计算机组成原理二/image-20240229123419792.png)\n\n**(3)组相联映射**\n\nCache块氛围若干组，每个主存块可以存放到特定分组的任意一个位置\n$$\n组号=主存块号\\%分组数\n$$\n![image-20240229123614460](计算机组成原理二/image-20240229123614460.png)\n\n\n\n### 1.4.2 替换算法\n\n#### 1.4.2.1随机算法(RAND)\n\n若Cache已满，则随机选择一块进行替换\n\n![image-20240229125852091](计算机组成原理二/image-20240229125852091.png)\n\n随机算法实现简单，但是没考虑局部性，命中率低，实际效果很不稳定\n\n#### 1.4.2.2先进先出算法(FIFO)\n\n若Cache已满，则替换最先被调入的Cache块\n\n![image-20240229130033994](计算机组成原理二/image-20240229130033994.png)\n\n实现简单，但依然没有考虑局部性，最先被调入Cache的块也有可能是被频繁访问的\n\n#### 1.4.2.3近期最少使用算法(LRU,Least Recently Used)\n\n为每一个Cache块设置一个\"计数器\"，用于记录每个块已经多久没有被访问，当Cache满后替换\"计数器\"最大的\n\n![image-20240229130404308](计算机组成原理二/image-20240229130404308.png)\n\n- 命中时，所命中的块的计数器要<font color=red>清零</font>，其余不变\n- 未命中且还有空闲块时候，新装入的块的计数器<font color=red>置零</font>，其余非空闲块全加1\n- 未命中且无空闲块时，计数值最大的块被淘汰，新装入的块的计数器置零，其余加1\n\n#### 1.4.2.4最不经常使用算法(LFU,Least Frequently Used)\n\n为每一个Cache块设置一个\"计数器\"，用于记录每个Cache块被访问了几次，当Cache满后替换\"计数器\"最小的\n\nPS：若有多个最小的块，可按行号递增或FIFO策略进行替换\n\n![image-20240229131139169](计算机组成原理二/image-20240229131139169.png)\n\n### 1.4.3 Cache写策略(数据一致性)\n\n#### 1.4.3.1写命中\n\n(**1)写回法**\n\n![image-20240229132354989](计算机组成原理二/image-20240229132354989.png)\n\n**(2)全写法**\n\n![image-20240229132301833](计算机组成原理二/image-20240229132301833-1709184184141-1.png)\n\n使用写缓冲，CPU的写速度很快，若写操作很频繁，可能回因为写缓冲饱和而发生阻塞，此时CPU就要等待。\n\n#### 1.4.3.2写不命中\n\n**（1）写分配法(write-allocate)**\n\n当CPU对Cache写不命中时，把主存的块调入Cache，再在Cache中修改，最后采用<font color=red>写回法</font>\n\n**（2）非写分配法**\n\n当CPU对Cache写不命中时，只写入主存，不调入Cache，搭配<font color=red>全写法</font>使用\n\n## 1.5页式存储器\n\n一个程序(进程)在逻辑上被分为若干个大小相等的\"页面\"，\"页面\"大小与\"块\"的大小相等，每个页面可以离散的放在不同的主存块中。\n\n背景解析：如果不这样做，就需要在主存中寻找到连续的空间，导致主存利用率不高。\n\n### 1.5.1地址变换方式\n\n![image-20240229134940178](计算机组成原理二/image-20240229134940178.png)\n\n### 1.5.2引入快表(TLB)的变换\n\n![image-20240229135553300](计算机组成原理二/image-20240229135553300.png)\n\n","tags":["计算机基础"]},{"title":"hexo博客文章加密","url":"/2024/01/29/hexo博客文章加密/","content":"\n静态博客加密插件：[hexo-blog-encrypt](https://www.npmjs.com/package/hexo-blog-encrypt)，搭配此插件你可以写一些私密博客，通过密码验证的方式让人不能随意浏览。\n\n### 安装：\n\n```shell\nnpm install hexo-blog-encrtpt\n```\n\n### 用法：\n\n文章头添加关键字<font color=red>password</font>即可设置文章访问密码\n\n```c\n---\ntitle: Hello World\ndate: 2016-03-30 21:18:02\npassword: hello\n---\n```\n\n高级用法：\n\n```c\n---\ntitle: Hello World\ndate: 2016-03-30 21:12:21\npassword: hello\nabstract: Here's something encrypted, password is required to continue reading.\nmessage: Hey, password is required here.\nwrong_pass_message: Oh, this is an invalid password. Check and try again, please.\n---\n```\n\n- `abstract`：用于设置加密文章显示的摘要。\n- `message`：输入密码提示。\n- `wrong_pass_message`: 输入错误提示。\n","tags":["hexo"]},{"title":"HPCGame记录","url":"/2024/01/23/HPCGame记录/","content":"\n前言：参加完ASC，回家两天，看到HPCGame开赛心痒痒\n\n## A.欢迎参赛！\n\n这个题就是介绍一下比赛的相关内容，直接提交后就会返回提供的集群账号密码\n\n## B.流量席卷土豆\n\n  [流量席卷土豆.mhtml](流量席卷土豆.mhtml) \n\n这个题挺有意思的，刚开始看到题的时候说实话我人有点慌了(好多字)冷静下来认真读题后发现，就是一个作业提交和软件使用而已。\n\n**解题步骤如下：**\n\n1、srun提交命令提取 SSH 流量：\n\n（赛题中提供的路径有问题，找了一下还有一层子目录pcaps）\n\n```\nsrun -p C064M0256G -N4 --ntasks-per-node=4 bash -c 'tshark -r /lustre/shared_data/potato_kingdom_univ_trad_cluster/pcaps/$SLURM_PROCID.pcap -Y ssh -w $SLURM_PROCID.ssh.pcap'\n```\n\n当前路径就会得到如下文件\n\n![image-20240123134122253](HPCGame记录/image-20240123134122253.png)\n\n2、合并 PCAP 文件：\n\n```\nmergecap -w merged.pcap *.ssh.pcap\n```\n\n![image-20240123134322241](HPCGame记录/image-20240123134322241.png)\n\n3、破解密码：\n\n```\nquantum-cracker merged.pcap\n```\n\n![image-20240123134517990](HPCGame记录/image-20240123134517990.png)\n\n4、获取 Slurm JobID\n\n```\nsacct -u $(whoami) --format JobID | tail\n```\n\n![image-20240123134612339](HPCGame记录/image-20240123134612339.png)\n\n取最后一个的整数，提交即可。\n\n## C.简单的编译\n\n [简单编译.mhtml](简单编译.mhtml) \n\n这道题就是写Makefile和CMakeLists.txt\n\n```\n在本题中，你需要写一个简单的Makefile文件，和一个简单的CMakeLists.txt文件，来编译 Handout 中所提供的三个简单程序。\n\n其中，hello_cuda.cu是一个简单的cuda程序，hello_mpi.cpp是一个简单的mpi程序，hello_omp.cpp是一个简单的 OpenMP 程序。它们都做了同一个简单的事情：从文件中读取一个向量并求和。\n\n你需要上传Makefile和CMakeLists.txt文件。我们会根据以下策略来评测你所写的配置文件的正确性。\n\n对于Makefile文件，我们会在项目根目录下执行make命令。然后在项目根目录下检查程序是否被生成，并运行以检测正确性。\n对于CMakeLists.txt文件，我们会在项目根目录下执行mkdir build; cd build; cmake ..; make。然后我们会在build目录下检查程序是否被正确生成，并运行以检测正确性。\n对于所有类型的文件，hello_cuda.cu所编译出的文件名应为hello_cuda；hello_mpi.cpp所编译出的文件名应为hello_mpi；hello_omp.cpp所编译出的文件名应为hello_omp。\n```\n\n集群GPU节点连不上，用记事板手搓了一下，提交上去Makefile一直报错，\n\n查了一下是tab缩进的问题，后来在终端里面用vim编写，复制，完美解决\n\n（长记性了，用vim来编辑才能正常识别tab）\n\n```makefile\n.PHONY: all clean\n\nall: hello_cuda hello_mpi hello_omp\n\nhello_cuda: hello_cuda.cu\n\tnvcc -o hello_cuda hello_cuda.cu\n\nhello_mpi: hello_mpi.cpp\n\tmpic++ -o hello_mpi hello_mpi.cpp\n\nhello_omp: hello_omp.cpp\n\tg++ -fopenmp -o hello_omp hello_omp.cpp\n\nclean:\n\trm -f hello_cuda hello_mpi hello_omp\n```\n\n```cmake\ncmake_minimum_required(VERSION 3.10)\nproject(test)\n\nenable_language(CUDA)\nadd_executable(hello_cuda hello_cuda.cu)\n\nfind_package(MPI REQUIRED)\nadd_executable(hello_mpi hello_mpi.cpp)\ntarget_link_libraries(hello_mpi MPI::MPI_CXX)\n\nfind_package(OpenMP REQUIRED)\nadd_executable(hello_omp hello_omp.cpp)\ntarget_link_libraries(hello_omp OpenMP::OpenMP_CXX)\n```\n\n## D.小北问答 Classic\n\n [小北问答 Classic.mhtml](小北问答.mhtml) \n\n![image-20240123135107256](HPCGame记录/image-20240123135107256.png)\n\n```\n答案：{\"t1\":\"65.396\",\"t2.1\":\"105.26\",\"t2.2\":\"107.14\",\"t3\":\"iv. GCC\",\"t4.1\":\"ii. 进程\",\"t4.2\":\"i. 线程\",\"t4.3\":\"i. 线程\",\"t5.1\":\"8\",\"t5.2\":\"i. 在 CPU 中设计独立的 AVX512 运算单元，但有可能导致调用 AVX512 指令集时因功耗过大而降频\",\"t5.3\":\"ii. 复用两个 AVX2 运算单元执行 AVX512 运算\",\"t6\":\"iv. OpenGL\",\"t8\":\"iv. PCIe\",\"t9\":\"ii. Slurm\",\"t10\":\"i. 缓存未命中\",\"t7\":\"iii,iv\"}\n```\n\n## E.齐心协力\n\n [齐心协力.mhtml](齐心协力.mhtml) \n\n这道题卡了两天，Ray集群老是出错，后来偶然交了一发过了\n\n后来发现提示里有放置组的概念，学习了一下，改了一下代码，111.6/120分，满足了\n\n```python\nimport ray\nimport numpy as np\nimport os\n\n@ray.remote(num_cpus=1)\nclass Counter:\n    def __init__(self, flag_index):\n        self.weight_matrix = np.load(f\"weights/weight_{flag_index}.npy\")\n    \n    def process(self, input_matrix):\n        return np.maximum(0, np.dot(input_matrix, self.weight_matrix))\n\nif __name__ == \"__main__\":\n    ray.init(address=os.environ['RAY_CLUSTER_ADDR'])\n\n    # 创建放置组，每组有 4 个 CPU\n    placement_groups = [ray.util.placement_group([{\"CPU\": 4}], strategy=\"STRICT_PACK\") for _ in range(4)]\n    ray.get([pg.ready() for pg in placement_groups])  # 等待放置组就绪\n\n    if not os.path.exists(\"outputs\"):\n        os.makedirs(\"outputs\")\n\n    # 在每个放置组中创建 Counter 实例\n    counters = [[Counter.options(placement_group=placement_groups[i], placement_group_bundle_index=0).remote(j) for j in range(4)] for i in range(4)]\n\n    output_results = []\n    for i in range(100):\n        input_matrix = np.load(f\"inputs/input_{i}.npy\")\n        result = input_matrix\n        for counter in counters[i % 4]:\n            result = counter.process.remote(result)\n        output_results.append(result)\n\n    # 收集和保存结果\n    for i, result in enumerate(output_results):\n        output = ray.get(result)\n        np.save(f\"outputs/output_{i}.npy\", output)\n```\n\n\n\n## F.高性能数据校验\n\n [高性能数据校验.mhtml](高性能数据校验.mhtml) \n\n这道题一开始随便开了个MPI竟然就有80多分，而且我题都没认真看，后来随便改改卡到了90（没错，是卡bug到了90）题目重测后直接回归0分，着急！\n\n仔细读了一下题，看到提升里的SHA512函数，就想着用SHA512替换原来的一堆函数（没有认真去看那几个函数），然后就陷入了死循环里，SHA512没法进行并行计算，第i个块的计算依赖于第i-1个。\n\n后来偶然的仔细看了一下代码，发baseline代码中的函数完全解决了上面的问题，可以拆开做，只需要用更多的数组来记录一下就行了![image-20240125213452456](HPCGame记录/image-20240125213452456.png)\n\n修改了一下代码：\n\n```cpp\nvoid checksum(uint8_t *data, size_t len, uint8_t *obuf) {\n  int num_block = (len + BLOCK_SIZE - 1) / BLOCK_SIZE;\n  \n  EVP_MD *sha512 = EVP_MD_fetch(nullptr, \"SHA512\", nullptr);\n  EVP_MD_CTX *ctx[num_block];\n  for(int i=0; i<num_block; i++)//多创建一点ctx让记录数据和校验位分开计算\n  {\n    ctx[i]=EVP_MD_CTX_new();\n    EVP_DigestInit_ex(ctx[i], sha512, nullptr);\n  }\n  uint8_t prev_md[SHA512_DIGEST_LENGTH];\n  SHA512(nullptr, 0, prev_md);\n  for (int i = 0; i < num_block; i++) {\n    uint8_t buffer[BLOCK_SIZE]{};\n    EVP_DigestInit_ex(ctx[i], sha512, nullptr);\n    std::memcpy(buffer, data + i * BLOCK_SIZE, std::min(BLOCK_SIZE, len - i * BLOCK_SIZE));\n    EVP_DigestUpdate(ctx[i], buffer, BLOCK_SIZE);\n  }\n  for(int i=0;i<num_block;i++)\n  {\n    EVP_DigestUpdate(ctx[i], prev_md, SHA512_DIGEST_LENGTH);\n    unsigned int len = 0;\n    EVP_DigestFinal_ex(ctx[i], prev_md, &len);\n    EVP_MD_CTX_free(ctx[i]);\n  }\n  std::memcpy(obuf, prev_md, SHA512_DIGEST_LENGTH);\n  EVP_MD_free(sha512);\n}\n```\n\n就这一改，run了一下，成了！思路正确！测试了一下几个for循环的耗时，中间数据处理的循环占比最高![image-20240125213808760](HPCGame记录/image-20240125213808760.png)\n\n那就没问题了，开始修改MPI并行程序：\n\n```cpp\n#include <algorithm>\n#include <chrono>\n#include <cstring>\n#include <filesystem>\n#include <fstream>\n#include <iostream>\n#include <mpi.h>\n#include <openssl/evp.h>\n#include <openssl/sha.h>\n\nnamespace fs = std::filesystem;\n\nconstexpr size_t BLOCK_SIZE = 1024 * 1024;\n\nvoid print_checksum(std::ostream &os, uint8_t *md, size_t len);\n\nint main(int argc, char *argv[]) {\n\n  MPI_Init(&argc, &argv);\n\n  int rank, nprocs;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &nprocs);\n\n  if (rank == 0) {\n    if (argc < 3) {\n      std::cout << \"Usage: \" << argv[0] << \" <input_file> <output_file>\"\n                << std::endl;\n      MPI_Abort(MPI_COMM_WORLD, 1);\n    }\n  }\n    fs::path input_path = argv[1];\n    fs::path output_path = argv[2];\n\n    auto total_begin_time = std::chrono::high_resolution_clock::now();\n\n    auto file_size = fs::file_size(input_path);\n    std::cout << input_path << \" size: \" << file_size << std::endl;\n    int num_block = (file_size + BLOCK_SIZE - 1) / BLOCK_SIZE;\n    int proc_num_block = num_block / 8;\n    auto len = file_size / 8;\n    uint8_t *buffer = nullptr;\n    if (file_size != 0) {\n      buffer = new uint8_t[len];\n      std::ifstream istrm(input_path, std::ios::binary);\n      istrm.seekg(rank*len);\n      istrm.read(reinterpret_cast<char *>(buffer), len);\n    }\n\n    auto begin_time = std::chrono::high_resolution_clock::now();\n    \n    EVP_MD *sha512 = EVP_MD_fetch(nullptr, \"SHA512\", nullptr);\n    EVP_MD_CTX *ctx[proc_num_block];\n    for(int i=0; i<proc_num_block; i++)\n    {\n      ctx[i]=EVP_MD_CTX_new();\n      EVP_DigestInit_ex(ctx[i], sha512, nullptr);\n    }\n\n    uint8_t prev_md[SHA512_DIGEST_LENGTH];\n    \n    for (int i = 0; i < proc_num_block; i++) {\n      uint8_t buffer_temp[BLOCK_SIZE]{};\n      std::memcpy(buffer_temp, buffer + i * BLOCK_SIZE, std::min(BLOCK_SIZE, len - i * BLOCK_SIZE));\n      EVP_DigestUpdate(ctx[i], buffer_temp, BLOCK_SIZE);\n    }\n    delete[] buffer;\n\n    if(rank==0){\n      SHA512(nullptr, 0, prev_md);\n      for(int i=0;i<proc_num_block;i++)\n      {\n        EVP_DigestUpdate(ctx[i], prev_md, SHA512_DIGEST_LENGTH);\n        unsigned int len_ex = 0;\n        EVP_DigestFinal_ex(ctx[i], prev_md, &len_ex);\n        EVP_MD_CTX_free(ctx[i]);\n      }\n      MPI_Send(prev_md, SHA512_DIGEST_LENGTH, MPI_UINT8_T, 1, 0, MPI_COMM_WORLD);\n    }else if(rank>0 && rank<7)\n    {\n      MPI_Recv(prev_md, SHA512_DIGEST_LENGTH, MPI_UINT8_T, rank - 1, 0, MPI_COMM_WORLD, MPI_STATUS_IGNORE);\n      for(int i=0;i<proc_num_block;i++)\n      {\n        EVP_DigestUpdate(ctx[i], prev_md, SHA512_DIGEST_LENGTH);\n        unsigned int len_ex = 0;\n        EVP_DigestFinal_ex(ctx[i], prev_md, &len_ex);\n        EVP_MD_CTX_free(ctx[i]);\n      }\n      MPI_Send(prev_md, SHA512_DIGEST_LENGTH, MPI_UINT8_T, rank + 1, 0, MPI_COMM_WORLD);      \n    }else if(rank==7){\n      MPI_Recv(prev_md, SHA512_DIGEST_LENGTH, MPI_UINT8_T, rank - 1, 0, MPI_COMM_WORLD, MPI_STATUS_IGNORE);\n      for(int i=0;i<proc_num_block;i++)\n      {\n        EVP_DigestUpdate(ctx[i], prev_md, SHA512_DIGEST_LENGTH);\n        unsigned int len_ex = 0;\n        EVP_DigestFinal_ex(ctx[i], prev_md, &len_ex);\n        EVP_MD_CTX_free(ctx[i]);\n      }\n    }\n\n    EVP_MD_free(sha512);\n  \n  if(rank==7)\n  {\n    auto end_time = std::chrono::high_resolution_clock::now();\n\n    // print debug information\n    std::cout << \"checksum: \";\n    print_checksum(std::cout, prev_md, SHA512_DIGEST_LENGTH);\n    std::cout << std::endl;\n\n    auto duration = std::chrono::duration_cast<std::chrono::milliseconds>(\n        end_time - begin_time);\n\n    std::cout << \"checksum time cost: \" << std::dec << duration.count() << \"ms\"\n              << std::endl;\n\n    // write checksum to output file\n    std::ofstream output_file(output_path);\n\n    print_checksum(output_file, prev_md, SHA512_DIGEST_LENGTH);\n  \n    auto total_end_time = std::chrono::high_resolution_clock::now();\n\n    auto total_duration = std::chrono::duration_cast<std::chrono::milliseconds>(\n        total_end_time - total_begin_time);\n\n    std::cout << \"total time cost: \" << total_duration.count() << \"ms\"\n              << std::endl;\n  \n  }\n\n  MPI_Finalize();\n  return 0;\n}\n\nvoid print_checksum(std::ostream &os, uint8_t *md, size_t len) {\n  for (int i = 0; i < len; i++) {\n    os << std::setw(2) << std::setfill('0') << std::hex\n       << static_cast<int>(md[i]);\n  }\n}\n```\n\n效果不算特别好，90/120分，检查了一下，发现读取占用时间太长，\n\n偶然想到可以不用一次性读入全部数据，让IO和CPU形成流水线即可\n\n```c\n#include <algorithm>\n#include <chrono>\n#include <cstring>\n#include <filesystem>\n#include <fstream>\n#include <iostream>\n#include <mpi.h>\n#include <openssl/evp.h>\n#include <openssl/sha.h>\n\nnamespace fs = std::filesystem;\n\nconstexpr size_t BLOCK_SIZE = 1024 * 1024;\n\nvoid print_checksum(std::ostream &os, uint8_t *md, size_t len);\n\nint main(int argc, char *argv[]) {\n\n  MPI_Init(&argc, &argv);\n\n  int rank, nprocs;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &nprocs);\n\n  if (rank == 0) {\n    if (argc < 3) {\n      std::cout << \"Usage: \" << argv[0] << \" <input_file> <output_file>\"\n                << std::endl;\n      MPI_Abort(MPI_COMM_WORLD, 1);\n    }\n  }\n    fs::path input_path = argv[1];\n    fs::path output_path = argv[2];\n\n    auto total_begin_time = std::chrono::high_resolution_clock::now();\n\n    auto file_size = fs::file_size(input_path);\n    std::cout << input_path << \" size: \" << file_size << std::endl;\n    int num_block = (file_size + BLOCK_SIZE - 1) / BLOCK_SIZE;\n    int proc_num_block = num_block / 8;\n    auto len = file_size / 8;\n\n    auto begin_time = std::chrono::high_resolution_clock::now();\n    \n    EVP_MD *sha512 = EVP_MD_fetch(nullptr, \"SHA512\", nullptr);\n    EVP_MD_CTX *ctx[proc_num_block];\n    for(int i=0; i<proc_num_block; i++)\n    {\n      ctx[i]=EVP_MD_CTX_new();\n      EVP_DigestInit_ex(ctx[i], sha512, nullptr);\n    }\n\n    uint8_t prev_md[SHA512_DIGEST_LENGTH];\n    std::ifstream istrm(input_path, std::ios::binary);\n    uint8_t buffer_temp[BLOCK_SIZE];\n    for (int i = 0; i < proc_num_block; i++) {\n      istrm.seekg(rank*len + i*BLOCK_SIZE);\n      istrm.read(reinterpret_cast<char *>(buffer_temp),BLOCK_SIZE);\n        //IO和CPU流水线\n      EVP_DigestUpdate(ctx[i], buffer_temp, BLOCK_SIZE);\n    }\n\n    if(rank==0){\n      SHA512(nullptr, 0, prev_md);\n      for(int i=0;i<proc_num_block;i++)\n      {\n        EVP_DigestUpdate(ctx[i], prev_md, SHA512_DIGEST_LENGTH);\n        unsigned int len_ex = 0;\n        EVP_DigestFinal_ex(ctx[i], prev_md, &len_ex);\n        EVP_MD_CTX_free(ctx[i]);\n      }\n      MPI_Send(prev_md, SHA512_DIGEST_LENGTH, MPI_UINT8_T, 1, 0, MPI_COMM_WORLD);\n    }else if(rank>0 && rank<7)\n    {\n      MPI_Recv(prev_md, SHA512_DIGEST_LENGTH, MPI_UINT8_T, rank - 1, 0, MPI_COMM_WORLD, MPI_STATUS_IGNORE);\n      for(int i=0;i<proc_num_block;i++)\n      {\n        EVP_DigestUpdate(ctx[i], prev_md, SHA512_DIGEST_LENGTH);\n        unsigned int len_ex = 0;\n        EVP_DigestFinal_ex(ctx[i], prev_md, &len_ex);\n        EVP_MD_CTX_free(ctx[i]);\n      }\n      MPI_Send(prev_md, SHA512_DIGEST_LENGTH, MPI_UINT8_T, rank + 1, 0, MPI_COMM_WORLD);      \n    }else if(rank==7){\n      MPI_Recv(prev_md, SHA512_DIGEST_LENGTH, MPI_UINT8_T, rank - 1, 0, MPI_COMM_WORLD, MPI_STATUS_IGNORE);\n      for(int i=0;i<proc_num_block;i++)\n      {\n        EVP_DigestUpdate(ctx[i], prev_md, SHA512_DIGEST_LENGTH);\n        unsigned int len_ex = 0;\n        EVP_DigestFinal_ex(ctx[i], prev_md, &len_ex);\n        EVP_MD_CTX_free(ctx[i]);\n      }\n    }\n\n    EVP_MD_free(sha512);\n  \n  if(rank==7)\n  {\n    auto end_time = std::chrono::high_resolution_clock::now();\n\n    // print debug information\n    std::cout << \"checksum: \";\n    print_checksum(std::cout, prev_md, SHA512_DIGEST_LENGTH);\n    std::cout << std::endl;\n\n    auto duration = std::chrono::duration_cast<std::chrono::milliseconds>(\n        end_time - begin_time);\n\n    std::cout << \"checksum time cost: \" << std::dec << duration.count() << \"ms\"\n              << std::endl;\n\n    // write checksum to output file\n    std::ofstream output_file(output_path);\n\n    print_checksum(output_file, prev_md, SHA512_DIGEST_LENGTH);\n  \n    auto total_end_time = std::chrono::high_resolution_clock::now();\n\n    auto total_duration = std::chrono::duration_cast<std::chrono::milliseconds>(\n        total_end_time - total_begin_time);\n\n    std::cout << \"total time cost: \" << total_duration.count() << \"ms\"\n              << std::endl;\n  \n  }\n  MPI_Finalize();\n  return 0;\n}\n\nvoid print_checksum(std::ostream &os, uint8_t *md, size_t len) {\n  for (int i = 0; i < len; i++) {\n    os << std::setw(2) << std::setfill('0') << std::hex\n       << static_cast<int>(md[i]);\n  }\n}\n```\n\n速度得到了非常显著的提升，get满分\n\n## H.矩阵乘法\n\n [矩阵乘法.mhtml](矩阵乘法.mhtml) \n\n经典题目，同样的配方，用AVX512+Openmp+分块计算基本就能有不错的效果，不过我也只拿到了73/100分（菜就该多练），直接把printf去掉了都拿不到高分┭┮﹏┭┮\n\n```cpp\n#include <iostream>\n#include <chrono>\n#include <immintrin.h>\n#include <omp.h>\n#include <cmath>\n#define BLOCKSIZE 128\n#define AVX_F_CAPACITY 8\n\nvoid mul(double* a, double* b, double* c, uint64_t n1, uint64_t n2, uint64_t n3) {\n#pragma omp parallel for\n    for (uint64_t i = 0; i < n1; i+=BLOCKSIZE) {\n        for (uint64_t j = 0; j < n2; j+=BLOCKSIZE) {\n            for (uint64_t k = 0; k < n3; k+=BLOCKSIZE) {\n\n                for(uint64_t ii=i; ii<i+BLOCKSIZE; ii+=AVX_F_CAPACITY)\n                {\n                    for(uint64_t kk=k; kk<k+BLOCKSIZE; kk+=16)\n                    {\n                        __m512d vc0,vc1,vc2,vc3,vc4,vc5,vc6,vc7,vc8,vc9,vc10,vc11,vc12,vc13,vc14,vc15,vb,vb1;\n                        vc0 = _mm512_load_pd(&c[ii*n3+kk]);\n                        vc8 = _mm512_load_pd(&c[ii*n3+kk+8]);\n                        vc1 = _mm512_load_pd(&c[(ii+1)*n3+kk]);\n                        vc9 = _mm512_load_pd(&c[(ii+1)*n3+kk+8]);\n                        vc2 = _mm512_load_pd(&c[(ii+2)*n3+kk]);\n                        vc10 = _mm512_load_pd(&c[(ii+2)*n3+kk+8]);\n                        vc3 = _mm512_load_pd(&c[(ii+3)*n3+kk]);\n                        vc11 = _mm512_load_pd(&c[(ii+3)*n3+kk+8]);\n                        vc4 = _mm512_load_pd(&c[(ii+4)*n3+kk]);\n                        vc12 = _mm512_load_pd(&c[(ii+4)*n3+kk+8]);\n                        vc5 = _mm512_load_pd(&c[(ii+5)*n3+kk]);\n                        vc13 = _mm512_load_pd(&c[(ii+5)*n3+kk+8]);\n                        vc6 = _mm512_load_pd(&c[(ii+6)*n3+kk]);\n                        vc14 = _mm512_load_pd(&c[(ii+6)*n3+kk+8]);\n                        vc7 = _mm512_load_pd(&c[(ii+7)*n3+kk]);\n                        vc15 = _mm512_load_pd(&c[(ii+7)*n3+kk+8]);\n\n                        for(uint64_t jj=j; jj<j+BLOCKSIZE; jj+=AVX_F_CAPACITY)\n                        {\n                            vb=_mm512_load_pd(&b[jj*n3 + kk]);\n                            vb1=_mm512_load_pd(&b[jj*n3 + kk+8]);\n                            vc0 = _mm512_fmadd_pd(_mm512_set1_pd(a[ii*n2+jj]),vb,vc0);\n                            vc8 = _mm512_fmadd_pd(_mm512_set1_pd(a[ii*n2+jj]),vb1,vc8);\n                            vc1 = _mm512_fmadd_pd(_mm512_set1_pd(a[(ii+1)*n2+jj]),vb,vc1);\n                            vc9 = _mm512_fmadd_pd(_mm512_set1_pd(a[(ii+1)*n2+jj]),vb1,vc9);\n                            vc2 = _mm512_fmadd_pd(_mm512_set1_pd(a[(ii+2)*n2+jj]),vb,vc2);\n                            vc10 = _mm512_fmadd_pd(_mm512_set1_pd(a[(ii+2)*n2+jj]),vb1,vc10);\n                            vc3 = _mm512_fmadd_pd(_mm512_set1_pd(a[(ii+3)*n2+jj]),vb,vc3);\n                            vc11 = _mm512_fmadd_pd(_mm512_set1_pd(a[(ii+3)*n2+jj]),vb1,vc11);\n                            vc4 = _mm512_fmadd_pd(_mm512_set1_pd(a[(ii+4)*n2+jj]),vb,vc4);\n                            vc12 = _mm512_fmadd_pd(_mm512_set1_pd(a[(ii+4)*n2+jj]),vb1,vc12);\n                            vc5 = _mm512_fmadd_pd(_mm512_set1_pd(a[(ii+5)*n2+jj]),vb,vc5);\n                            vc13 = _mm512_fmadd_pd(_mm512_set1_pd(a[(ii+5)*n2+jj]),vb1,vc13);\n                            vc6 = _mm512_fmadd_pd(_mm512_set1_pd(a[(ii+6)*n2+jj]),vb,vc6);\n                            vc14 = _mm512_fmadd_pd(_mm512_set1_pd(a[(ii+6)*n2+jj]),vb1,vc14);\n                            vc7 = _mm512_fmadd_pd(_mm512_set1_pd(a[(ii+7)*n2+jj]),vb,vc7);\n                            vc15 = _mm512_fmadd_pd(_mm512_set1_pd(a[(ii+7)*n2+jj]),vb1,vc15);\n                        \n\n                            vb=_mm512_load_pd(&b[(jj+1)*n3 + kk]);\n                            vb1=_mm512_load_pd(&b[(jj+1)*n3 + kk+8]);\n                            vc0 = _mm512_fmadd_pd(_mm512_set1_pd(a[ii*n2+jj+1]),vb,vc0);\n                            vc8 = _mm512_fmadd_pd(_mm512_set1_pd(a[ii*n2+jj+1]),vb1,vc8);\n                            vc1 = _mm512_fmadd_pd(_mm512_set1_pd(a[(ii+1)*n2+jj+1]),vb,vc1);\n                            vc9 = _mm512_fmadd_pd(_mm512_set1_pd(a[(ii+1)*n2+jj+1]),vb1,vc9);\n                            vc2 = _mm512_fmadd_pd(_mm512_set1_pd(a[(ii+2)*n2+jj+1]),vb,vc2);\n                            vc10 = _mm512_fmadd_pd(_mm512_set1_pd(a[(ii+2)*n2+jj+1]),vb1,vc10);\n                            vc3 = _mm512_fmadd_pd(_mm512_set1_pd(a[(ii+3)*n2+jj+1]),vb,vc3);\n                            vc11 = _mm512_fmadd_pd(_mm512_set1_pd(a[(ii+3)*n2+jj+1]),vb1,vc11);\n                            vc4 = _mm512_fmadd_pd(_mm512_set1_pd(a[(ii+4)*n2+jj+1]),vb,vc4);\n                            vc12 = _mm512_fmadd_pd(_mm512_set1_pd(a[(ii+4)*n2+jj+1]),vb1,vc12);\n                            vc5 = _mm512_fmadd_pd(_mm512_set1_pd(a[(ii+5)*n2+jj+1]),vb,vc5);\n                            vc13 = _mm512_fmadd_pd(_mm512_set1_pd(a[(ii+5)*n2+jj+1]),vb1,vc13);\n                            vc6 = _mm512_fmadd_pd(_mm512_set1_pd(a[(ii+6)*n2+jj+1]),vb,vc6);\n                            vc14 = _mm512_fmadd_pd(_mm512_set1_pd(a[(ii+6)*n2+jj+1]),vb1,vc14);\n                            vc7 = _mm512_fmadd_pd(_mm512_set1_pd(a[(ii+7)*n2+jj+1]),vb,vc7);\n                            vc15 = _mm512_fmadd_pd(_mm512_set1_pd(a[(ii+7)*n2+jj+1]),vb1,vc15);\n\n                            vb=_mm512_load_pd(&b[(jj+2)*n3 + kk]);\n                            vb1=_mm512_load_pd(&b[(jj+2)*n3 + kk+8]);\n                            vc0 = _mm512_fmadd_pd(_mm512_set1_pd(a[ii*n2+jj+2]),vb,vc0);\n                            vc8 = _mm512_fmadd_pd(_mm512_set1_pd(a[ii*n2+jj+2]),vb1,vc8);\n                            vc1 = _mm512_fmadd_pd(_mm512_set1_pd(a[(ii+1)*n2+jj+2]),vb,vc1);\n                            vc9 = _mm512_fmadd_pd(_mm512_set1_pd(a[(ii+1)*n2+jj+2]),vb1,vc9);\n                            vc2 = _mm512_fmadd_pd(_mm512_set1_pd(a[(ii+2)*n2+jj+2]),vb,vc2);\n                            vc10 = _mm512_fmadd_pd(_mm512_set1_pd(a[(ii+2)*n2+jj+2]),vb1,vc10);\n                            vc3 = _mm512_fmadd_pd(_mm512_set1_pd(a[(ii+3)*n2+jj+2]),vb,vc3);\n                            vc11 = _mm512_fmadd_pd(_mm512_set1_pd(a[(ii+3)*n2+jj+2]),vb1,vc11);\n                            vc4 = _mm512_fmadd_pd(_mm512_set1_pd(a[(ii+4)*n2+jj+2]),vb,vc4);\n                            vc12 = _mm512_fmadd_pd(_mm512_set1_pd(a[(ii+4)*n2+jj+2]),vb1,vc12);\n                            vc5 = _mm512_fmadd_pd(_mm512_set1_pd(a[(ii+5)*n2+jj+2]),vb,vc5);\n                            vc13 = _mm512_fmadd_pd(_mm512_set1_pd(a[(ii+5)*n2+jj+2]),vb1,vc13);\n                            vc6 = _mm512_fmadd_pd(_mm512_set1_pd(a[(ii+6)*n2+jj+2]),vb,vc6);\n                            vc14 = _mm512_fmadd_pd(_mm512_set1_pd(a[(ii+6)*n2+jj+2]),vb1,vc14);\n                            vc7 = _mm512_fmadd_pd(_mm512_set1_pd(a[(ii+7)*n2+jj+2]),vb,vc7);\n                            vc15 = _mm512_fmadd_pd(_mm512_set1_pd(a[(ii+7)*n2+jj+2]),vb1,vc15);\n\n                            vb=_mm512_load_pd(&b[(jj+3)*n3 + kk]);\n                            vb1=_mm512_load_pd(&b[(jj+3)*n3 + kk+8]);\n                            vc0 = _mm512_fmadd_pd(_mm512_set1_pd(a[ii*n2+jj+3]),vb,vc0);\n                            vc8 = _mm512_fmadd_pd(_mm512_set1_pd(a[ii*n2+jj+3]),vb1,vc8);\n                            vc1 = _mm512_fmadd_pd(_mm512_set1_pd(a[(ii+1)*n2+jj+3]),vb,vc1);\n                            vc9 = _mm512_fmadd_pd(_mm512_set1_pd(a[(ii+1)*n2+jj+3]),vb1,vc9);\n                            vc2 = _mm512_fmadd_pd(_mm512_set1_pd(a[(ii+2)*n2+jj+3]),vb,vc2);\n                            vc10 = _mm512_fmadd_pd(_mm512_set1_pd(a[(ii+2)*n2+jj+3]),vb1,vc10);\n                            vc3 = _mm512_fmadd_pd(_mm512_set1_pd(a[(ii+3)*n2+jj+3]),vb,vc3);\n                            vc11 = _mm512_fmadd_pd(_mm512_set1_pd(a[(ii+3)*n2+jj+3]),vb1,vc11);\n                            vc4 = _mm512_fmadd_pd(_mm512_set1_pd(a[(ii+4)*n2+jj+3]),vb,vc4);\n                            vc12 = _mm512_fmadd_pd(_mm512_set1_pd(a[(ii+4)*n2+jj+3]),vb1,vc12);\n                            vc5 = _mm512_fmadd_pd(_mm512_set1_pd(a[(ii+5)*n2+jj+3]),vb,vc5);\n                            vc13 = _mm512_fmadd_pd(_mm512_set1_pd(a[(ii+5)*n2+jj+3]),vb1,vc13);\n                            vc6 = _mm512_fmadd_pd(_mm512_set1_pd(a[(ii+6)*n2+jj+3]),vb,vc6);\n                            vc14 = _mm512_fmadd_pd(_mm512_set1_pd(a[(ii+6)*n2+jj+3]),vb1,vc14);\n                            vc7 = _mm512_fmadd_pd(_mm512_set1_pd(a[(ii+7)*n2+jj+3]),vb,vc7);\n                            vc15 = _mm512_fmadd_pd(_mm512_set1_pd(a[(ii+7)*n2+jj+3]),vb1,vc15);\n                            \n                            vb=_mm512_load_pd(&b[(jj+4)*n3 + kk]);\n                            vb1=_mm512_load_pd(&b[(jj+4)*n3 + kk+8]);\n                            vc0 = _mm512_fmadd_pd(_mm512_set1_pd(a[ii*n2+jj+4]),vb,vc0);\n                            vc8 = _mm512_fmadd_pd(_mm512_set1_pd(a[ii*n2+jj+4]),vb1,vc8);\n                            vc1 = _mm512_fmadd_pd(_mm512_set1_pd(a[(ii+1)*n2+jj+4]),vb,vc1);\n                            vc9 = _mm512_fmadd_pd(_mm512_set1_pd(a[(ii+1)*n2+jj+4]),vb1,vc9);\n                            vc2 = _mm512_fmadd_pd(_mm512_set1_pd(a[(ii+2)*n2+jj+4]),vb,vc2);\n                            vc10 = _mm512_fmadd_pd(_mm512_set1_pd(a[(ii+2)*n2+jj+4]),vb1,vc10);\n                            vc3 = _mm512_fmadd_pd(_mm512_set1_pd(a[(ii+3)*n2+jj+4]),vb,vc3);\n                            vc11 = _mm512_fmadd_pd(_mm512_set1_pd(a[(ii+3)*n2+jj+4]),vb1,vc11);\n                            vc4 = _mm512_fmadd_pd(_mm512_set1_pd(a[(ii+4)*n2+jj+4]),vb,vc4);\n                            vc12 = _mm512_fmadd_pd(_mm512_set1_pd(a[(ii+4)*n2+jj+4]),vb1,vc12);\n                            vc5 = _mm512_fmadd_pd(_mm512_set1_pd(a[(ii+5)*n2+jj+4]),vb,vc5);\n                            vc13 = _mm512_fmadd_pd(_mm512_set1_pd(a[(ii+5)*n2+jj+4]),vb1,vc13);\n                            vc6 = _mm512_fmadd_pd(_mm512_set1_pd(a[(ii+6)*n2+jj+4]),vb,vc6);\n                            vc14 = _mm512_fmadd_pd(_mm512_set1_pd(a[(ii+6)*n2+jj+4]),vb1,vc14);\n                            vc7 = _mm512_fmadd_pd(_mm512_set1_pd(a[(ii+7)*n2+jj+4]),vb,vc7);\n                            vc15 = _mm512_fmadd_pd(_mm512_set1_pd(a[(ii+7)*n2+jj+4]),vb1,vc15);\n\n                            vb=_mm512_load_pd(&b[(jj+5)*n3 + kk]);\n                            vb1=_mm512_load_pd(&b[(jj+5)*n3 + kk+8]);\n                            vc0 = _mm512_fmadd_pd(_mm512_set1_pd(a[ii*n2+jj+5]),vb,vc0);\n                            vc8 = _mm512_fmadd_pd(_mm512_set1_pd(a[ii*n2+jj+5]),vb1,vc8);\n                            vc1 = _mm512_fmadd_pd(_mm512_set1_pd(a[(ii+1)*n2+jj+5]),vb,vc1);\n                            vc9 = _mm512_fmadd_pd(_mm512_set1_pd(a[(ii+1)*n2+jj+5]),vb1,vc9);\n                            vc2 = _mm512_fmadd_pd(_mm512_set1_pd(a[(ii+2)*n2+jj+5]),vb,vc2);\n                            vc10 = _mm512_fmadd_pd(_mm512_set1_pd(a[(ii+2)*n2+jj+5]),vb1,vc10);\n                            vc3 = _mm512_fmadd_pd(_mm512_set1_pd(a[(ii+3)*n2+jj+5]),vb,vc3);\n                            vc11 = _mm512_fmadd_pd(_mm512_set1_pd(a[(ii+3)*n2+jj+5]),vb1,vc11);\n                            vc4 = _mm512_fmadd_pd(_mm512_set1_pd(a[(ii+4)*n2+jj+5]),vb,vc4);\n                            vc12 = _mm512_fmadd_pd(_mm512_set1_pd(a[(ii+4)*n2+jj+5]),vb1,vc12);\n                            vc5 = _mm512_fmadd_pd(_mm512_set1_pd(a[(ii+5)*n2+jj+5]),vb,vc5);\n                            vc13 = _mm512_fmadd_pd(_mm512_set1_pd(a[(ii+5)*n2+jj+5]),vb1,vc13);\n                            vc6 = _mm512_fmadd_pd(_mm512_set1_pd(a[(ii+6)*n2+jj+5]),vb,vc6);\n                            vc14 = _mm512_fmadd_pd(_mm512_set1_pd(a[(ii+6)*n2+jj+5]),vb1,vc14);\n                            vc7 = _mm512_fmadd_pd(_mm512_set1_pd(a[(ii+7)*n2+jj+5]),vb,vc7);\n                            vc15 = _mm512_fmadd_pd(_mm512_set1_pd(a[(ii+7)*n2+jj+5]),vb1,vc15);\n                            \n\n                            vb=_mm512_load_pd(&b[(jj+6)*n3 + kk]);\n                            vb1=_mm512_load_pd(&b[(jj+6)*n3 + kk+8]);\n                            vc0 = _mm512_fmadd_pd(_mm512_set1_pd(a[ii*n2+jj+6]),vb,vc0);\n                            vc8 = _mm512_fmadd_pd(_mm512_set1_pd(a[ii*n2+jj+6]),vb1,vc8);\n                            vc1 = _mm512_fmadd_pd(_mm512_set1_pd(a[(ii+1)*n2+jj+6]),vb,vc1);\n                            vc9 = _mm512_fmadd_pd(_mm512_set1_pd(a[(ii+1)*n2+jj+6]),vb1,vc9);\n                            vc2 = _mm512_fmadd_pd(_mm512_set1_pd(a[(ii+2)*n2+jj+6]),vb,vc2);\n                            vc10 = _mm512_fmadd_pd(_mm512_set1_pd(a[(ii+2)*n2+jj+6]),vb1,vc10);\n                            vc3 = _mm512_fmadd_pd(_mm512_set1_pd(a[(ii+3)*n2+jj+6]),vb,vc3);\n                            vc11 = _mm512_fmadd_pd(_mm512_set1_pd(a[(ii+3)*n2+jj+6]),vb1,vc11);\n                            vc4 = _mm512_fmadd_pd(_mm512_set1_pd(a[(ii+4)*n2+jj+6]),vb,vc4);\n                            vc12 = _mm512_fmadd_pd(_mm512_set1_pd(a[(ii+4)*n2+jj+6]),vb1,vc12);\n                            vc5 = _mm512_fmadd_pd(_mm512_set1_pd(a[(ii+5)*n2+jj+6]),vb,vc5);\n                            vc13 = _mm512_fmadd_pd(_mm512_set1_pd(a[(ii+5)*n2+jj+6]),vb1,vc13);\n                            vc6 = _mm512_fmadd_pd(_mm512_set1_pd(a[(ii+6)*n2+jj+6]),vb,vc6);\n                            vc14 = _mm512_fmadd_pd(_mm512_set1_pd(a[(ii+6)*n2+jj+6]),vb1,vc14);\n                            vc7 = _mm512_fmadd_pd(_mm512_set1_pd(a[(ii+7)*n2+jj+6]),vb,vc7);\n                            vc15 = _mm512_fmadd_pd(_mm512_set1_pd(a[(ii+7)*n2+jj+6]),vb1,vc15);\n\n                            vb=_mm512_load_pd(&b[(jj+7)*n3 + kk]);\n                            vb1=_mm512_load_pd(&b[(jj+7)*n3 + kk+8]);\n                            vc0 = _mm512_fmadd_pd(_mm512_set1_pd(a[ii*n2+jj+7]),vb,vc0);\n                            vc8 = _mm512_fmadd_pd(_mm512_set1_pd(a[ii*n2+jj+7]),vb1,vc8);\n                            vc1 = _mm512_fmadd_pd(_mm512_set1_pd(a[(ii+1)*n2+jj+7]),vb,vc1);\n                            vc9 = _mm512_fmadd_pd(_mm512_set1_pd(a[(ii+1)*n2+jj+7]),vb1,vc9);\n                            vc2 = _mm512_fmadd_pd(_mm512_set1_pd(a[(ii+2)*n2+jj+7]),vb,vc2);\n                            vc10 = _mm512_fmadd_pd(_mm512_set1_pd(a[(ii+2)*n2+jj+7]),vb1,vc10);\n                            vc3 = _mm512_fmadd_pd(_mm512_set1_pd(a[(ii+3)*n2+jj+7]),vb,vc3);\n                            vc11 = _mm512_fmadd_pd(_mm512_set1_pd(a[(ii+3)*n2+jj+7]),vb1,vc11);\n                            vc4 = _mm512_fmadd_pd(_mm512_set1_pd(a[(ii+4)*n2+jj+7]),vb,vc4);\n                            vc12 = _mm512_fmadd_pd(_mm512_set1_pd(a[(ii+4)*n2+jj+7]),vb1,vc12);\n                            vc5 = _mm512_fmadd_pd(_mm512_set1_pd(a[(ii+5)*n2+jj+7]),vb,vc5);\n                            vc13 = _mm512_fmadd_pd(_mm512_set1_pd(a[(ii+5)*n2+jj+7]),vb1,vc13);\n                            vc6 = _mm512_fmadd_pd(_mm512_set1_pd(a[(ii+6)*n2+jj+7]),vb,vc6);\n                            vc14 = _mm512_fmadd_pd(_mm512_set1_pd(a[(ii+6)*n2+jj+7]),vb1,vc14);\n                            vc7 = _mm512_fmadd_pd(_mm512_set1_pd(a[(ii+7)*n2+jj+7]),vb,vc7);                            \n                            vc15 = _mm512_fmadd_pd(_mm512_set1_pd(a[(ii+7)*n2+jj+7]),vb1,vc15);\n                        }\n                        _mm512_store_pd(&c[ii*n3 + kk],vc0);\n                        _mm512_store_pd(&c[ii*n3 + kk+8],vc8);\n                        _mm512_store_pd(&c[(ii+1)*n3 + kk],vc1);\n                        _mm512_store_pd(&c[(ii+1)*n3 + kk+8],vc9);\n                        _mm512_store_pd(&c[(ii+2)*n3 + kk],vc2);\n                        _mm512_store_pd(&c[(ii+2)*n3 + kk+8],vc10);\n                        _mm512_store_pd(&c[(ii+3)*n3 + kk],vc3);\n                        _mm512_store_pd(&c[(ii+3)*n3 + kk+8],vc11);\n                        _mm512_store_pd(&c[(ii+4)*n3 + kk],vc4);\n                        _mm512_store_pd(&c[(ii+4)*n3 + kk+8],vc12);\n                        _mm512_store_pd(&c[(ii+5)*n3 + kk],vc5);\n                        _mm512_store_pd(&c[(ii+5)*n3 + kk+8],vc13);\n                        _mm512_store_pd(&c[(ii+6)*n3 + kk],vc6);\n                        _mm512_store_pd(&c[(ii+6)*n3 + kk+8],vc14);\n                        _mm512_store_pd(&c[(ii+7)*n3 + kk],vc7);\n                        _mm512_store_pd(&c[(ii+7)*n3 + kk+8],vc15);\n                    }\n                }\n            \n            }\n        }\n    }\n}\nint main() {\n uint64_t n1, n2, n3;\n FILE* fi;\n\n fi = fopen(\"conf.data\", \"rb\");\n fread(&n1, 1, 8, fi);\n fread(&n2, 1, 8, fi);\n fread(&n3, 1, 8, fi);\n\n double* a = (double*)_mm_malloc(n1 * n2 * 8,64);\n double* b = (double*)_mm_malloc(n2 * n3 * 8,64);\n double* c = (double*)_mm_malloc(n1 * n3 * 8,64);\n\n fread(a, 1, n1 * n2 * 8, fi);\n fread(b, 1, n2 * n3 * 8, fi);\n fclose(fi);\n\n for (uint64_t i = 0; i < n1; i++) {\n  for (uint64_t k = 0; k < n3; k++) {\n   c[i * n3 + k] = 0;\n  }\n }\n\n\n auto t1 = std::chrono::steady_clock::now();\n mul(a, b, c, n1, n2, n3);\n auto t2 = std::chrono::steady_clock::now();\n int d1 = std::chrono::duration_cast<std::chrono::milliseconds>(t2 - t1).count();\n printf(\"%d\\n\", d1);\n// printf(\"c:%.4lf\\n\",c[202]);\n\n fi = fopen(\"out.data\", \"wb\");\n fwrite(c, 1, n1 * n3 * 8, fi);\n fclose(fi);\n\n return 0;\n}\n```\n\n\n\n## I.logistic 方程\n\n [Logistic方程.mhtml](Logistic方程.mhtml) \n\n这题卡了一下午，分数一直是20多分，实在看不下去\n\n一开始只是对it、itv函数进行简单的AVX和openmp处理，出来的结果实在不让人满意，后来经过对函数结构的观察，发现两个循环可以换位置，于是交换了一下，再在内部开openmp，确实还是差点意思，想到这道题反复强调向量化，就尝试将迭代次数减少一部分，放进内部循环，此时发现效果还可以。代码如下：\n\n```cpp\n#define N 8\ndouble count_itv(double r, double x) {\n    return r * x * (1.0 - x);\n}\n\nvoid itv(double r, double* x, int64_t n, int64_t itn) {\n    #pragma omp parallel\n    {\n        for (int64_t j = 0; j < itn/N; j++) {\n            #pragma omp for\n            for (int64_t i = 0; i < n; i++) {\n                for (int64_t k = 0; k <N; k++) {\n                    x[i] = count_itv(r, x[i]);\n                }\n            }\n        }\n    }\n}\n```\n\n数字16是经过反复尝试，调整出来的最好结果，因为itn=32768，所以必须选择可以除尽的数\n\n![image-20240124010147362](HPCGame记录/image-20240124010147362.png)\n\n还差4分，难受，改了一下手动向量化，代码如下：\n\n```cpp\n    __m512d avx_one = _mm512_set1_pd(1.0);\n    __m512d avx_r = _mm512_set1_pd(r);\n    #pragma omp parallel\n    {\n        for (short i=0; i<itn/N; ++i) {\n            #pragma omp for\n            for (int64_t j=0; j<n; j+=8) {\n                __m512d avx_x = _mm512_load_pd(&x[j]);\n                for (short k=0; k<N; ++k) {\n                    __m512d avx_tmp = _mm512_mul_pd(avx_r, avx_x);\n                    avx_x = _mm512_mul_pd(avx_tmp, _mm512_sub_pd(avx_one, avx_x));\n                }\n                _mm512_store_pd(&x[j], avx_x);\n            }\n        }\n    }\n```\n\n![image-20240124013348557](HPCGame记录/image-20240124013348557.png)\n\n额(⊙o⊙)…毁灭吧，我累了\n\n后期突然注意到，openmp开错了，这道题还是openmp+向量化，但是我神奇般的过了...卡了个bug\n\n来自一位学长的**修正：**\n\n```cpp\n#include <iostream>\n#include <chrono>\n#include <omp.h>\n#include <immintrin.h>\n\n// Define macro for aligning memory to 64 bytes for AVX-512\n#define ALIGNMENT 64\n\ndouble it(double r, double x, int64_t itn) {\n    for (int64_t i = 0; i < itn; i++) {\n        x = r * x * (1.0 - x);\n    }\n    return x;\n}\n\nvoid itv(double r, double* x, int64_t n, int64_t itn) {\n    __builtin_assume_aligned(x, 64);\n    __m512d r_vec=_mm512_set1_pd(r);\n    __m512d vec_1=_mm512_set1_pd(1.0);\n    #pragma omp parallel for collapse(1) \n    #pragma vector aligned\n    for (int64_t i = 0; i < n; i += 64) {\n        __m512d x_vec1 = _mm512_loadu_pd(&x[i]);\n        __m512d x_vec2 = _mm512_loadu_pd(&x[i+8]);\n        __m512d x_vec3 = _mm512_loadu_pd(&x[i+16]);\n        __m512d x_vec4 = _mm512_loadu_pd(&x[i+24]);\n        __m512d x_vec5 = _mm512_loadu_pd(&x[i+32]);\n        __m512d x_vec6 = _mm512_loadu_pd(&x[i+40]);\n        __m512d x_vec7 = _mm512_loadu_pd(&x[i+48]);\n        __m512d x_vec8 = _mm512_loadu_pd(&x[i+56]);\n        for (int64_t j = 0; j < itn; j++) {\n            x_vec1 = _mm512_mul_pd(_mm512_mul_pd(r_vec, x_vec1),\n                                   _mm512_sub_pd(vec_1, x_vec1));\n            x_vec2 = _mm512_mul_pd(_mm512_mul_pd(r_vec, x_vec2),\n                       \t\t\t   _mm512_sub_pd(vec_1, x_vec2));\n            x_vec3 = _mm512_mul_pd(_mm512_mul_pd(r_vec, x_vec3),\n                       \t\t\t   _mm512_sub_pd(vec_1, x_vec3));\n            x_vec4 = _mm512_mul_pd(_mm512_mul_pd(r_vec, x_vec4),\n                       \t\t\t   _mm512_sub_pd(vec_1, x_vec4));\n            x_vec5 = _mm512_mul_pd(_mm512_mul_pd(r_vec, x_vec5),\n                       \t\t\t   _mm512_sub_pd(vec_1, x_vec5));\n            x_vec6 = _mm512_mul_pd(_mm512_mul_pd(r_vec, x_vec6),\n                       \t\t\t   _mm512_sub_pd(vec_1, x_vec6));\n            x_vec7 = _mm512_mul_pd(_mm512_mul_pd(r_vec, x_vec7),\n                       \t\t\t   _mm512_sub_pd(vec_1, x_vec7));\n            x_vec8 = _mm512_mul_pd(_mm512_mul_pd(r_vec, x_vec8),\n           \t\t\t   \t\t\t   _mm512_sub_pd(vec_1, x_vec8));\n        }\n        _mm512_storeu_pd(&x[i], x_vec1);\n        _mm512_storeu_pd(&x[i+8], x_vec2);\n        _mm512_storeu_pd(&x[i+16], x_vec3);\n        _mm512_storeu_pd(&x[i+24], x_vec4);\n        _mm512_storeu_pd(&x[i+32], x_vec5);\n        _mm512_storeu_pd(&x[i+40], x_vec6);\n        _mm512_storeu_pd(&x[i+48], x_vec7);\n        _mm512_storeu_pd(&x[i+56], x_vec8);\n    }\n}\n\nint main(){\n    FILE* fi;\n    fi = fopen(\"conf.data\", \"rb\");\n\n    int64_t itn;\n    double r;\n    int64_t n;\n    double* x;\n\n    fread(&itn, 1, 8, fi);\n    fread(&r, 1, 8, fi);\n    fread(&n, 1, 8, fi);\n\n    // Allocate aligned memory for better AVX-512 performance\n    x = (double*)_mm_malloc(n * 8, ALIGNMENT);\n\n    fread(x, 1, n * 8, fi);\n    fclose(fi);\n\n    auto t1 = std::chrono::steady_clock::now();\n\n    // Use OpenMP for parallelization and AVX-512 for vectorization\n    itv(r, x, n, itn);\n\n    auto t2 = std::chrono::steady_clock::now();\n    int d1 = std::chrono::duration_cast<std::chrono::milliseconds>(t2 - t1).count();\n    printf(\"%d\\n\", d1);\n\n    fi = fopen(\"out.data\", \"wb\");\n    fwrite(x, 1, n * 8, fi);\n    fclose(fi);\n\n    // Free aligned memory\n    _mm_free(x);\n\n    return 0;\n}\n```\n\n\n\n## J.H-66\n\n [H-66.mhtml](H-66.mhtml) \n\n先用了gprof进行了热点分析，结果如下：\n\n![image-20240124102831082](HPCGame记录/image-20240124102831082.png)\n\n可以看到，大部分时间都是花费在了getsp函数上，act函数也是个小热点，\n\n先拿getsp开刀，\n\n1月29日：“遗憾，玩不动这道题”\n\n## L.洪水困兽\n\n [洪水困兽.mhtml](洪水困兽.mhtml) \n\n签到送分题，OpenMP直接过\n\n```cpp\n#include <array>\n#include <fstream>\n#include <iostream>\n#include <omp.h>\n#include <vector>\n#include <cmath>\n#include <tuple>\n\nusing std::vector, std::array, std::tuple, std::string;\n\nvoid particle2grid(int resolution, int numparticle,\n                   const vector<double> &particle_position,\n                   const vector<double> &particle_velocity,\n                   vector<double> &velocityu, vector<double> &velocityv,\n                   vector<double> &weightu, vector<double> &weightv) {\n    double grid_spacing = 1.0 / resolution;\n    double inv_grid_spacing = 1.0 / grid_spacing;\n    auto get_frac = [&inv_grid_spacing](double x, double y) {\n        int xidx = floor(x * inv_grid_spacing);\n        int yidx = floor(y * inv_grid_spacing);\n        double fracx = x * inv_grid_spacing - xidx;\n        double fracy = y * inv_grid_spacing - yidx;\n        return tuple(array<int, 2>{xidx, yidx},\n                     array<double, 4>{fracx * fracy, (1 - fracx) * fracy,\n                                      fracx * (1 - fracy),\n                                      (1 - fracx) * (1 - fracy)});\n    };\n\n    #pragma omp parallel for\n    for (int i = 0; i < numparticle; i++) {\n        array<int, 4> offsetx = {0, 1, 0, 1};\n        array<int, 4> offsety = {0, 0, 1, 1};\n\n        auto [idxu, fracu] =\n            get_frac(particle_position[i * 2 + 0],\n                     particle_position[i * 2 + 1] - 0.5 * grid_spacing);\n        auto [idxv, fracv] =\n            get_frac(particle_position[i * 2 + 0] - 0.5 * grid_spacing,\n                     particle_position[i * 2 + 1]);\n\n        for (int j = 0; j < 4; j++) {\n            int tmpidx_u = (idxu[0] + offsetx[j]) * resolution + (idxu[1] + offsety[j]);\n            int tmpidx_v = (idxv[0] + offsetx[j]) * (resolution + 1) + (idxv[1] + offsety[j]);\n//关键点就在这里,知道有这个操作就能签到成功，但看到有人手写锁好像也成功了\n            #pragma omp atomic\n            velocityu[tmpidx_u] += particle_velocity[i * 2 + 0] * fracu[j];\n\n            #pragma omp atomic\n            weightu[tmpidx_u] += fracu[j];\n\n            #pragma omp atomic\n            velocityv[tmpidx_v] += particle_velocity[i * 2 + 1] * fracv[j];\n\n            #pragma omp atomic\n            weightv[tmpidx_v] += fracv[j];\n        }\n    }\n}\n\nint main(int argc, char *argv[]) {\n    if (argc < 2) {\n        printf(\"Usage: %s inputfile\\n\", argv[0]);\n        return -1;\n    }\n\n    string inputfile(argv[1]);\n    std::ifstream fin(inputfile, std::ios::binary);\n    if (!fin) {\n        printf(\"Error opening file\");\n        return -1;\n    }\n    \n    int resolution;\n    int numparticle;\n    vector<double> particle_position;\n    vector<double> particle_velocity;\n\n    fin.read((char *)(&resolution), sizeof(int));\n    fin.read((char *)(&numparticle), sizeof(int));\n    \n    particle_position.resize(numparticle * 2);\n    particle_velocity.resize(numparticle * 2);\n    \n    printf(\"resolution: %d\\n\", resolution);\n    printf(\"numparticle: %d\\n\", numparticle);\n    \n    fin.read((char *)(particle_position.data()),\n             sizeof(double) * particle_position.size());\n    fin.read((char *)(particle_velocity.data()),\n             sizeof(double) * particle_velocity.size());\n\n    vector<double> velocityu((resolution + 1) * resolution, 0.0);\n    vector<double> velocityv((resolution + 1) * resolution, 0.0);\n    vector<double> weightu((resolution + 1) * resolution, 0.0);\n    vector<double> weightv((resolution + 1) * resolution, 0.0);\n\n\n    string outputfile;\n\n    particle2grid(resolution, numparticle, particle_position,\n                    particle_velocity, velocityu, velocityv, weightu,\n                    weightv);\n    outputfile = \"output.dat\";\n\n    std::ofstream fout(outputfile, std::ios::binary);\n    if (!fout) {\n        printf(\"Error output file\");\n        return -1;\n    }\n    fout.write((char *)(&resolution), sizeof(int));\n    fout.write(reinterpret_cast<char *>(velocityu.data()),\n               sizeof(double) * velocityu.size());\n    fout.write(reinterpret_cast<char *>(velocityv.data()),\n               sizeof(double) * velocityv.size());\n    fout.write(reinterpret_cast<char *>(weightu.data()),\n               sizeof(double) * weightu.size());\n    fout.write(reinterpret_cast<char *>(weightv.data()),\n               sizeof(double) * weightv.size());\n\n    return 0;\n}\n```\n\n## 其余题：\n\n [光之游戏.mhtml](光之游戏.mhtml) \n\n [3D生命游戏.mhtml](3D生命游戏.mhtml) \n\nRISC-V的题没有放\n","tags":["比赛"]},{"title":"计算机组成原理-(1)","url":"/2024/01/22/计算机组成原理一/","content":"\n# 前言知识：\n\n等差数列公式：\n$$\na_n=a_1+(n-1)d\\\\\nS_n=\\frac {n(a_1+a_n)}{2}=na_1+\\frac {n(n-1)}{2}d\n$$\n等比数列公式：\n$$\na_n=a_1q^{n-1}(q\\neq0)\\\\\nS_n=\\frac {a_1(1-q^n)}{1-q}=\\frac{a_1-a_nq}{1-q}\n$$\n\n\n# 一、计算机系统概论\n\n## 1.1计算机系统简介\n\n**物联网：**把<font color=red>传感器</font>嵌入和装备到各种物体中，并且被普遍连接\n\n计算机系统由<u>**硬件**</u>和<u>**软件**</u>组成\n\n- 硬件：计算机的实体，如主机、外设等\n\n- 软件：由具有各类特殊功能的程序组成 \n\n  ```\n  系统软件：用来管理整个计算机系统，如语言处理程序、操作系统、服务性程序、数据库管理系统、网络软件(如tcp/ip协议的模块)\n  应用软件：按任务需要贬值的各种程序\n  ```\n\n## 1.2计算机硬件基本组成\n\n### 1.2.1冯诺依曼机\n\n第一台计算机ENIAC(埃尼亚克)通过手动接线的方式进行控制计算，效率受到接线的限制\n\n冯诺依曼提出“**存储程序**”：将指令以二进制代码的形式实现输入到计算机的主存储器，然后从首地址开始按序执行指令\n\n**早期冯诺依曼体系结构：**\n\n![image-20240122152233293](计算机组成原理一/image-20240122152233293.png)\n\n<img src=\"计算机组成原理一/image-20240122152116407.png\" alt=\"image-20240122152116407\" style=\"zoom:80%;\" />\n\n步骤：\n\n```\n数据或程序先进入输入设备，将信息转换为机器能识别的形式\n数据通过运算器进行中转到存储器中\n控制器读入存储器中的运算指令（加、乘等）控制运算器做算术运算或逻辑运算\n经过运算后的数据通过输出设备转换为人们能识别的结果\n```\n\n冯诺依曼计算机的特点：\n\n```\n计算机由五大部分组成：输入设备、输出设备、控制器、运算器、存储器\n指令和数据以同等地位存于存储器，可按址寻访\n指令和数据用二进制表示\n指令由操作码和地址码组成\n存储程序：提前把指令和数据存储到存储器中\n以运算器为中心（输入/输出与存储器之间的数据传输通过运算器完成）\n```\n\n### 1.2.2现代计算机的结构\n\n以<font color=red>**存储器**</font>为中心\n\n<img src=\"计算机组成原理一/image-20240122154625927.png\" alt=\"image-20240122154625927\" style=\"zoom:80%;\" />\n\nCPU=运算器+控制器\n\n![image-20240122154923848](计算机组成原理一/image-20240122154923848.png)\n\n<img src=\"计算机组成原理一/image-20240122192046146.png\" alt=\"image-20240122192046146\" style=\"zoom:80%;\" />\n\n**主存：**RAM运行内存\n\n**辅存：**ROM存储大小\n\n### 1.2.3主存储器\n\n![image-20240122210202202](计算机组成原理一/image-20240122210202202.png)\n\n**读取：**CPU将地址传入MAR，从MDR获得数据，控制器控制主存储器执行\"读\"操作\n\n**写入：**CPU将地址传入MAR，数据传入MDR，控制器控制主存储器进行\"写\"操作\n\n**【存储体】：**\n\n数据都在存储体内按<font color=red>地址</font>存储\n\n![image-20240203175618433](计算机组成原理一/image-20240203175618433.png)\n\n存储单元：存储器最小的存储单位，是一串存放二进制代码的空间\n\n存储字（word）：存储单元中二进制代码的组合\n\n存储字长：存储单元中二进制代码的位数（通常为8bit的整数倍）\n\n存储元：用于存储二进制的的电子元件（电容），每个存储元可以存1bit\n\n因此，MAR位数可以反映存储单元的个数，MDR的位数等于存储字长\n\n### 1.2.4运算器\n\n用于实现算术运算（加减乘除），逻辑运算（布尔运算）\n\n![image-20240203175555484](计算机组成原理一/image-20240203175555484.png)\n\n```\nACC:累加器。用于存放操作数或运算结果。\nMQ:乘商寄存器，在乘除运算时，用于存放操作数或运算结果。\nX：通用操作数寄存器，用于存放操作数\nALU：算术逻辑单元，通过内部电路实现算数运算，逻辑运算。\n```\n\n![image-20240203151052252](计算机组成原理一/image-20240203151052252.png)\n\n### 1.2.5控制器\n\n![image-20240203175515496](计算机组成原理一/image-20240203175515496.png)\n\n```\nCU(Control Unit):控制单元，分析指令，给出控制信号\nIR(Instruction Register):指令寄存器，存放当前执行的指令\nPC(Program Counter):存放下一跳指令的地址，有自动加1的功能\n```\n\n完成一条指令需要：\n\n从PC取指令放入IR中，CU分析IR中的指令，从而控制其他配件进行指令执行\n\n![image-20240203153331340](计算机组成原理一/image-20240203153331340.png)\n\n[bilibili视频直达](https://www.bilibili.com/video/BV1ps4y1d73V/?p=5&spm_id_from=333.1007.top_right_bar_window_history.content.click&vd_source=10960c964c9089624e6f92b8d20ed3e0)\n\n## 1.3计算机系统的层次结构\n\n![image-20240203155707352](计算机组成原理一/image-20240203155707352.png)\n\n下层是上层的基础，上层是下层的拓展。\n\n\n\n**编译程序：**将高级语言编写的源程序全部语句一次性翻译成机器语言程序，而后直接执行机器语言程序(.exe)，如C/C++，Java\n\n**解释程序：**将源程序的一条语句翻译成对应的机器语言的雨具，并立即执行，紧接着翻译下一句（每次执行都要翻译）如Python、JavaScript、shell\n\n![image-20240203160113764](计算机组成原理一/image-20240203160113764.png)\n\n## 1.4计算机性能指标\n\n### 1.4.1存储器的性能指标\n\n**总容量：**\n\n- 存储单元个数*存储字长 bit\n- 存储单元个数*存储字长/8 Byte\n\nEg：MAR为32位，MDR为8位\n$$\n总容量 = 2^{32}*8=32Gbit=4GB\n$$\nMAR位数反映存储单元的个数，MDR位数反映每个存储单元的大小\n\n### 1.4.2CPU的性能指标\n\n$$\nK=Kilo=千=10^3\\\\\nM=Milion=百万=10^6\\\\\nG=Giga=十亿=10^9\\\\\nT=Tera=万亿=10^{12}\n$$\n\nK、M、G 和 T 在不同上下文中可以表示不同的含义，具体取决于是以 2 的 10 次方（1024 的倍数）还是以 10 的 3 次方（1000 的倍数）为基础。\n\n1. **二进制（以 2 为基础）：**\n\n   - K 表示 2^10，即 1024。\n   - M 表示 2^20，即 1024 * 1024。\n   - G 表示 2^30，即 1024 * 1024 * 1024。\n   - T 表示 2^40，即 1024 * 1024 * 1024 * 1024。\n\n   在计算机领域，通常使用二进制定义存储容量，如硬盘容量、内存大小等。\n\n2. **十进制（以 10 为基础）：**\n\n   - K 表示 10^3，即 1000。\n   - M 表示 10^6，即 1000 * 1000。\n   - G 表示 10^9，即 1000 * 1000 * 1000。\n   - T 表示 10^12，即 1000 * 1000 * 1000 * 1000。\n\n   在一些其他上下文，如国际制度和网络速度，通常使用十进制定义单位，表示文件大小、带宽等。\n\n**(1)CPU主频：**\n\nCPU内数字脉冲信号振荡的频率\n$$\nCPU主频（时钟频率）=1/CPU时钟周期\n$$\n**(2)CPI（Clock cycle Per Instruction）**\n\n执行一条指令所需要的时钟周期（不同的指令CPI不同，甚至相同的指令CPI也会有变化）\n\n<font color=red>执行一条指令的耗时</font>=CPI*CPU时钟周期\n\nEg：某CPU主频为1000Hz，某程序包含100条指令，平均来看指令的CPI=3，则该程序要在该CPU上执行完成需要多久？\n$$\n100*3*(1/1000)=0.3s\n$$\n**(3)IPS  (Instructions Per Second)**\n\n每秒执行多少条指令\n\nIPS = 1/(CPI*时钟周期)= 主频/CPI\n\n**(4)FLOPS (Floating-point Operations Per Second)**\n\n每秒执行多少次浮点运算\n\n### 1.4.3系统整体性能指标\n\n(1)数据通路带宽：数据总线一次能并行传送的位数\n\n(2)吞吐量：系统在单位时间内处理请求的数量\n\n(3)响应时间：指的是用户向计算机发送一个请求到系统对该请求做出响应并获得所需要的结果的等待时间\n\n# 二、数据的表示和运算\n\n## 2.1 进位计数制\n\n$$\n二进制:0,1\\\\\n八进制:0,1,2,3,4,5,6,7\\\\\n十进制:0,1,2,3,4,5,6,7,8,9\\\\\n十六进制:0,1,2,3,4,5,6,7,8,9,A,B,C,D,E,F\\\\\n$$\n\n\n$$\n二进制：101.1->1*2^2+2*2^1+1*2^0+1*2^{-1}=5.5 \\\\\n八进制：5.4->5*8^0+4*8^{-1}=5.5\\\\\n十进制：5.5->5*10^1+5*10^{-1}=5.5\\\\\n十六进制：5.8->5*16^0+8*16^{-1}=5.5\n$$\n类推：r进制计数法\n$$\n(K_nK_{n-1}...K_2K_1K_0K_{-1}K_{-2}...K_{-m})整体的一个数转十进制  \\\\\n=K_n*r^n+K_{n-1}*r^{n-1}+...+K_2*r^2+K_1*r^1+K_0*r_0+K_{-1}*r^{-1}+K_{-2}*r^{-2}+...+K_{-m}*r^{-m}\n$$\n**十进制转换任意进制**\n\n![image-20240203192543394](计算机组成原理一/image-20240203192543394.png)\n\n![image-20240203193019989](计算机组成原理一/image-20240203193019989.png)\n\n[二进快速制转换八进制和十六进制](https://cooc.cqmu.edu.cn/Course/KnowledgePoint/14960.aspx?AspxAutoDetectCookieSupport=1)\n\n```\n真值：人类习惯的数字\n机器数：数字实际存在机器里的形式（正负号需要被“数字化”，0表示正，1表示负）\n\n+15  0 1111\n-8\t 1 1000\n```\n\n## 2.2 BCD码\n\n### 2.2.1 8421码\n\n![image-20240203193932518](计算机组成原理一/image-20240203193932518.png)\n\n每4bit表示一个数字，如12就可以表示为“0001 0010”的形式\n$$\n十进制:5+8=13\\\\\n8421码:0101+1000=1101(不在映射表中)\\\\\n如果不在映射表内，8421中1010~1111没有意义\\\\\n+6(0110)修正即可\\\\\n0101+1000=1101+0110=0001\\quad0011\n$$\n注意：如果在映射表中就无需修正。\n\n### 2.2.2 余3码\n\n余3码：8421码+(0011)\n\n![image-20240203194903126](计算机组成原理一/image-20240203194903126.png)\n\n### 2.2.3 2421码\n\n![image-20240203195017632](计算机组成原理一/image-20240203195017632.png)\n\n前五个数字第一位都为0，后五个数字第一位都为1\n\n## 2.3无符号整数的加减法运算\n\n- ![image-20240205144647536](计算机组成原理一/image-20240205144647536.png)\n\n### 2.3.1无符号整数的加法运算\n\n**计算机硬件：**从最低位开始，按位相加，并往更高位进位\n\n![image-20240205144805187](计算机组成原理一/image-20240205144805187.png)\n\n### 2.3.2无符号整数的减法运算\n\n**计算机硬件：**\"被减数\"不变，\"减数\"全部按位取反，末尾+1，减法变加法（加法电路造价便宜）---数论\n\n![image-20240205145050472](计算机组成原理一/image-20240205145050472.png)\n\n\n\n## 2.4带符号整数(定点整数)在计算机中的应用\n\n带符号整数的表示：原码、补码、反码\n\n（同一个含义，只是编码方式不同，不同的编码方式有不同的优缺点）\n\n![image-20240205181042323](计算机组成原理一/image-20240205181042323.png)\n\n### 2.4.1原码\n\n![image-20240205145757764](计算机组成原理一/image-20240205145757764.png)\n\n符号位\"0\"表示正，\"1\"表示负，剩余的为数值位\n\n若机器字长为**n+1**位，则原码表示范围为\n$$\n-(2^{n}-1)\\leq x \\leq 2^n-1\n$$\n真值0有两种形式，+0和-0, [+0]原=0 0000000，[-0]原=1 0000000\n\n#### 原码的缺点\n\n符号位不能参与运算，需要设计复杂的硬件电路才能处理\n\n![image-20240205150427986](计算机组成原理一/image-20240205150427986.png)\n\n### 2.4.2补码\n\n![image-20240205150537453](计算机组成原理一/image-20240205150537453.png)\n\n补码转反码只需要末位-1即可，但是操作麻烦，所以可以先用补码算出原码，再转反码，以下为方法2：\n\n此为手算快速转换技巧，计算机中并不是这样实现的\n\n![image-20240205151427416](计算机组成原理一/image-20240205151427416.png)\n\n#### 补码的加法运算\n\n计算机硬件从最低位开始，按位相加（符号位参与运算），并往更高位进位\n\n![image-20240205154907313](计算机组成原理一/image-20240205154907313.png)\n\n#### 补码的减法运算\n\n![image-20240205155804452](计算机组成原理一/image-20240205155804452.png)\n\n注意：原码转补码符号位不用按位取反，补码转补码的负要全部位按位取反。\n\n无符号整数和有符号整数的减法都是全部位按位取反末位+1，所以可以用同一套电路\n\n![image-20240205180517867](计算机组成原理一/image-20240205180517867.png)\n\n### 2.4.3移码\n\n补码的基础上将符号位取反。注意：移码用于表示整数\n\n![image-20240205180910511](计算机组成原理一/image-20240205180910511.png)\n\n## 2.5定点小数\n\n<font color=green>定点整数</font>的编码表示：原码、反码、补码、移码\n\n<font color=red>定点小数</font>的编码表示：原码、反码、补码\n\n### 2.5.1定点小数原码、反码、移码\n\n![image-20240205181911503](计算机组成原理一/image-20240205181911503.png)\n\n![image-20240205182022160](计算机组成原理一/image-20240205182022160.png)\n\n![image-20240205184110792](计算机组成原理一/image-20240205184110792.png)\n\n## 2.6奇偶校验码\n\n**奇校验码：**整个校验码（有效信息位和校验位）中“1”的个数为奇数。\n\n**偶校验码：**整个校验码（有效信息位和校验位）中“1”的个数为偶数。\n\n![image-20240205185809301](计算机组成原理一/image-20240205185809301.png)\n\nEg：给出两个编码1001101和1010111\n\n奇校验：<font color=red>1</font>1001101\t\t<font color=red>0</font>1010111\n\n偶校验：<font color=green>0</font>1001101\t\t<font color=green>1</font>1010111\n\n**奇偶校验码的局限性：**如果发生了两个位置的错误，会出现校验不出的情况\n\n**硬件实现偶校验**通过异或（⊕）运算求得校验位\n\n1⊕0⊕0⊕1⊕1⊕0⊕1=0所以第一个编码的偶校验位为0\n\n## 2.7符号拓展\n\n![image-20240205234947265](计算机组成原理一/image-20240205234947265.png)\n\n注意负数反码和补码的拓展！\n\n# 三、电路的实现\n\n## 3.1算术逻辑单元（ALU）--Arithmetic and Logic Unit\n\n![image-20240205191909131](计算机组成原理一/image-20240205191909131.png)\n\n## 3.2门电路：\n\n![img](计算机组成原理一/u=3886467858,546682409&fm=253&fmt=auto&app=138&f=PNG.png)\n\n**<font color=red>运算优先级</font>**：与>或\n\n## 3.3布尔运算定律\n\n![image-20240205205622135](计算机组成原理一/image-20240205205622135.png)\n\n## 3.4一位全加器\n\n如同手算一样，从低位到高位进行加法运算\n\n![image-20240205211137735](计算机组成原理一/image-20240205211137735.png)\n\n### 3.4.1串行加法器\n\n#### 3.4.1.1单串行加法器\n\n只有一个全加器，数据逐位串行送入到加法器中进行计算，进位触发器用来寄存进位信号，以便下一次运算。\n\n如果操作数长位n位，则要进行n次运算，每次产生一位和，并且逐位送回寄存器中，这样效率不高。\n\n![image-20240205211809002](计算机组成原理一/image-20240205211809002.png)\n\n#### 3.4.1.2串行进位的加法器\n\n把n个全加器串接起来，可以进行两个n位数的相加。\n\n![image-20240205212245672](计算机组成原理一/image-20240205212245672.png)\n\n始终依赖于低位的进位信号，运算速度还是比较慢。\n\n### 3.4.2并行加法器\n\n$$\n对于每一位都要进行\\\\C_i=A_iB_i+(A_i⊕B_i)C_{i-1}\\\\S_i=A_i⊕B_i⊕C_{i-1}\n\\\\设G_i=A_iB_i \\quad P_i=A_0⊕B_0\n\\\\则原式=G_i+P_iC_{i-1}\n\\\\\n\\\\\n通过展开可得：\\\\\nC_1=G_1+P_1C_0\\\\\nC_2=G_2+P_2C_1=G_2+P_2G_1+P_2P_1C_0\\\\\nC_3=G_3+P_3C_2=G_3+P_3G_2+P_3P_2G_1+P_3P_2P_1C_0\n\\\\...\n\\\\C_i的值依赖于P、G、C_0，因此可以直接进行并行计算\n\\\\第i项中的P_iC_{i-1}在后续项中均存在，所以可以设计简化一下电路\n$$\n\n![image-20240205220840672](计算机组成原理一/image-20240205220840672.png)\n\n继续展开会导致电路越来越复杂，一般只展开4个(4个FA)形成4位的CLA加法器\n\n![image-20240205222133269](计算机组成原理一/image-20240205222133269.png)\n\n## 3.5补码加减运算器\n\n**基本（手算）方法：**\n\n```\nn bit的补码X+Y：按位相加即可\nn bit的补码X-Y：将补码Y全部按位取反，末位+1，得到[-Y]补，减法变为了加法\n```\n\n![image-20240205224540144](计算机组成原理一/image-20240205224540144.png)\n\nsub=1即采用减法操作，非门对Y进行按位取反，Cin=Sub=1即对Y的末尾+1得到[-Y]补\n\n**此电路同时也适合无符号数的加减法运算**\n\n## 3.6加减溢出判断\n\n$$\n[A+B]_补=A_补+B_补\\\\\n[A-B]_补=A_补+[-B]_补\n$$\n\n只有“正数+正数”才会<font color=red>**上溢**</font>--正+正=负\n\n只有“负数+负数”才会<font color=red>**下溢**</font>--负+负=正\n\n### 3.6.1溢出判断方法一\n\n可以根据上面的规律得到真值表\n\n![image-20240206002645564](计算机组成原理一/image-20240206002645564.png)\n\n$$\nV=A_sB_s\\overline S_s + \\overline A_s\\overline B_sS_s\\\\\nA_s表示第一个数的符号位，B_s表示第二个数的符号位，S_s表示最终结果符号位\n$$\n\n若V=0，表示无溢出；\n\n若V=1，表示有溢出。\n\n### 3.6.2溢出判断方法二\n\n采用符号位进位和最高数值位的进位进行异或⊕运算判断\n\n![image-20240206003024065](计算机组成原理一/image-20240206003024065.png)\n\n![image-20240206002710848](计算机组成原理一/image-20240206002710848.png)\n$$\nV=C_s⊕C_1\n$$\n\n### 3.6.3溢出判断方法三\n\n采用双符号位，正数的符号位为00，负数的符号位为11\n\n![image-20240205233933203](计算机组成原理一/image-20240205233933203.png)\n\n对两个符号位S1S2进行异或运算即可\n\n**<font color=red>拓展：</font>**\n\n1. 双符号位补码又称为模4补码，单符号位补码又称为模2补码\n2. 双符号位实际存储时只存储一个符号位，运算时会复制一个符号位，不会增加存储空间\n\n## 3.7标志位的生成\n\n![image-20240206002729636](计算机组成原理一/image-20240206002729636.png)\n\n<font color=red>**注意：**</font>OF(Overflow Flag)和SF(Sign Flag)只对**有符号数**加减运算有意义，CF(Carry Flag)只对**无符号数**加减运算有意义，ZF(Zero Flag)均有意义。\n\n![image-20240206000841222](计算机组成原理一/image-20240206000841222.png)\n\n## 3.8移位运算\n\n注意：由于原、反、补码的位数有限，因此某些时候移位操作不能精确等效于乘、除法。\n\n### 3.8.1算数移位\n\n**移位：**通过改变各个数值位和小数点的相对位置，改变各个数值位的位权，实现乘除法运算\n$$\nr进制数：K_nK_{n-1}...K_2K_1K_0K_{-1}K_{-2}...K{-n}\n\\\\小数点前移x位相当于÷r^x\n\\\\小数点后移相当于×r^x\n$$\n![image-20240206122447048](计算机组成原理一/image-20240206122447048.png)\n\n#### 3.8.1.1原码的算数移位\n\n符号位保持不变，仅对数值位进行位移。\n\n**右移：**高位补0，低位舍弃。若舍弃的位=0，则相当于÷r，若舍弃的位≠0，则丢失相应的精度\n\n![image-20240206121350996](计算机组成原理一/image-20240206121350996.png)\n\n**左移：**低位补0，高位舍弃。若舍弃的位=0，则相当于×r，若舍弃的位≠0，则会出现错误\n\n![image-20240206121305855](计算机组成原理一/image-20240206121305855.png)\n\n#### 3.8.1.2反码的算数移位\n\n反码<u>**正数**</u>的算数位移与原码的一样，\n\n负数由于反码数值位于原码相反，因此，\n\n**右移：**高位补1，低位舍弃。\n\n**左移：**低位补1，高位舍弃。\n\n#### 3.8.1.3补码的算数移位\n\n补码**<u>正数</u>**的算数移位与原码一样，\n\n**负数**规则如下：\n\n![image-20240206122220103](计算机组成原理一/image-20240206122220103.png)\n\n### 3.8.2逻辑移位\n\n**逻辑右移：**高位补0，低位舍弃\n\n**逻辑左移：**低位补0，高位舍弃。\n\n可以看做是对”无符号数“的算数移位\n\n![image-20240206122743175](计算机组成原理一/image-20240206122743175.png)\n\n### 3.8.3循环移位\n\n普通循环移位：\n\n![3](计算机组成原理一/3.gif)\n\n带进位位的循环移位：\n\n方法相同，只是要考虑进位位CF\n\n![image-20240206123754559](计算机组成原理一/image-20240206123754559.png)\n\n应用：大端和小端存储之间的转换\n\n## 3.9乘除法运算\n\n### 3.9.1原码的乘法运算\n\n**手算：**\n\n![image-20240206125053826](计算机组成原理一/image-20240206125053826.png)\n\n**机器实现：**\n$$\n设机器字长为n+1=5位(含1个符号位)，[x]_原=1.1101，[y]_原=0.1011，采用原码一位乘法求xy\n\\\\符号位单独处理:符号位=x_s⊕y_s\n\\\\数值位取绝对值进行乘法运算:[|x|]_原=0.1101，[|y|]_原=0.1011\n$$\n![image-20240206130607736](计算机组成原理一/image-20240206130607736.png)\n\n到最后一步，要处理符号位，\n\n![image-20240206130754825](计算机组成原理一/image-20240206130754825.png)\n\n小数点隐含在符号位后面，乘数的符号位不用参与真正的运算，只需要与被乘数的符号位进行异或运算\n\n**手算模拟方法：**\n\n![image-20240206131310285](计算机组成原理一/image-20240206131310285.png)\n\n### 3.9.2补码的乘法运算\n\n![image-20240206133738224](计算机组成原理一/image-20240206133738224.png)\n\n![image-20240206133643035](计算机组成原理一/image-20240206133643035.png)\n\n### 3.9.3定点数的除法运算\n\n[王道视频地址](https://www.bilibili.com/video/BV1ps4y1d73V/?p=24&spm_id_from=pageDriver&vd_source=10960c964c9089624e6f92b8d20ed3e0)\n\n#### **3.9.3.1原码除法：恢复余数法**\n\n$$\n设机器字长为5位（1位符号位,n=4），x=0.1011,y=0.1101，求x/y\n\\\\|x|=0.1011,|y|=0.1101,[|y|]_补=0.1101,[-|y|]_补=1.0011\n\\\\符号位单独处理:符号位=x_s⊕y_s\n\\\\数值位取绝对值进行除法计算。\n$$\n\n初始状态：\n\n![image-20240206150210054](计算机组成原理一/image-20240206150210054.png)\n\n计算机会默认**商1**，如果商1出现问题再进行商0，并“恢复余数”。\n\n![image-20240206150630659](计算机组成原理一/image-20240206150630659.png)\n\n此时发现ACC-(除数)得到的结果是一个**负数**，所以ACC是比除数小的，所以应该商0，于是：\n\n更改为商0，并将ACC+(除数)，将结果送回ACC，恢复原本余数\n\n![image-20240206151038661](计算机组成原理一/image-20240206151038661.png)\n\n此时这一位商已经计算完成，通过逻辑左移，末尾置零，计算下一位。\n\n根据机器字长进行计算，直到计算完成，注意，最后一位商的余数为负的话也需要恢复余数并商0\n\n![image-20240206151615123](计算机组成原理一/image-20240206151615123.png)\n\n最终答案的符号位用异或运算得到\n\n**手算模拟：**\n\n![image-20240206152008434](计算机组成原理一/image-20240206152008434.png)\n\n#### 3.9.3.2原码除法：加减交替法（不恢复余数法）\n\n![image-20240206154651802](计算机组成原理一/image-20240206154651802.png)\n\n符号位的确定还是需要异或运算，\n\n在最后一步如果余数为负，需商0，并+[|y|]补得到正确的余数\n\n### 3.9.4补码的除法运算\n\n采用加减交替法，要让符号位参与运算，被除数/余数，除数都采用双符号位\n\n![image-20240206155634184](计算机组成原理一/image-20240206155634184.png)\n\n## 补充：C语言强制类型转换\n\nC语言中定点整数是用“补码”存储的。\n\n\n\n无符号数与有符号数：不改变数据内容，只是改变解释方式\n\n```C\nvoid main(){\n\tshort x=-4321;//short类型占用2个字节\n    unsigned short y = (unsigned short)x;\n}\n```\n\n长整数便短等输，高位截断，保留低位\n\n```c\nvoid main(){\n\tint a=165537,b=-34991;\n\tshort c=(short)a,d=(short)b;\n    //a:0x000286a1 c:0x86a1 真值：-31071\n    //b:0xffff7751 d:0x7751 真值：30545\n}\n```\n\n短整数变长整数，符号拓展\n\n```c\nvoid main(){\n\tshort x=-4321;\n\tint m=x;\n\tunsigned short n=(unsigned short)x;\n\tunsigned int p=n;\n    //x:1110 1111 0001 1111  0xef1f\n    //m:1111 1111 1111 1111 1110 1111 0001 1111 0xffffef1f 真值:-4321\n    //n:1110 1111 0011 1111 0xef1f 真值：61215\n    //p:0000 0000 0000 0000 1110 1111 0001 1111 0x0000ef1f 真值:61215\n}\n```\n\n","tags":["计算机基础"]},{"title":"GoogleColab使用","url":"/2023/08/10/GoogleColab使用/","content":"\n愁，想系统学习CUDA却没显卡用\n\n看到许多免费资源，其中Google的Colab就是个不错的选择，只是需要依靠魔法\n\n## Colab挂载谷歌云盘\n\n在谷歌云盘中自建一个文件夹，空白处右键点击创建colab notebook\n\n![image-20240810173046163](GoogleColab使用/image-20240810173046163.png)\n\n在修改-笔记本设置选项里选择GPU\n\n![image-20240810173130277](GoogleColab使用/image-20240810173130277.png)\n\n在cell里面输入如下代码，进行云盘挂载\n\n```python\nfrom google.colab import drive\ndrive.mount('/content/drive')\n```\n\n期间会出现授权，无脑勾选即可\n\n\n\n## Vscode远程连接Colab\n\n**1.新建脚本文件**`start.sh`\n\n```bash\npip install colab_ssh --upgrade\n```\n\n直接在cell里面输入会出现警告，用脚本运行可以规避\n\n**2.运行脚本**\n\n在cell中输入如下内容，运行即可\n\n```python\n!bash start.sh\nfrom colab_ssh import launch_ssh_cloudflared, init_git_cloudflared\nlaunch_ssh_cloudflared(password=\"password\")　　　　　　# password是后面用于连接远程服务器的密码，自行填入即可\n```\n\n得到如下图\n\n![img](GoogleColab使用/2015591-20231221200626190-1129252360.png)\n\n**3.配置vscode**\n\n首先要去安装一个[cloudflared](https://github.com/cloudflare/cloudflared/releases)\n\n将第一个框内的ssh配置加到电脑本地的ssh配置文件中，用cloudflared的文件路径替换配置中的<PUT_THE_ABSOLUTE_CLOUDFLARE_PATH_HERE> 字段\n\n![image-20240810172536048](GoogleColab使用/image-20240810172536048.png)\n\n**4.连接Colab**\n\n在VSCode界面按`Ctrl + Shift + P`  输入 `Connect to Host`\n\n然后将第三个黑色块的内容输入（该hostname每次执行代码都会变）\n\n提示输入密码即为之前设置的密码\n\n**注意：**重新连接会话都会恢复原始状态，colab端的操作需要重新做一遍\n\n## 防掉线\n\n使用google colab时如果长时间不交互可能会掉线，\n\n打开 开发者选项 的Console，使用如下脚本即可，脚本会不断创建cell\n\n```javascript\nfunction ClickConnect() {\n    console.log(\"Working\");\n    document.querySelector(\"colab-toolbar-button\").click();\n}\nsetInterval(ClickConnect, 60000);\n```\n\n使用完后可以用如下命令停止运行\n\n```javascript\nclearInterval(intervalId) # intervalId换成具体的数字\n```\n\n## Vscode连接kaggle\n\n```\n!pip install jupyter_ssh\n!ssh-keygen -t rsa -b 4096 -f ~/.ssh/id_rsa\n\n```\n\n"},{"title":"申威架构相关知识","url":"/2023/04/07/申威架构相关知识/","content":"\n# 0.补充知识\n\n## CSR 存储方法\n\n![image-20240407161052148](申威架构相关知识/image-20240407161052148.png)\n\n\n\n# 1.架构图\n\n![image-20240407155922026](申威架构相关知识/image-20240407155922026.png)\n\n此处为SW26010众核处理器架构，SW39000为**6个核组**\n\n每一个从核都有一快高速的本地局部存储**LDM**\n\n![image-20240407160402121](申威架构相关知识/image-20240407160402121.png)\n\nSW39000 LDM空间限制为**256 KB**（私有段、共享内存、Cache）\n\n- 私有段不能为0\n- Cache 只能设置为0、32、128 KB（默认配置为32KB）\n- LDM 连续共享段必须为2的幂，大小只能是0，4，8，16，32，128，256KB\n\n主存和从核之间数据通过**DMA**传输，从核之间的数据通过**RMA**传输\n\n","tags":["计算机基础"]},{"title":"CUDA","url":"/2022/02/09/CUDA/","content":"\n**本篇参考：**\n\n- [https://face2ai.com/program-blog](https://face2ai.com/program-blog)\n\n- [https://zhuanlan.zhihu.com/p/34587739](https://zhuanlan.zhihu.com/p/34587739)\n- [https://zhuanlan.zhihu.com/p/53773183](https://zhuanlan.zhihu.com/p/53773183)\n- [https://zhuanlan.zhihu.com/p/97044592](https://zhuanlan.zhihu.com/p/97044592)\n- [https://blog.csdn.net/sunmc1204953974/article/details/51000970](https://blog.csdn.net/sunmc1204953974/article/details/51000970)\n\n学东西要沉住气，”**慢就是稳，稳就是快**“\n\n# 一、前序\n\n## 并行性\n\n程序是一系列指令和数据的集合，因此并行就可以分为**指令并行**和**数据并行**\n\n我们通常更关注数据并行，openmp、pthread很多操作都是为了数据并行\n\n- 指令并行：利用流水线、‌超标量、‌乱序执行等技术，‌使得多条指令可以同时或部分重叠地执行\n- 数据并行：在多个处理单元之间实现的，‌通过将数据划分成若干块，‌并分别映射到不同的处理单元上\n\nCUDA非常适合数据并行\n\n## 异构计算\n\n异构：不同的计算机架构就是异构\n\nx86 CPU+GPU的异构是最常见的\n\n![img](CUDA/1.png)\n\n- ALU：逻辑计算单元，也就是核心，就是我们常说的四核\n- Control：控制单元\n- Cache：缓存\n- DRAM：内存\n\nGPU中一个SM（红色框部分）可以看作是一个完整的多核CPU，只是ALU数量变多了，\n\n因此GPU对数据量大的计算任务适应性更好，对于逻辑复杂的程序**一个SM**是不如**一个CPU**\n\n**注意：**一个GPU是由若干多个SM（*streaming multiprocessor*），可以把SM看成GPU的大核，寄存器register和共享内存shared memory是SM的稀缺资源\n\nCPU和GPU之间通过PCIe总线进行连接（有的采用的是NVLink）\n\n## GPU架构\n\nGPU是围绕SM(流式多处理器)的扩展阵列搭建的，通过复制结构实现硬件并行。\n\n一个SM的具体结构如下：\n\n![img](CUDA/fermi_sm.png)\n\nGPU中每个SM都能支持数百个线程**并发**执行，\n\n当一个核函数被启动的时候，**多个block**会被同时分配给可用的SM上执行。\n\n### 线程束 Wrap\n\nCUDA 采用单指令多线程SIMT架构管理执行线程，\n\n目前基本所有设备的线程束大小都是**32**，所以block大小最好是32的倍数\n\n因为执行的时候可能有多个block会被分配到一个SM，但是在某一时刻只能有一个线程数在运行（**并发！！！！**）线程束中的每个线程执行**同一条指令**\n\n一个线程束里的执行指令是相同的，可以选择不执行但也不能执行其他指令。\n\n线程块Block中的线程可以通过共享内存和寄存器进行数据共享，因此Wrap也一样\n\nCUDA提供了块内同步的方法，但是块与块之间的同步是没办法的\n\n### Fermi 费米架构\n\n第一个完整的GPU架构，最大可支持16个SM，每个SM有32个Core，共512个Core\n\n\n\n![img](CUDA/fermi.png)\n\n\n\n## 补充知识\n\n即是没有GPU，CPU也可以完成计算，只是速度会慢很多，所以把GPU看作是CPU的加速设备（加速卡）\n\nNVIDIA目前的**计算平台**（不是架构）：\n\n- Tegra：嵌入式芯片，功耗低，gpu和cpu芯片在同一块硅片上\n- Geforce：图像用户\n- Quadro：专业绘图，支持高速OpenGL渲染\n- Tesla：用于大规模并行计算\n\n**CUDA平台**不是单单指软件或者硬件，而是建立在Nvidia GPU上的一整套平台，并扩展出多语言支持\n\n# 二、知识总览\n\n![img](CUDA/CUDA_C.png)\n\n# 三、基础\n\n## 3.1 GPU信息获取\n\n### 3.1.1 程序内信息获取\n\n具体参见：[https://blog.csdn.net/weixin_45791458/article/details/136379581](https://blog.csdn.net/weixin_45791458/article/details/136379581)\n\nAPI在更新，最好是查阅最新的官方文档！\n\n### 3.1.2 nvidia-smi\n\n指令可以直接获取当前设备GPU信息，通过添加不同的参数获取不同的信息\n\n```\nroot@dsw-425468-7489bfcb8-jfhdt:/mnt/workspace# nvidia-smi\nSat Aug 10 22:43:58 2024       \n+-----------------------------------------------------------------------------+\n| NVIDIA-SMI 470.82.01    Driver Version: 470.82.01    CUDA Version: 12.1     |\n|-------------------------------+----------------------+----------------------+\n| GPU  Name        Persistence-M| Bus-Id        Disp.A | Volatile Uncorr. ECC |\n| Fan  Temp  Perf  Pwr:Usage/Cap|         Memory-Usage | GPU-Util  Compute M. |\n|                               |                      |               MIG M. |\n|===============================+======================+======================|\n|   0  NVIDIA A10          Off  | 00000000:00:08.0 Off |                    0 |\n|  0%   29C    P8    15W / 150W |      0MiB / 22731MiB |      0%      Default |\n|                               |                      |                  N/A |\n+-------------------------------+----------------------+----------------------+\n                                                                               \n+-----------------------------------------------------------------------------+\n| Processes:                                                                  |\n|  GPU   GI   CI        PID   Type   Process name                  GPU Memory |\n|        ID   ID                                                   Usage      |\n|=============================================================================|\n|  No running processes found                                                 |\n+-----------------------------------------------------------------------------+\n```\n\n最具体的信息可以用如下命令查询\n\n```\nnvidia-smi -q [-i No]\n```\n\n更多用法可以`nvidia-smi -h` 或者 手册查询\n\n## 3.2 第一个程序Hello world\n\n```c++\n#include <stdio.h>\n\n__global__ void print_kernel(){\n    int tid = blockDim.x * blockIdx.x + threadIdx.x;\n    printf(\"Hello CPU from GPU %d\\n\", tid);\n}\n\nint main(){\n    printf(\"Hello GPU from CPU!\\n\");\n    print_kernel<<<1,10>>>();\n    cudaDeviceReset();//同步CPU和GPU\n    return 0;\n}\n```\n\n![image-20240810180059923](CUDA/image-20240810180059923.png)\n\n- `__global__`关键字告诉编译器此函数是在GPU上执行的核函数\n- `print_kernel<<<1,10>>>()`运行核函数\n- `cudaDeviceReset()`这个函数包含有隐式同步，CPU必须等GPU执行完成才接着执行，`cudaDeviceSynchronize()`则是显示同步\n\n### 整个代码结构\n\n1. 分配GPU的内存\n2. 拷贝数据到GPU\n3. 调用核函数执行计算\n4. 将计算完的数据拷贝回主机\n5. 释放内存\n\n## 3.3 内存管理\n\nCUDA提供了一套进行内存管理的API，既可以管理设备端的内存也可以管理主机端的\n\n但是主机端通常还是用传统的标准库进行管理。\n\n| 标准C函数 |  CUDA API  | 说明     |\n| :-------: | :--------: | -------- |\n|  malloc   | cudaMalloc | 分配内存 |\n|  memcpy   | cudaMemcpy | 内存拷贝 |\n|  memset   | cudaMemst  | 数据设置 |\n|   free    |  cudaFree  | 释放内存 |\n\n### 3.2.1 cudaMemcpy\n\n内存数据拷贝的过程是通过总线完成的\n\n```c\ncudaError_t cudaMemcpy(void * dst,const void * src,size_t count,cudaMemcpyKind kind)\n/*\n类型可以分为如下几种：\ncudaMemcpyHostToHost\ncudaMemcpyHostToDevice\ncudaMemcpyDeviceToHost\ncudaMemcpyDeviceToDevice\n*/\n```\n\n如果函数执行成功，则会返回`cudaSuccess` 否则返回 `cudaErrorMemoryAllocation`\n\n```c\nchar* cudaGetErrorString(cudaError_t error)\n```\n\n使用此指令即可把错误代码翻译成详细的信息\n\n### 3.2.2 cudaMalloc\n\n```cpp\ncudaError_t cudaMalloc (void **devPtr, size_t  size ); \n```\n\n第一次遇到我也很好奇，为什么第一个参数是两个星星\n\n```cpp\nfloat *device_data=NULL;\nsize_t size = 1024*sizeof(float);\ncudaMalloc((void**)&device_data, size);\n```\n\n目的是为了将 device 上分配的内存地址通过形参传出来。\n\n### 3.2.3 示例\n\n```c++\n#include <stdio.h>\n#include <cstdlib> // For std::rand and std::srand\n#include <ctime>   // For std::time\n\n__global__ void sub_kernel(double *a, double *b, double *res){\n    int tid = blockDim.x * blockIdx.x + threadIdx.x;\n    res[tid] = a[tid] + b[tid];\n}\n\nint main(){\n    std::srand(std::time(0));\n    const int nElement = 32;\n    printf(\"The Number of Element is %d\\n\", nElement);\n    double *a_host = (double *)malloc(nElement * sizeof(double));\n    double *b_host = (double *)malloc(nElement * sizeof(double));\n    double *res_host = (double *)malloc(nElement * sizeof(double));\n    double *res_from_gpu = (double *)malloc(nElement * sizeof(double));\n    memset(res_host, 0, nElement*sizeof(double));\n    memset(res_from_gpu, 0, nElement*sizeof(double));\n\n    double *a_device, *b_device, *res_device;\n    cudaMalloc((double **)&a_device, nElement*sizeof(double));\n    cudaMalloc((double **)&b_device, nElement*sizeof(double));\n    cudaMalloc((double **)&res_device, nElement*sizeof(double));\n    \n    /*Init a b*/\n    for(int i = 0; i < nElement; i++){\n        a_host[i] = std::rand() % 100;\n        b_host[i] = std::rand() % 100;\n    }\n\n    cudaMemcpy(a_device, a_host, nElement*sizeof(double), cudaMemcpyHostToDevice);\n    cudaMemcpy(b_device, b_host, nElement*sizeof(double), cudaMemcpyHostToDevice);\n    sub_kernel<<<1, 32>>>(a_device, b_device, res_device);\n    \n    for(int i = 0; i < nElement; i++){\n        res_host[i] = a_host[i] + b_host[i];\n    }\n\n    cudaDeviceSynchronize();\n    cudaMemcpy(res_from_gpu, res_device, nElement*sizeof(double), cudaMemcpyDeviceToHost); \n\n    for(int i = 0; i < nElement; i++){\n        printf(\"%lf %lf\\n\", res_host[i], res_from_gpu[i]);\n        if(res_host[i]!=res_from_gpu[i]){\n            printf(\"%d,ERROR!\\n\",i);\n            break;\n        }\n    }\n\n    cudaFree(a_device);\n    cudaFree(b_device);\n    cudaFree(res_device);\n    free(a_host);\n    free(b_host);\n    free(res_from_gpu);\n    free(res_host);\n    return 0;\n}\n```\n\n## 3.4 初识线程\n\n![img](CUDA/4.png)\n\n首先要明白，一个kernel对应一个Grid，一个Grid里面有很多块，每个块又可以包含许多线程\n\n线程块内部线程之间可以实现**同步**和**共享内存**，不同线程块之间是<u>物理隔离</u>的\n\n`gridDim.x`、`gridDim.y`、`gridDim.z`分别表示**Grid**各个维度的大小\n\n`blockDim.x`、`blockDim.y`、`blockDim.z`分别表示**线程块**中各个维度的大小\n\n`blockIdx.x`、`blockIdx.y`、`blockIdx.z`分别表示**当前线程块所处的线程格的坐标位置**\n\n`threadIdx.x`、`threadIdx.y`、`threadIdx.z`分别表示**当前线程所处的线程块的坐标位置**\n\n```cpp\ndim3 grid(1,1,1);\ndim3 block(1,1,1);\nkernel<<<grid, block>>>();\n```\n\n**注意：一个块里的线程最大为<u>1024</u>**，grid的维度（block的块数）很大，暂时可以不考虑\n\n一维二维示意图如下，三维可自行推\n\n![img](CUDA/1-1723297430375-3.png)\n\n------\n\n![img](CUDA/cuda_thread.png)\n\n所有CUDA核函数的启动都是异步的。\n\n## 3.5 核函数\n\n- `__global__`：设备端运行，全局（主机端、设备端）都可以调用，**返回类型必须是void**\n- `__device__`：设备端运行\n- `__host__`：忽略，不加关键词默认即这个\n\n有一个特殊情况，就是`__device__`和`__host__`同时存在，这样的话CPU和GPU就可以都进行调用，也可以存在返回值\n\n底层实现是编译器编译出了两份功能相同，调用对象不同的代码\n\n```cpp\n#include <stdio.h>\n__device__ __host__ int func(int a, int b){\n    return a + b;\n}\n__global__ void kernel(){\n    printf(\"GPU:%d\\n\",func(1,1));\n}\nint main(){\n\n    printf(\"CPU:%d\\n\",func(1,1));\n    dim3 grid(1,1,1);\n    dim3 block(1,1,1);\n    kernel<<<grid,block>>>();\n    cudaDeviceSynchronize();\n    return 0;\n}\n```\n\nKernel核函数编写有以下限制\n\n1. 只能访问设备内存\n2. 必须有void返回类型\n3. 不支持可变数量的参数\n4. **不支持静态变量**\n5. 显示异步行为\n\n## 3.6 错误处理\n\n```cpp\n#define CHECK(call)\\\n{\\\n  const cudaError_t error=call;\\\n  if(error!=cudaSuccess)\\\n  {\\\n      printf(\"ERROR: %s:%d,\",__FILE__,__LINE__);\\\n      printf(\"code:%d,reason:%s\\n\",error,cudaGetErrorString(error));\\\n      exit(1);\\\n  }\\\n}\n```\n\n通过这个宏定义就可以进行检查错误\n\n```CPP\n CHECK(cudaMalloc((float**)&a_d,nByte));\n```\n\n## 3.7 计时\n\n### 3.7.1 CPU计时法\n\n```cpp\n#include <sys/time.h>\ndouble cpuSecond()\n{\n  struct timeval tp;\n  gettimeofday(&tp,NULL);\n  return ((double)tp.tv_sec + (double)tp.tv_usec*1e-6);\n}\n```\n\n使用这个方法计算得出的时间比GPU计算运行的时间要长\n\n原因：\n\n- 主机调用核函数需要时间\n- 主机同步函数需要时间\n\n### 3.7.2 nvprof\n\nnvprof是分析工具，可以很直观的计算出整个过程时间\n\n```bash\nnvprof [args] <application>\n```\n\n![image-20240811115225538](CUDA/image-20240811115225538.png)\n\n可能会出现如下内容\n\n```\n======== Warning: nvprof is not supported on devices with compute capability 8.0 and higher.\n                  Use NVIDIA Nsight Systems for GPU tracing and CPU sampling and NVIDIA Nsight Compute for GPU profiling.\n                  Refer https://developer.nvidia.com/tools-overview for more details.\n```\n\n其实就是说nvprof工具太老了，让使用`NVIDIA Nsight Systems`\n\n具体参见：[https://zhuanlan.zhihu.com/p/666242337](https://zhuanlan.zhihu.com/p/666242337)\n\n\n\n","tags":["超算"]},{"title":"教务系统选课脚本(正方-urp)","url":"/2022/02/05/教务系统选课脚本正方-urp/","content":"\n共三个脚本，一个urp、一个正方教务、一个西南石油大学新版教务，代码都大同小异\n\n# urp教务系统\n\n第一次写爬虫相关的东西，也是第一次写UI界面，过于潦草，但功能没问题，使用tkinter实现的UI界面\n\n```python\nimport time\nimport tkinter.messagebox as messagebox\nimport tkinter as tk\nimport random\nimport winsound\nimport requests\nfrom PIL import Image, ImageTk\nimport threading\nimport os\nfrom lxml import etree\n\nheaders = {\n        'Content-Type': 'application/x-www-form-urlencoded',\n        'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:104.0) Gecko/20100101 Firefox/104.0',\n    }\ncookies = {}\nurp_url = '1'\nthread_class_flag = True #选课线程标志\nclass_inf = '2'\nclass LoginWindow:\n    def __init__(self):\n        self.window = tk.Tk()\n        self.window.title(\"登录\")\n        self.window.geometry(\"300x200\")\n        self.window.resizable(0,0)\n        self.window.iconbitmap('ic.ico')\n        start_url = set_urp_url()\n        self.username_label = tk.Label(self.window, text=\"当前登录网址：\" + urp_url)\n        self.username_label.place(x=30, y=0)\n        # 用户名输入框\n        self.username_label = tk.Label(self.window, text=\"用户名：\")\n        self.username_label.place(x=50, y=30)\n        self.username_entry = tk.Entry(self.window, width=20)\n        self.username_entry.place(x=110, y=30)\n\n        # 密码输入框\n        self.password_label = tk.Label(self.window, text=\"密码：\")\n        self.password_label.place(x=50, y=70)\n        self.password_entry = tk.Entry(self.window, width=20)\n        self.password_entry.place(x=110, y=70)\n\n        # 验证码输入框\n        self.verify_label = tk.Label(self.window, text=\"验证码：\")\n        self.verify_label.place(x=50, y=110)\n        self.verify_entry = tk.Entry(self.window, width=10)\n        self.verify_entry.place(x=110, y=110)\n\n        def on_enter(event):\n            event.widget.tk_focusNext().focus()\n        def on_enter_code(event):\n            self.login()\n        #绑定事件，回车换输入框\n        self.username_entry.bind(\"<Return>\",on_enter)\n        self.password_entry.bind(\"<Return>\",on_enter)\n        self.verify_entry.bind(\"<Return>\",on_enter_code)\n        # 验证码图片\n        def refresh_code():\n            start_url.getcode()\n            self.verify_image = Image.open(\"code.png\")\n            self.verify_image = ImageTk.PhotoImage(self.verify_image)\n            self.verify_button.config(image=self.verify_image)\n        start_url.getcode()\n        self.verify_image = Image.open(\"code.png\")\n        self.verify_image = ImageTk.PhotoImage(self.verify_image)\n        self.verify_button = tk.Button(self.window, command=refresh_code)\n        self.verify_button.config(image=self.verify_image)\n        self.verify_button.place(x=190, y=110)\n\n        # 登录按钮\n        self.login_button = tk.Button(self.window, width=10, text=\"登录\", command=self.login)\n        self.login_button.place(x=120, y=150)\n\n        try:\n            with open(\"user.txt\", \"r\") as file:\n                lines = file.readlines()\n                if len(lines) >= 1:\n                    self.username_entry.insert(0, lines[0].strip())  # 填充第一个输入框\n                if len(lines) >= 2:\n                    self.password_entry.insert(0, lines[1].strip())  # 填充第二个输入框\n        except FileNotFoundError:\n            print(\"找不到user.txt文件\")\n        self.window.mainloop()\n\n    def login(self):\n        url = urp_url + '/loginAction.do'\n        print(url)\n        while True:\n            data = {\n                'zjh1': '',\n                'tips': '',\n                'lx': '',\n                'evalue': '',\n                'eflag': '',\n                'fs': '',\n                'dzslh': '',\n                'zjh': self.username_entry.get(),\n                'mm': self.password_entry.get(),\n                'v_yzm': self.verify_entry.get(),\n            }\n\n            print(\"用户名：\", data[\"zjh\"])\n            print(\"密码：\", data['mm'])\n            print(\"验证码：\", data['v_yzm'])\n            try:\n                response = requests.session().post(url=url, headers=headers, cookies=cookies, data=data, timeout=90).text\n                tree = etree.HTML(response)\n                login_staut = tree.xpath('//head/title/text()')[0]\n                print(login_staut)\n                if login_staut != '学分制综合教务':\n                    login_staut = tree.xpath('//td[@class=\"errorTop\"]/strong/font/text()')[0]\n                    print(login_staut)\n                    messagebox.showinfo('错误',login_staut)\n                    raise Exception\n                break\n            except:\n                return\n        while True:\n            try:\n                requests.get(urp_url + '/xkAction.do', headers=headers, cookies=cookies, timeout=90)\n                break\n            except:\n                return\n        self.window.destroy()\n\n        # 打开\"user.txt\"文件以写入模式\n        with open(\"user.txt\", \"w\") as file:\n            file.write(data['zjh'] + \"\\n\")\n            file.write(data['mm'] + \"\\n\")\n        print(\"已将文本写入user.txt文件。\")\n        menu(data['zjh'])\n\nclass menu:\n    def __init__(self,user):\n        root = tk.Tk()\n        root.title(\"当前用户：\"+user)\n        root.geometry(\"400x300\")  # 设置窗口大小\n        root.resizable(0, 0)\n        root.iconbitmap('ic.ico')\n        # 添加标题\n        lbl_title = tk.Label(root, text=\"urp TOOL\", font=(\"Arial\", 20))\n        lbl_title.pack(pady=10)\n\n        # 添加按钮\n        def class_table():\n            url = urp_url + '/xkAction.do?actionType=6'\n            response = requests.get(url, headers=headers, cookies=cookies)\n            with open(\"cx.html\", 'wb') as fp:\n                fp.write(response.content)\n            os.system('cx.html')\n        btn_query = tk.Button(root, text=\"查询课表\", width=15, height=2,command=class_table)\n        btn_query.pack(pady=5)\n\n        def select_class():\n            root.withdraw()\n            class_window = tk.Toplevel(root)\n            class_window.title(\"选课:\"+user)\n            class_window.geometry(\"355x460\")\n            class_window.resizable(0, 0)\n            class_window.iconbitmap(\"ic.ico\")\n            def closing():\n                root.deiconify()\n                class_window.destroy()\n            class_window.protocol('WM_DELETE_WINDOW',closing)\n            label1 = tk.Label(class_window,text = \"课程号\")\n            label1.grid(row=0,column=0)\n            entry1 = tk.Entry(class_window)\n            entry1.grid(row=0,column=1)\n            label1 = tk.Label(class_window, text=\"课序号\")\n            label1.grid(row=1, column=0)\n            entry2 = tk.Entry(class_window)\n            entry2.grid(row=1, column=1)\n            def add_class():\n                input1 = entry1.get()\n                input2 = entry2.get()\n                if not (input1 == '' and input2==''):\n                    classbox.insert(tk.END, f\"{input1},{input2}\")\n            def delete_selected_class():\n                selected_class = classbox.curselection()\n                if selected_class:\n                    classbox.delete(selected_class)\n            button1 = tk.Button(class_window,text='添加课程',command=add_class)\n            button1.grid(row=0,column=2)\n            button2 = tk.Button(class_window, text='删除课程', command=delete_selected_class)\n            button2.grid(row=1, column=2)\n            classbox = tk.Listbox(class_window,width=50, height=5)\n            classbox.grid(row=2,column=0,columnspan=3)\n            try:\n                for line in open('kc.txt', 'r'):\n                    line = line.rstrip('\\n').split(\" \")\n                    classbox.insert(tk.END,f\"{line[0]},{line[1]}\")\n            except:\n                messagebox.showinfo(\"WARING\",\"检测到缺少课程文件，可手动添加课程\")\n                class_window.quit()\n\n            def selectthread():\n                len_class = classbox.size()\n                i = 0\n                global thread_class_flag\n                while len_class !=0 and thread_class_flag:\n                    i = i % len_class\n                    kcid = classbox.get(i).split(',')[0]\n                    kcnum = classbox.get(i).split(',')[1]\n                    print(kcid,kcnum)\n                    url = urp_url + '/xkAction.do'\n                    da = {}\n                    if class_inf == '5':\n                        da = {\n                            'kch': kcid,\n                            'cxkxh': kcnum,\n                            'kcm': \"\",\n                            'skjs': \"\",\n                            'kkxsjc': \"\",\n                            'skxq': \"\",\n                            'skjc': \"\",\n                            'pageNumber': \"-2\",\n                            'preActionType': \"3\",\n                            'actionType': \"5\",\n                        }\n                    elif class_inf == '2':\n                        da = {\n                            \"jhxn\": \"\",\n                            \"kcsxdm\": \"\",\n                            \"kch\": kcid,\n                            \"cxkxh\": kcnum,\n                            \"actionType\": \"2\",\n                            \"oper2\": \"gl\",\n                            \"pageNumber\": \"-1\"\n                        }\n                    while True:\n                        try:\n                            st = time.time()\n                            re = requests.post(urp_url + '/xkAction.do', headers=headers, cookies=cookies, data=da, timeout=90)\n                            cost_time = time.time()-st\n                            urp_label.config(text=urp_url+\" \"+f\"延时: {cost_time:.3f} 秒\",fg=\"blue\")\n                            break\n                        except:\n                            return\n\n                    data = {\n                        'kcId': kcid + '_' + kcnum,\n                        'preActionType': class_inf,\n                        'actionType': '9',\n                    }\n                    while True:\n                        try:\n                            st = time.time()\n                            response = requests.post(url, headers=headers, cookies=cookies, data=data, timeout=90).text\n                            cost_time = time.time() - st\n                            urp_label.config(text=urp_url + \" \" + f\"延时: {cost_time:.3f} 秒\", fg=\"blue\")\n                            break\n                        except:\n                            return\n\n                    try:\n                        tree = etree.HTML(response)\n                        ret = tree.xpath('//strong/font/text()')\n                        status_box.insert(tk.END, str(i+1)+\":\"+ret[0])\n                        status_box.yview_moveto(1.0)\n                        class_window.update()\n                        if \"时间冲突\" in ret[0] or \"成功\" in ret[0] or \"已经选择\" in ret[0]:\n                            print(ret[0])\n                            classbox.delete(i)\n                            len_class -= 1\n                            if \"成功\" in ret[0]:\n                                try:\n                                    winsound.PlaySound(\"succeed.wav\", winsound.SND_ASYNC)\n                                except:\n                                    print(\"找不到音频\")\n\n                    except:\n                        print(\"暂无课程信息，请稍后重试\")\n                        status_box.insert(tk.END, str(i+1)+\":\"+\"暂无课程信息，请稍后重试\")\n                        status_box.yview_moveto(1.0)\n                        class_window.update()\n                    i += 1\n                    if delay_slider.get()!=0:\n                        delay_time = delay_slider.get()+random.uniform(0, 2)-random.uniform(0,1.5)\n                        delay_time = max(0,delay_time)\n                        print(\"延迟:\",round(delay_time,2),\"s\")\n                        status_box.insert(tk.END, \"延迟：\"+str(delay_time)+\"s\")\n                        status_box.yview_moveto(1.0)\n                        class_window.update()\n                        time.sleep(delay_time)\n\n                if len_class==0:\n                    button4.config(text=\"开始选课\")\n                    urp_label.config(text=urp_url, fg='black')\n                    status_box.insert(tk.END,\"************选课任务完成************\")\n                if not thread_class_flag:\n                    status_box.insert(tk.END, \"选课已暂停，等待服务器响应...\")\n                    status_box.see(tk.END)\n                    button4.config(state=tk.NORMAL)\n                    urp_label.config(text=urp_url,fg='black')\n\n            def Thread_class():\n                global thread_class_flag\n                thread = threading.Thread(target=selectthread)\n                if button4.cget(\"text\") == \"开始选课\":\n                    thread_class_flag = True\n                    status_box.insert(tk.END,\"开始选课，等待服务器响应...\")\n                    status_box.see(tk.END)\n                    button4.config(text=\"暂停选课\")\n                    thread.start()\n                else:\n                    button4.config(text=\"开始选课\",state=tk.DISABLED)\n                    thread_class_flag = False\n\n            button4 = tk.Button(class_window, width=12,text='开始选课',command=Thread_class)\n            button4.grid(row=4, column=1, columnspan=2)\n\n            delay_slider = tk.Scale(class_window, from_=0.0, to=5.0, resolution=0.01, orient=\"horizontal\", length=200)\n            delay_slider.grid(row=5,column=0,columnspan=3)\n            def change_class():\n                global class_inf\n                if class_inf == '2':\n                    class_inf = '5'\n                    class_label.config(text='课程属性：自由选择')\n                elif class_inf == '5':\n                    class_inf='2'\n                    class_label.config(text='课程属性：方案课程')\n            button5 = tk.Button(class_window, width=10, text='切换属性', command=change_class)\n            button5.grid(row=4, column=0, columnspan=2)\n\n            status_box = tk.Listbox(class_window, width=50)\n            status_box.grid(row=3, column=0, columnspan=3)\n\n            class_label = tk.Label(class_window, text=\"课程属性：方案课程\" )\n            class_label.grid(row=6, column=1)\n            urp_label = tk.Label(class_window, text=urp_url)\n            urp_label.grid(row=7,column=0,columnspan=3)\n\n        btn_quick_select = tk.Button(root, text=\"快速选课\", width=15, height=2,command=select_class)\n        btn_quick_select.pack(pady=5)\n\n        def jxpg():\n            print(\"\\n正在读取教学评估界面\\n\")\n            resp = requests.get(url=urp_url + \"/jxpgXsAction.do?oper=listWj\", headers=headers, cookies=cookies)\n            tree = etree.HTML(resp.text)\n            list = tree.xpath('//body/form/table/tr/td/table/tr/td/img[@title=\"评估\"]/@name')\n            if len(list)==0:\n                messagebox.showinfo(\"提醒\",\"当前可评估数目为0，正在返回菜单\")\n            else:\n                new_window = tk.Toplevel(root)\n                new_window.title(\"评教\")\n                new_window.geometry(\"400x500\")\n                new_window.resizable(0, 0)\n                risk_box = tk.Listbox(new_window, width=50)\n                risk_box.pack()\n                status_box = tk.Listbox(new_window, width=50)\n                status_box.pack()\n                for i in list:\n                    j=i.split(\"#@\")\n                    risk_box.insert(tk.END,\"教师姓名：\"+j[2]+\"    课程名：\"+j[4])\n                # print(list)\n                print(\"共 \", len(list), \" 个评估任务\")\n                risk_count = tk.Label(new_window, text=\"共 \"+ str(len(list))+ \" 个评估任务\")\n                risk_count.pack(pady=10)\n\n                def start_jxpg():\n                    for item in list:\n                        info = item.split('#@')\n                        print(info)\n                        data_flag = {\n                            'wjbm': info[0],\n                            'bpr': info[1],\n                            'pgnr': info[5],\n                            'oper': 'wjShow',\n                            \"wjbz\": \"null\",\n                            \"pageSize\": \"20\",\n                            \"page\": \"1\",\n                            \"currentPage\": \"1\",\n                            \"pageNo\": \"\",\n                        }\n                        data = {\n                            \"wjbm\": info[0],\n                            \"bpr\": info[1],\n                            \"pgnr\": info[5],\n                            \"xumanyzg\": 'zg',\n                            \"wjbz\": \"\",\n                            \"0000000257\": \"40_0.96\",\n                            \"0000000258\": \"12_0.96\",\n                            \"0000000259\": \"10_0.96\",\n                            \"0000000260\": \"8_0.96\",\n                            \"0000000261\": \"8_0.96\",\n                            \"0000000262\": \"5_0.96\",\n                            \"0000000263\": \"5_0.96\",\n                            \"0000000264\": \"4_0.96\",\n                            \"0000000265\": \"4_0.96\",\n                            \"0000000266\": \"4_0.96\",\n                            \"0000000271\": \"0_0.96\",\n                            \"0000000272\": \"0_0.2\",\n                            \"0000000273\": \"0_0.96\",\n                            \"zgpj\": \"好\"\n                        }\n                        requests.post(urp_url + '/jxpgXsAction.do', cookies=cookies, data=data_flag)\n                        res = requests.post(url=urp_url + \"/jxpgXsAction.do?oper=wjpg\", cookies=cookies, data=data)\n                        tree = etree.HTML(res.text)\n                        status = tree.xpath('//script/text()')[0].split('\"')[1]\n                        status_box.insert(tk.END,status)\n                btn_query = tk.Button(new_window, text=\"开始评估\", width=15, height=2, command=start_jxpg)\n                btn_query.pack(pady=5)\n        btn_eval = tk.Button(root, text=\"一键评教\", width=15, height=2,command=jxpg)\n        btn_eval.pack(pady=5)\n\n#退课\n        def cancel_class():\n            root.withdraw()\n            cancle_window = tk.Toplevel(root)\n            cancle_window.title(\"退课\")\n            cancle_window.geometry(\"355x260\")\n            cancle_window.resizable(0, 0)\n            cancle_window.iconbitmap(\"ic.ico\")\n            def closing():\n                root.deiconify()\n                cancle_window.destroy()\n            cancle_window.protocol('WM_DELETE_WINDOW', closing)\n            lable1 = tk.Label(cancle_window,text=\"请选择所需退课课程\")\n            lable1.grid(row=0,column=1,columnspan=3)\n            cancle_box = tk.Listbox(cancle_window,width=50,height=10)\n            cancle_box.grid(row=1,column=1,columnspan=3)\n            def class_input_thread():\n                cancle_response = requests.get(url=urp_url+\"/xkAction.do?actionType=6\",cookies=cookies,headers=headers)\n                tree = etree.HTML(cancle_response.text)\n                cancle_list = tree.xpath('//table/tr[count(td) > 15]/td[position()=2 or position()=3 or position()=4 or position()=8]/text()')\n                for row in range(0,len(cancle_list),4):\n                    cancle_box.insert(tk.END,cancle_list[row][4:]+\",\"+cancle_list[row+1][4:]+\",\"+cancle_list[row+2][4:]+\",\"+cancle_list[row+3][4:])\n            def thread_class():\n                thread = threading.Thread(target=class_input_thread)\n                thread.start()\n            def ACK_cancle():\n                select_box_index = cancle_box.curselection()\n                if select_box_index:\n                    ACK_class = cancle_box.get(select_box_index[0]).split(',')\n                    requests.get(url=urp_url+\"/xkAction.do?actionType=10&kcId=\"+ACK_class[0],cookies=cookies,headers=headers)\n                    messagebox.showinfo(\"完成\",message=\"请按确认校验退课结果\")\n                    cancle_box.delete(0,\"end\")\n                    thread_class()\n                else:\n                    messagebox.showwarning(\"警告\",\"请先选定课程\")\n            thread_class()\n            cancle_button = tk.Button(cancle_window,text=\"确认退课\",command=ACK_cancle)\n            cancle_button.grid(row=2,column=1,columnspan=3)\n        btn_drop = tk.Button(root, text=\"退课\", width=15, height=2,command=cancel_class)\n        btn_drop.pack(pady=5)\n\n        root.mainloop()\n\n\nclass set_urp_url:\n    urp_url_list = [\"http://10.28.63.116:8081\",\n                    \"http://10.28.63.111:9001\",\n                    \"http://10.28.63.111:9002\",\n                    ]\n    URL_flag = True\n\n    def __init__(self):\n        url_count = len(self.urp_url_list)\n\n        def xzURLthread(i):\n            try:\n                response = requests.get(self.urp_url_list[int(i)], timeout=90)\n            except:\n                return\n            if not self.URL_flag:\n                return\n            global urp_url\n            global cookies\n            urp_url = self.urp_url_list[int(i)]\n            cookies = response.cookies.get_dict()\n            self.URL_flag = False\n\n            lock_url.set()\n\n        threads = []\n        lock_url = threading.Event()\n        for i in range(0, url_count):\n            t = threading.Thread(target=xzURLthread, args=[i])\n            threads.append(t)\n        for thread in threads:\n            thread.start()\n        lock_url.wait()\n        print(urp_url)\n\n    def getcode(self):\n        code_url = urp_url + '/validateCodeAction.do?random=0.5925328096959378'\n        mysession = requests.session()\n        response = mysession.get(code_url, headers=headers, cookies=cookies)\n        content = response.content\n        with open('code.png', 'wb') as fp:\n            fp.write(content)\n\n\nif __name__=='__main__':\n    try:\n                LoginWindow()\n    except:\n        messagebox.showinfo('Error','发生了未知错误，请检测网络是否连接')\n```\n\n# 正方教务\n\n这是做来帮人抢课的,没有进一步完善\n\n```python\nimport threading\nimport requests\nimport os\nfrom lxml import etree\nclass_dict = []\ndef search_class(name,id,header,header_oi,class_name,numb):\n    response = requests.get(url='http://112.45.152.8:30008/xf_xsqxxxk.aspx?xh='+id+'&xm='+name+'&gnmkdm=N121203',headers=header)\n    value = searchcode(response)\n    data = {\n        '__EVENTTARGET': '',\n        '__EVENTARGUMENT': '',\n        '__LASTFOCUS': '',\n        '__VIEWSTATE': value,\n        '__VIEWSTATEGENERATOR': '4E92E216',\n        'ddl_kcxz': '',\n        'ddl_ywyl': '无',\n        'ddl_kcgs': '',\n        'ddl_sksj': '',\n        'ddl_xqbs': '1',\n        'TextBox1': class_name,\n        'Button2': '确定',\n        'dpkcmcGrid$txtChoosePage': '1',\n        'dpkcmcGrid$txtPageSize': '150',\n    }\n    res = requests.post(url='http://112.45.152.8:30008/xf_xsqxxxk.aspx?xh=' + id + '&xm=' + name + '&gnmkdm=N121203', data=data, headers=header_oi)\n    data['__VIEWSTATE'] = searchcode(res)\n    data['kcmcGrid$ctl02$xk'] = 'on'\n    data['kcmcGrid$ctl02$jc'] = 'on'\n    data['Button1'] = ['++提+交++']\n    del data['Button2']\n    res = requests.post(url='http://112.45.152.8:30008/xf_xsqxxxk.aspx?xh=' + id + '&xm=' + name + '&gnmkdm=N121203', data=data, headers=header_oi)\n    # print(res.text)\n    if res.status_code == 200:\n        print(res.status_code)\n        with open(\"cx\"+numb+\".html\", 'wb') as fp:\n            fp.write(res.content)\n        os.system(\"cx\"+numb+\".html\")\n        del class_dict[int(numb)]\n    return\n\ndef searchcode(response):\n    try:\n        tree = etree.HTML(response.text)\n        return tree.xpath('//input[@id=\"__VIEWSTATE\"]/@value')[0]\n    except:\n        print(\"请检查cookie是否正确！！！\")\n        exit()\n\n\ndef menu(name,id,cookie):\n    header ={\n        'Host': '112.45.152.8:30008',\n        'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:109.0) Gecko/20100101 Firefox/110.0',\n        'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,*/*;q=0.8',\n        'Accept-Language': 'zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2',\n        'Accept-Encoding': 'gzip, deflate',\n        'Connection': 'keep-alive',\n        'Referer': 'http://112.45.152.8:30008/xs_main.aspx?xh='+id,\n        'Cookie': cookie,\n        'Upgrade-Insecure-Requests': '1',\n    }\n    nm = 'http://112.45.152.8:30008/xf_xsqxxxk.aspx?xh=' + id + '&xm=' + name + '&gnmkdm=N121203'\n    nm = nm.encode('utf-8')\n    header_oi ={\n        'Host': '112.45.152.8:30008',\n        'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv: 109.0) Gecko/20100101 Firefox/110.0',\n        'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,*/*;q=0.8',\n        'Accept-Language': 'zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2',\n        'Accept-Encoding': 'gzip, deflate',\n        'Content-Type': 'application/x-www-form-urlencoded',\n        'Content-Length': '47574',\n        'Origin': 'http://112.45.152.8:30008',\n        'Connection': 'keep-alive',\n        'Referer': nm,\n        'Cookie': cookie,\n        'Upgrade-Insecure-Requests': '1',\n    }\n    while True:\n        class_dict.clear()\n        a = 0\n        for line in open('kc.txt', 'r', encoding='utf-8'):\n            line = line.rstrip('\\n')\n            class_dict.append(line)\n            a += 1\n        print(\"共\", a, \"科\\n\", class_dict)\n        p = input(\"\\n请输入所需功能：\\n1:选取\\n\")\n        if p == \"1\" : select(name,id,header,header_oi)\n\n\ndef select(name,id,header,header_oi):\n    i = 0\n    while len(class_dict) != 0:\n        class_thread = []\n        print(len(class_dict))\n        for item in class_dict:\n            class_thread.append(threading.Thread(target=search_class,args=(name,id,header,header_oi,item,str(i))))\n            i+=1\n        for thread in class_thread:\n            thread.start()\n        for thread in class_thread:\n            thread.join()\n    return\n\nif __name__=='__main__':\n    name = input(\"请输入姓名：\")\n    id = input(\"请输入学号：\")\n    cookie = input(\"请输入cookie：\")\n    menu(name,id,cookie)\n\n```\n\n# 新版教务系统\n\n暂时只实现了选课功能，\n\n![image-20240205200345870](教务系统选课脚本正方-urp/image-20240205200345870-1707136055615-1.png)\n\n由于教务还在使用，暂时不进行开源，思路和上述两个都大同小异，有兴趣的uu可以自行尝试一下。\n","tags":["爬虫"]},{"title":"问海一号SACA随记","url":"/2022/02/05/问海一号SACA随记/","content":"\n**主核存储系统：**\n\n- 一级指令Cache 32KB\n- 一级数据Cache 32KB\n- 二级Cache 512KB\n\n**从核存储系统：**\n\n- 一个指令Cache 32KB\n- 每个从核有256KB数据存储空间（LDM）\n\n![img](问海一号SACA随记/1685787598459-32ce2b53-4270-4d08-8615-840b5f1603ac.png)\n\n从核私有变量：`_thread int a[100];`\n\n\n\n```cpp\n混合静态编译及链接\nswgcc -mhost master.c\nswgcc -mslave slave.c\nswgcc -mhybrid master.o slave.o -o a.out\n\n混合动态编译及链接\nswgcc -mhost -FPIC -c master.c\nswgcc -mslave -FPIC -c slave.c\nswgcc -mdynamic -shared master.o slave.o -o libmix.so\n\nmpi编译\nmpicc -mhost mater.c\nmpicc -mslave slave.c\nmpicc -mhybrid master.o slave.o -o a.out\n-mhost\t编译主核代码\n-mslave\t编译从核代码\n-mhybrid/-mdynamic\t静态/动态链接\n-msimd\tSIMD扩展编程接口\t（建议从核加）\n-mieee\t允许使用精确结果的任何操作\t（主核必加）\n-faddress_align=n\t所有数组、向量、结构体按照首地址 nB对齐\t主核（n=32）从核（n=64）\n-mftz\t发生下溢时，将真零写入目标寄存器 （建议主核加）\n-O[0/1/2/3/s]\t优化级别\n-lm -lm_slave\t提供高性能快速数据库链接\t（主核-lm，从核-lm_slave）\n-g\t方便gdb调试\n-mfma\t对乘加操作合成一条操作，建议增加\n```\n\n**说明：**\n\n-faddress_align=64内存对齐，加了这个编译选项后，\n\n就无需在定义数组时候加`__attribute__ ((aligned(64)))`\n\n**例如：**\n\n```\nint arr[16] __attribute__ ((aligned (64)))= {1,2,3,4,5,6,7,8,10,11,12,13,14,15}; \n```\n\n\n\nSIMD数据向量化支持512位\n\n```cpp\nCRTS_init();\n//从核线程初始化\nathread_spawn();\n//从核线程启动\nathread_join();\n//从核线程回收\nathread_halt();\n//从核线程终止\nCRTS_tid\t--从核号（0-63）\nCRTS_rid\t--从核所在行（0-7）\nCRTS_cid\t--从核所在列（0-7）\nCRTS_cgn\t--从核所在核组号（0-5）\nCRTS_spc_tid\t--从核簇方式的逻辑从核号（0-63）\nCRTS_spcn\t--从核簇号（0-16）\n\nCRTS_dma_iget(void *dst, void *src, int len, crts_rply_t *rply);\n//dst从核内的地址,src共享内存的地址,len=i*sizeof(int)\nCRTS_dma_iget_stride(void *dst, void *src, int len, int bsize, int stride, crts_rply_t *rply);\n//主存跨步读取，跨步大小为stride(4B的整数倍)即两个向量块之间的空隙，bsize为跨步向量块的大小\n\nCRTS_dma_wait_value(crts_rply_t *rply, int value);\n//当rply的值大于等于value时，代表操作已经完成\n    \nCRTS_dma_iput(void *dst, void *src, int len, crts_rply_t *rply);\n//dst为主存的地址，src为局存地址\nCRTS_dma_input_stride(void *dst, void *src, int len, int bsize, int stride, crts_rply_t *rply);\n//跨步\n```\n\n## 编译\n\n![img](问海一号SACA随记/1685699879442-3e5a6739-2f07-48fa-b74f-7a07ddf8b225.png)\n\n```cpp\nsw9gcc -mhost -c main.c\n\nsw9gcc -mslave -c slave.c\n\nsw9gcc -mhybrid main.o slave.o -o a.out\n```\n\n## 作业提交\n\n```\nbsub -I -q q_sw_expr -b -n 1 -cgsp 64 -host_stack 1024 -share_size 6000 test.exe\n```\n\n-  -I 程序输出打印到终端，终端关闭则程序停止运行，若想去掉该项，则加上\"-o out.log\"，输出内容会重定向到out.log文件，终端关闭程序也不会停止\n- -q 程序提交到q_sw_expr计算节点队列运行\n- -n 程序运行使用的核组数，最好是4的倍数（一个节点有4个核组）\n- -b 从核函数栈变量放在从核局部存储上（必选）\n- -cgsp 从核的个数，设置64\n- -host_stack 指定主核栈的空间大小，默认8M，一般设置128M以上\n- -share_size 指定核组的共享空间大小，一般share_size+host_stack ≤7500 \n\n```cpp\nbjobs \n//查看当前作业状态和作业号\n\nbkill 作业号 \n//停止作业\n\nqload -w \n//查看可用计算队列和可用节点\n```\n\n## 两级并行\n\n![img](问海一号SACA随记/1685700038922-317f4811-448c-41c9-9f52-18ae7ae9797c.png)\n\n## 性能分析\n\nswprof\n\n使用方法：在bsub命令中增加`-swrunarg '-p'`\n\n![img](问海一号SACA随记/1685700372900-61a89b72-655c-434c-8ef1-0a654eccd299.png)\n","tags":["超算"]},{"title":"SQL基础学习","url":"/2022/02/05/SQL基础学习/","content":"\n# 基础查询\n\n```sql\nuse SCT --SCT数据库\nselect C# from sc --从sc表中查询C#\nselect distinct C# from sc --从sc表中查询C#并且过滤掉重复行\nselect top 3 * from sc --从sc表中查询前三行的数据\nselect top 50 percent * from sc --从sc表中查询前50%的数据\nselect s# as 学号,score as 分数 from sc --从sc表查询s#作为“学号”输出，score作为“分数”输出\nselect s#,C#,Score*1.50 from sc --从sc中查询s#,c#，和score的1.5倍，注意此时score没有列名\nselect s#,C#,Score150 = score *1.50 from sc --此时score*1.50的列名为Score150\nselect * from sc where score>=60 --查询sc中score>=60的元组\nselect * from sc where score>=60 and s#='123' --and查询sc中score>=60并且s#为123的元组\nselect * from sc where score>=60 or score<=20 --or查询\nselect * from sc where score between 20 and 60\nselect * from sc where score>=20 and score<=60 --等效\nselect Cname,Chours from sc where Cname in('数据库','C语言')\nselect Cname,Chours from sc where Cname not in('数据库','C语言')\nselect * from sc where sname like '张%' \nselect * from sc where sname not like '张%' --%任意长的任意字符,_任意单个字符，[]指定范围内的单个字符，如[a-f]或者[abfr]，[^]指定不在范围内的单个字符\nselect * from sc where sname is NULL --[not] is对空值判断\n```\n\n\n\n```sql\nselect avg(sage) as 平均年龄 from student where ssex = '男'\n● avg()：返回列的数据平均值\n● sum()：返回列数据的和\n● max()：返回列数据中的最大值\n● min()：返回列数据中的最小值\n● count()：返回数据的个数\nuse SCT\nselect C#,avg(score) from SC\ngroup by C#\n--group by 后面的必须按照前面筛选的C#进行分组\nhaving avg(score)>=60\n--对group by进行筛选\nSELECT s#,sname \nFROM student \nWHERE ssex='女'\nORDER BY sname ASC --升序\n--ORDER BY sname DESC 降序\nSELECT student.sname, sc.c#, sc.score\nFROM student INNER JOIN sc ON student.s#=sc.s#\n\n也可用\nSELECT sname, sc.c#, sc.score\nFROM student,sc\nWHERE  student.s#=sc.s#\nselect * from subject\nleft join score --left join表示subject全部输出，score取交集\nright join score --right join 表示score全部输出，subject取交集\non subject.id = score.id\n```\n\n![img](SQL基础学习/1680141783646-9338980a-9e78-456d-a219-ad3215ccffcc.png)![img](SQL基础学习/1680141893719-2f9854d4-d7fa-4101-80fd-814543bb4399.png)![img](SQL基础学习/1680141908016-0e173a0d-1daf-4850-9c53-65792838d1ec.png)\n\n```sql\nUNION --并\nEXCEPT --差\nINTERSECT --交\n```\n\n# 数据库、表的操作\n\n### 数据库的创建\n\n```\ncreate database **DATABASE_NAME**\n```\n\n### 删除数据库\n\n```\ndrop database **DATABASE_NAME**\n```\n\n### 表的创建\n\n```sql\ncreate table TABLE_NAME\n(\n  属性1 数据类型,\n  属性2 数据类型,\n)\n```\n\n### 表的修改\n\n```sql\nalter table TABLE_NAME\n[\n  alter column 属性 数据类型 --修改表属性的数据类型\n  add 属性 数据类型 --新增表属性\n  drop column 属性 --删除表属性\n]\n```\n\n### 添加元组\n\n```\ninsert into TABLE_NAME values('','','')\ninsert into TABLE_NAME(属性1,属性2,....) values('','',''...)\n```\n\n### 修改表中数据\n\n```sql\nupdate 表名TABLE_NAME\n  set ssex='男'\n  where sno = '10011'\n```\n\n### 删除元组\n\n如果不加where则删除全部元组\n\n```sql\ndelete 表名TABLENAME\n  \twhere ssex='男'\n```\n\n### not null\n\n```sql\nUSE SCT\nCREATE TABLE STUDENT\n( Sno   char(7) not null,\nSname   char(10), \nSFZ  char(18),\nSage tinyint )\n=============================\nUSE  SCT \nALTER TABLE student\nALTER COLUMN Sname char(10) not null\n```\n\n### **primary key主键约束**\n\n```sql\nUSE SCT\n  CREATE TABLE SC\n  ( Sno   char(7) ,\n    Cno   char(3), \n    Score tinyint,\n    Primary key (Sno,Cno)\n  ) \n================================\nUSE SCT\n  CREATE TABLE STUDENT1\n\t( Sno char(7) primary key，\n    Sname char(10), \n    SFZ char(18),\n\t  Sage tinyint\n  ) \n================================\nUSE  SCT\nALTER TABLE STUDENT1\nadd primary key(sno) --不指定约束名称\nadd constraint pk1 primary key(sno) --指定约束名称\n================================\nuse sct\nalter table STUDENT1\ndrop constraint pk1 --删除pk1约束\n```\n\n### foreign key外键约束\n\n```sql\nUSE SCT\nCREATE  TABLE  SC\n( Sno char(7)  CONSTRAINT sc_k foreign key refernces student(sno),\n Cno char(3), \n Score tinyint\t ) \n=================================\nUSE  SCT\nALTER  TABLE  SC\nADD CONSTRAINT SC3_K\nforeign key(Cno) references Course(Cno)\n```\n\n![img](SQL基础学习/1680493907932-81eb8885-51a5-40cb-bdb0-61eaa798c6d9.png)\n\n注意：references指向的必须是**主键**\n\n### check 条件约束\n\n```sql\nUSE SCT\nCREATE TABLE STUDENT\n( Sno char(7) PRIMARY KEY，\nSname char(10), \nSFZ  char(18) UNIQUE,\nSage tinyint CHECK(Sage>=15 and Sage<=40 ) )\n================================================\nUSE  SCT\nALTER  TABLE  student\nADD CONSTRAINT St4_K\nCHECK(Sage>=15 and Sage<=40 )\n```\n\n### default默认约束\n\n```sql\nUSE SCT\nCREATE TABLE STUDENT\n( Sno   char(7) PRIMARY KEY,\nSname   char(10), \nMajor char(10) DEFAULT‘电计’)\n==============================\nuse SCT\nalter table STUDENT\nadd constraint pk1\ndefalut '电计' for Major\n```\n"},{"title":"Linux常用指令","url":"/2022/02/05/Linux常用指令/","content":"\n# 目录结构\n\nWindows操作系统中路径是：\n\n```\nC:\\Users\\Vicczyq\\Desktop\\a.cpp\n```\n\nLinux操作系统路径：\n\n```\n/Users/Vicczyq/Desktop/a.cpp\n```\n\n# 基础命令\n\n## 1、ls命令：\n\n语法：`ls [-a -l -h] [Linux路径]`\n\n- -a -l -h 是可选的选项\n\n-a:显示全部文件，包括隐藏文件\n\n-l:以列表的形式展示文件，更细节\n\n-h:搭配-l使用，人性化的显示文件大小(K,M,G)\n\n-d:显示目录本身属性\n\n--color:以颜色区分不同类型的文件\n\n可以组合使用，如-al,-alh\n\n\n\n- Linux路径 是可选的参数\n\n如果不加选项和参数，直接使用ls命令，表示：以平铺的形式，列出当前工作目录（开始默认为HOME目录，/HOME/用户名）内容\n\n## 2、cd命令（change directory）：\n\n语法：`cd Linux路径`\n\n- cd命令无需选项，只有路径（只有参数）\n- cd命令不给路径（不写参数）的表示回到用户HOME目录\n\n## 3、pwd命令（print work directory）：\n\n语法：`pwd`\n\npwd命令无选项，无参数，直接输入即可查看当前所在工作目录路径\n\n\n\n## 4、相对路径、绝对路径、特殊路径符：\n\ncd /home/Vicczyq/Desktop\t绝对路径\n\ncd Desktop\t相对路径\n\n特殊路径符：\n\n**.** \t表示当前目录\n\n**..**\t表示上一级目录\n\n**~**\t表示HOME目录\n\n## 5、mkdir命令（make directory):\n\n语法：`mkdir [-p] Linux路径`\n\n-p：自动创建不存在的父目录，用于多级文件夹创建\n\n## 6、touch、cat、more查看命令：\n\n语法：`touch Linux路径`\n\n例如：touch test.py 创建test.py文件（相对路径绝对路径都可以）\n\n语法：`cat Linux路径`\n\n例如：cat test.py 查看test.py文件\n\n语法：`more Linux路径`\n\n可以翻页查看文件（空格翻页，回车换行，q退出）\n\n## 7、cp、mv、rm文件操作命令：\n\n语法：`cp [-r] 参数1 参数2`\n\n- -r用于复制文件夹（如果要复制文件夹就要带上-r）\n- 参数1 Linux路径，表示被复制的文件或者文件夹路径\n- 参数2 Linux路径，表示要复制去的地方\n\n语法：`mv 参数1 参数2`\n\n- 参数1 Linux路径，表示被移动的文件或文件夹路径\n- 参数2 Linux路径，表示要移动去的地方\n\n可以用于改名\n\n语法：`rm [-r -f] 参数1 参数2 参数3.....参数n`\n\n- -r 用于删除文件夹\n- -f 强制删除，不会弹出确认信息（root超级管理员才用到）\n- 可以有多个参数Linux路径，删除多个\n\n\n\nrm可以配合通配符，用来做模糊搜索删除\n\n- 符号*表示通配符，及匹配任意内容：\n- test* 表示以任意test开头的内容\n- *test 表示任意以test结尾的内容\n- *test*表示任意包含test的内容 \n\n## 8、which、find查找命令：\n\n语法：`which 查找的命令`\n\n通过which可以查找命令程序的文件目录，如which pwd、while mkdir\n\n语法：`find 起始路径 -name \"文件名\"`\n\n文件名可以使用通配符\n\n语法：`find 起始路径 -size +|-n[kMG]`\n\n- +、-表示大于或小于\n- n表示数字大小\n- kMG表示大小单位(k为小写)\n\n例如：\n\n- 查找小于10KB的文件，find -size -10k\n- 查找大于100MB的文件：find -size +100M\n\n## 9、grep、wc（文件内容筛选和统计）管道符命令：\n\n语法：`grep [-n] 关键字 文件路径`\n\n- -n可选，表示结果显示匹配的行的行号\n- 参数，关键字，必填，表示文件内容筛选的关键字\n- 参数，文件路径，必填，可以做内容输入（见管道符）\n\n语法：`wc [-c -m -l -w] 文件路径`\n\n- 选项，-c，统计bytes数量\n- 选项，-m，统计字符数量\n- 选项，-l，统计行数\n- 选项，-w，统计单词数量\n- 参数，文件路径，必填，可以做内容输入（见管道符）\n\n**拓展：管道符 |**\n\n**cat test.txt | grep 关键字**\n\n**cat test.txt | wc -l**\n\n**将****左边的输出****作为****右边的输入**\n\n**只要左边有输出就可以作为右边的输入**\n\n## 10、echo、tail、head、重定向符：\n\n语法：`echo 输出的内容`\n\n例如：echo hello world！\n\necho `pwd`被包围的内容会按照命令去执行，最后以echo的形式显示结果\n\n语法：`tail/head [-f -num] Linux文件路径`\n\n- 选项，-f，表示持续追踪，相当于动态显示文件内容，Ctrl+C可以停止\n- 选项，-num，表示查看尾部多少行，不填默认为10\n\n\n\n**重定向符：**\n\n\\>表示覆盖写入到文件\n\n\\>>表示追加写入到文件\n\n例如：ls -al > Desktop/test.txt\n\n## 11、ln命令（软链接）快捷方式:\n\n语法：`ln -s 参数1 参数2`\n\n- -s选项 创建软链接\n- 参数1：被链接的文件或文件夹\n- 参数2：链接的文件或文件夹（快捷方式）\n\n### 12、date时间设置命令、cal日历命令\n\n通过date命令可以在命令行中查看系统时间\n\n语法：`date [-d] [+格式化字符串]`\n\n- -d 按照给定的字符串显示日期，一般用于日期计算\n\n- - - year 年\n    - month 月\n    - day 日\n    - hour 小时\n    - minute 分钟\n    - second 秒\n\n例如：date -d \"-1 day\"\n\n- 格式化字符串：通过特定的字符串标记，控制显示的日期格式\n\n- - - %Y 年\n    - %y 年份后两位（如99）\n    - %m 月份（01,12）\n    - %d 日（0,31）\n    - %H 小时（00,23）\n    - %M 分钟（00,59）\n    - %S 秒（00,60）\n    - %s 自1970-01-01 00:00:00: UTC到现在的秒数\n\ndate -d \"-1 day\" %d\n\n#### 修改时区：rm -f /etc/localtime\n\n# Vi、Vim编辑器\n\nvi/vim是命令行下对文本编辑的最经典的编辑器\n\nvim是vi的加强版本，兼容vi的所有指令，而且具有shell程序编辑的功能\n\n语法：`vim 文件名` 进入命令模式\n\n| i    | 当前光标位置进入输入模式      | dd      | 删除光标所在行             |\n| ---- | ----------------------------- | ------- | -------------------------- |\n| a    | 当前光标位置 之后进入输入模式 | ndd     | n为数字，删除当前光标下n行 |\n| I    | 当前行的开头进入输入模式      | yy      | 复制当前行                 |\n| A    | 当前行的结尾进入输入模式      | nyy     | n为数字，复制当前光标下n行 |\n| o    | 当前光标下一行进入输入模式    | p       | 粘贴                       |\n| O    | 当前光标上一行进入输入模式    | u       | 撤销修改                   |\n| esc  | 进入命令模式                  | gg      | 到首行                     |\n| 0    | 光标移动到行开头              | G       | 到尾部                     |\n| $    | 光标移动到行结尾              | :wq     | 保存并退出                 |\n| /    | 进入搜索模式                  | :q      | 直接退出                   |\n| n    | 向下继续搜索                  | :q!     | 强制退出                   |\n| N    | 向上继续搜索                  | :set nu | 设置显示行号               |\n\n# 网络请求和下载\n\n### 1、ping\n\n语法：`ping [-c num] ip或者主机名`\n\n- -c 检查的次数，不使用-c就无限次\n\n### 2、wget\n\n语法：`wget [-b] url`\n\n- -b 可选，后台下载，会将日志写入到当前目录的wget-log文件中\n- url 参数,下载链接\n\n### 3、curl\n\n可以用于发送http网络请求，用于：下载文件，获取信息等\n\n语法：`curl [-O] url`\n\n- -O 选项，用于下载文件，当url是下载链接时候，可以使用此选项保存文件\n- url，参数，要发起请求的网址\n\n# 软件\n\n### 1、yum命令（root）软件安装：\n\nRPM包软件管理器，用于自动化安装Linux软件，并可以解决依赖问题\n\n语法：`yum [-y] [install | remove | search] 软件名称`\n\n- -y，自动确认，无需手动确认安装或卸载过程\n- install：安装\n- remove：卸载\n- search：搜索\n\n### 2、systemctl命令\n\n控制软件：启动、停止、开机自启\n\n语法：`systemctl [start | stop | status |enable | disable] 服务名`\n\n- start：启动\n- stop：关闭\n- status：查看状态\n- enable：开启开机自启\n- disable：关闭开机自启\n\n# 压缩和解压缩\n\n### 1、tar压缩\n\n语法：`tar [-c -v -x -f -z -C] 参数1 参数2...参数n`\n\n- -c，创建压缩文件，用于压缩模式\n- -v，显示压缩，解压过程，用于查看进度\n- -x，解压模式\n- -f，要创建的文件，或要解压的文件，-f选项必须在所有选项的**最后**\n- -z，gzip格式，不使用就是普通的tarball格式，必须在**最前面**\n- -C，解压目的地\n\ntar：`tar -cvf test.tar 1.txt 2.txt 3.txt`\n\ngzip：`tar -zcvf test.tar.gz 1.txt 2.txt 3.txt`\n\n### 2、tar解压\n\n语法：`tar -xvf test.tar`\n\n指定解压路径：`tar -xvf test.tar -C /home/vicczyq/Desktop`\n\n\n\n### 3、zip压缩文件\n\n语法：`zip [-r] 参数1 参数2.....参数n`\n\n- -r，被压缩的包含文件夹时候，需要使用\n\n### 4、unzip解压文件\n\n语法：`unzip 参数 [-d 文件路径]`\n\n-d指定解压去的路径位置，参数为zip压缩包文件\n\n# 快捷键\n\n### 1、Ctrl+C 强行停止\n\n- Linux某些程序运行，如果想强行停止可以Ctrl+C\n- 输入命令错误，可以通过Ctrl+C清空输入\n\n### 2、Ctrl+D 退出或登出\n\n用户切换时候等效于exit，但不能退出vi/vim\n\n可以退出python等软件\n\n### 3、history命令可以查询历史使用命令\n\nhistory | grep \"关键词\"\n\n可以筛选\n\n### 4、！命令前缀\n\n执行历史记录中以前缀开头的最近的命令\n\n### 5、Ctrl+R 搜索历史命令\n\n### 6、Ctrl+a 跳到命令开头\n\n### 7、Ctrl+e 跳到命令结尾\n\n### 8、Ctrl+键盘左右键 左右跳单词\n\n### 9、Ctal+L 清空终端内容\n\n等效于输入命令clear\n\n### 10、Ctrl+U清空至行首\n\n### 11、Ctrl+K清空至行尾\n\n### 12、Home跳到行首\n\n### 13、End跳到行尾\n\n# 环境变量\n\n### 临时设置：\n\n语法：`export 变量名=变量值`\n\n### 永久生效：\n\necport PATH=$PATH :/添加的东西（$PATH取当前PATH的值）\n\n针对当前用户：配置当前用户的~/bashrc文件\n\n针对所有用户：配置在系统的/ect/profile文件\n\n配置完成，通过`source 配置文件`命令立刻生效\n\n# IP地址和主机用户\n\n### 1、hostname 查看主机名\n\n### 2、hostnamectl set-hostname 主机名\n\n修改主机名\n\n### 3、设置静态IP\n\n使用vim编辑 /ect/sysconfig/network-scripts/ifcfg-ens33文件 \n\n# Linux用户\n\n**用户账号文件：**/etc/passwd\n\n**用户密码文件：**/etc/shadow\n\n**组账号：**/etc/group\n\n**组密码：**/etc/gshadow\n\n\n\n最大权限的账户名：root\n\n切换用户（Switch User）：\n\n```\nsu [-] [用户名]\n```\n\n- “-”符号表示表示是否加载环境变量，建议加上\n- 用户名为可选参数，不填默认为root\n\n切换用户后，可以用exit切回上次用户\n\n\n\n```\nsudo 其它命令\n```\n\n这条命令以root的身份去执行，临时root授权\n\n并不是所有的用户都有权力使用sudo，只有配置sudo认证的才能\n\n\n\n**配置sudo认证：**\n\n切换到root用户，执行visudo命令，在文件最后添加\n\n```\n用户名 ALL=(ALL) NOPASSWORD\n```\n\nwq保存退出\n\n\n\n## 用户和用户组\n\n1、创建用户组：\n\n语法 `groupadd 用户组名`\n\n2、删除用户组\n\n语法 `groupdel 用户组名`\n\n3、创建用户\n\n语法 `useradd [-g -d -s] 用户名`\n\n- -g 指定用户组，如果不指定就会创建一个和用户名一样的组自己加入\n- -d 指定用户HOME路径，不指定默认在/home/用户名\n- -s 指定shell，默认为/bin/bash\n\n4、删除用户\n\n语法 `userdel [-r] 用户名`\n\n- -r 删除用户的HOME目录，不使用-r只删掉用户，不删目录文件\n\n5、查看用户所属组\n\n语法 `id [用户名]`\n\n- 不加用户名默认显示当前用户所属用户组\n\n6、修改用户所属组\n\n语法` usermod -aG 用户组 用户名`\n\n- 将指定用户加入指定组\n\n7、getent\n\n语法 `getent passwd`\n\n查看当前系统中的用户\n\n语法 `getent group`\n\n查看当前系统中的用户组\n\n8、更改/设置用户口令\n\n语法` passwd 用户名`\n\n![img](Linux常用指令/1695091854612-947fb28a-bde3-4437-b4aa-2e1fb80ddc7c.png)\n\n## 权限管理和修改\n\n![img](Linux常用指令/1679123684100-4081e340-fa70-4e1f-97bb-166729dccf43.png)\n\nr：表示可读权限\n\nw：表示可写权限\n\nx：表示执行权限\n\n-：无权限\n\n### 权限修改：\n\n**1、chmod命令：**\n\n语法：`chmod [-R] 权限 文件或文件夹`\n\n- -R指文件夹内所有文件进行相同操作\n\n实例：\n\nchmod u=rwx,g=rx,o=x hello.txt\n\n修改后的权限信息为：rwxr-x--x\n\n0：--- \t1：--x\t2：-w-\t3：-wx\n\n4：r--\t5：r-x\t6：rw-\t7：rwx\n\nchmod 751 hello.txt\n\n\n\n**2、chown命令：**\n\n语法：`chown [-R] [用户] [:] [用户组] 文件或文件夹`\n\n- -R指文件夹内所有文件进行相同操作\n\n![img](Linux常用指令/1679124407657-2754fd9e-b047-4c49-8978-174f49b9c60d.png)\n\n![img](Linux常用指令/1695695221590-a0ce7b34-78de-451b-ab9b-34a7ae774746.png)\n","tags":["计算机基础"]},{"title":"CUDA基础学习","url":"/2022/02/05/CUDA基础学习/","content":"\n![img](CUDA基础学习/1699278155036-757a1974-f6c1-43cd-a8e6-06852e4e6a4f.png)\n\nCPU+GPU组成异构计算，GPU可以看做是CPU的协作处理器，一般称为设备\n\n主机（CPU）和设备（GPU）之间的内存访问是通过PCIe总线连接的\n\n| **CPU**            | **GPU**        | **层次** |\n| ------------------ | -------------- | -------- |\n| 算术逻辑和控制单元 | 流处理器(SM)   | 硬件     |\n| 算术单元           | 批量处理器(SP) | 硬件     |\n| 进程               | Block          | 软件     |\n| 线程               | thread         | 软件     |\n| 调度单位           | Warp           | 软件     |\n\n![img](CUDA基础学习/1699013132500-689d59c7-7782-48d7-b23b-7cde1c59474d.png)\n\n一个线程在一个CUDA Core执行（SP）\n\n一个线程块被分配到一个SM上面执行\n\n一个Grid在GPU设备执行\n\n**查看显卡利用率**\n\n```\nnvidia-smi\n```\n\n![img](CUDA基础学习/1699002941511-a35e1dac-97f6-4a68-b917-50814844d2dc.png)\n\n# 1、核函数（Kernel_function）\n\n核函数在GPU上进行并行执行\n\n注意：\n\n1. 限定词_global_修饰\n2. 返回值必须是void\n3. 核函数只能访问设备（GPU）内存\n4. 核函数不能使用变长参数、静态变量、函数指针\n5. 核函数具有异步性\n\n```cpp\n_global_ void kernel_function(argument *arg)\n{\n    printf(\"Hello world from GPU\\n\");\n}\nvoid _global_ kernel_function(argument *arg)\n{\n    printf(\"Hello world from GPU\\n\");\n}\n#include <stdio.h>\n_global__ void hello()\n{\n    printf(\"Hello world from GPU\\n\");\n}\nint main()\n{\n    hello<<<1,1>>>(); //设备（GPU）核函数执行，<<<1,1>>>含义见下节。\n    cudaDeviceSynchronize(); //同步，CPU等待CPU处理完成\n    return 0;\n}\n```\n\n# 2、线程模型\n\n## 2.1基本概念\n\n![img](CUDA基础学习/1699011161039-62e75ab2-9f1c-4917-a815-37284fa75aa2.jpeg)\n\n线程分块是逻辑上的划分，物理上线程不分块\n\n配置线程：`<<<grid_size , block_size>>>`\n\ngrid_size：网格包含的线程块个数\tblock_size：线程块包含的线程个数\n\n![img](CUDA基础学习/1697013915734-f63e760a-5105-44f8-bafe-e9c5b382fe85.png)\n\n## 2.2一维身份标识\n\n每个线程的唯一标识由`<<<grid_size, block_size>>>`确定。\n\n在核函数中可以使用\n\n`gridDim.x`：该变量的值等于执行配置中变量`grid_size`的值（线程格的维度）\n\n`blockDim.x`：该变量的值等于执行配置中变量`block_size`的值（线程块的维度）\n\n`blockIdx.x`：线程在网格(grid)中的线程块(block)的索引，范围`0~gridDim.x-1`（线程块的索引）\n\n`threadIdx.x`：线程在线程块中的线程索引，范围`0~blockDim.x-1`（线程索引）\n\n![img](CUDA基础学习/1697012880220-f0efb73d-8784-47bf-bed8-34e3663ca4a5.png)\n\n\n\nCUDA可以组织三维的网格和线程块\n\n`blockIdx`和`threadIdx`都是结构体，具有x，y，z三个成员\n\n![img](CUDA基础学习/1697013503445-bdade019-0e4f-4dbe-91f9-35edef6a38ea.png)\n\n**一维：**\n\n![img](CUDA基础学习/1697013590396-76aec282-966a-48f7-804b-3cd0220a7cd4.png)\n\n**多维：**\n\n```cpp\ndim3 grid_size(Gx,Gy,Gz);\ndim3 block_size(Bx,By,Bz);\n<<<grid_size,block_size>>>//（线程块数，每个块线程数）\n\n// 例如：\n    dim3 grid_size(2,2); //等价于dim3 grid_size(2,2,1);\n\tdim3 block_size(5,3);//等价于dim3 block_size(5,3,1);\n```\n\n# 3、函数修饰符\n\n**__global__**：表明被修饰的函数在设备上执行，但在主机上调用\n\n**__device__**：表明被修饰的函数在设备上执行，但只能在其他__device__函数或者__global__函数中调用。\n\n# 4、常用的GPU函数\n\n#### cudaMalloc (void **devPtr, size_t size)\n\n功能：与C语言中的malloc函数一样，只是此函数在GPU的内存你分配内存。\n\n#### cudaMemcpy (void dst, const void src, size_t count, cudaMemcpyKind kind)\n\n功能：与c语言中的memcpy函数一样，只是此函数可以在主机内存和GPU内存之间互相拷贝数据。\n\n函数参数：cudaMemcpyKind kind表示数据拷贝方向，如果kind赋值cudaMemcpyDeviceToHost表示数据从设备内存拷贝到主机内存，cudaMemcpyHostToDevice表示主机到设备。\n\n相应的有个异步方式执行的函数cudaMemcpyAsync()\n\n#### cudaFree ( void* devPtr )\n\n功能：与c语言中的free()函数一样，只是此函数释放的是cudaMalloc()分配的内存。\n\n#### __syncthreads()\n\n功能：同步函数，确保线程块中的每个线程都执行完__syscthreads()前面的语句后，才会执行下一条语句。\n\n#### cudaDeviceSynchronize(); \n\n功能：同步，CPU等待GPU处理完成，注意此函数是CPU函数！\n\n```cpp\n#include <stdio.h>\n__global__ void add( int a, int b, int *c ) {\n    *c = a + b;\n}\nint main( void ) {\n    int c;\n    int *dev_c;\n\n    cudaMalloc( (void**)&dev_c, sizeof(int) );\n\n    add<<<1,1>>>( 2, 7, dev_c );   \n\n    cudaMemcpy( &c, dev_c, sizeof(int),cudaMemcpyDeviceToHost ) ;\n    printf( \"2 + 7 = %d\\n\", c );\n\n    cudaFree( dev_c );\n    return 0;\n}\n```\n\n# 5、GPU内存分类\n\n## 5.1全局内存\n\n通俗意义上的设备内存\n\n## 5.2共享内存\n\n位置：设备内存。\n\n形式：关键字`__share__`添加到变量声明中，如：`**__share__ float a[10]**`\n\n访问速度和L1相同\n\n## 5.3常量内存\n\n位置：设备内存\n\n形式：关键字`__constant__`添加到变量声明中，如：`__constant__ float a[10]`\n\n目的：为了提升性能。常量内存采取了不同于全局内存的处理方式，在某些情况下用常量内存替换全局内存能有效的减少内存带宽。\n\n# 6、计时\n\n```cpp\n#include <sys/time.h>\ndouble cpuSecond(){\n\tstruct timeval tp;\n    gettimeofday(&tp,NULL);\n    return ((double)tp.tv_sec + (double)tp.tv_usec*1.e-6);\n}\n\n测试函数(秒)：\ndouble start_time = cpuSecond();\nkernel_function<<<grid,block>>>();\ncudaDeviceSynchronize();\ndouble Elaps = cpuSecond() - start_time; \ncudaEvent_t startCuda, stopCuda;  //declare\ncudaEventCreate(&startCuda);      //set up \ncudaEventCreate(&stopCuda);       //set up\n\ncudaEventRecord(startCuda,0);    //start\nmyAdd <<<grid, threads>>> (d_B, d_C, d_A);\ncudaEventRecord(stopCuda,0);     //finish\n\nfloat eTime;\ncudaEventElapsedTime(&eTime, startCuda, stopCuda); \n\ncout<<eTime<<endl;\n\ncudaEventDestory(startCuda);\ncudaEventDestory(stopCuda);\n```\n\n# 7、获取GPU名字\n\n```cpp\n    cudaDeviceProp deviceProp;\n    cudaGetDeviceProperties(&deviceProp, 0);\n    printf(\"GPU Name: %s\\nJob start:\\n\", deviceProp.name);\n```\n\n# 8、线程束（Wrap)\n\n线程束是SM中基本的执行单元\n\n（SM是Streaming Multiprocessor的缩写，它是指图形处理器(GPU)中的一个核心处理单元）\n\n一个线程束由32个连续的线程组成。是执行程序时的调度单位，同在一个warp的线程执行同一个指令。\n\n\n\n**为什么要引入Wrap？**\n\n虽然GPU的Grid和Block的大小很大，可以拥有上万级别的线程，但因为硬件的限制，不是所有线程都是可以平行运行的。在运行thread的时候， thread会被捆绑到一起形成一个wrap。32个thread一个wrap。 同一个wrap里的指令是一样的，也就是他们运行的东西是一摸一样的，数据也相同。一个wrap里的线程只允许在同一个block里面运行。**为了让程序的运行更加有效，需要让同一个wrap里的线程运行同样的代码。**\n\n**看一个代码：**\n\n```cpp\n__global__ void code_with_divergence()\n{\n\tint idx = threadIdx.x;\n\tif(idx%2==0)\n\t{\n\t\t // do A\n\t}\n\telse\n\t{\n\t\t// do B\n\t}\n}\n```\n\n上面这个这个代码会让效率减少一半。因为当运行A的时候，会让满足条件的那一半thread运行，而另一半的thread会被休眠。\n\n**注意：**不是写了if语句就一定会让运行效率降低。只要能保证用一个wrap里的线程运行同样的指令就可以提升效率，比如如下代码：\n\n```cpp\n__global__ void code_without_divergence()\n{\n\tint idx = blockIdx.x * blockDim.x + threadIdx.x;\n\t// int wrap_id = idx/32;\n    int wrap_id = idx / wrapSize;//固有变量wrapSize = 32\n\tif(wrap_id%2==0)\n\t{\n\t\t // do A\n\t}\n\telse\n\t{\n\t\t// do B\n\t}\n}\n```\n\n代码是以一个wrap为整体去运行的，所以不会影响运行效率。\n\n# 9、如何设置grid和block\n\n## 前言：\n\nGPU 由多个 SM 处理器构成，一个 SM 处理器包含 8 个 SP 核。一个 SM 处理器可同时处理 32 个线程（Wrap束），实际上是同一套指令在每个 SP 核上重复 4 次， 这样提交一次任务，8 个SP 核同时就能处理 32 个线程。\n\n![img](CUDA基础学习/1699013420617-1a677527-2101-48e4-a317-1841acc8d223.png)\n\n## 设置grid和block维度\n\n如果某个GPU拥有 16 个 SM 处理器，共 128 个 SP 核（16*8）。\n\n1. 如果想让每个 SM 处理器都工作，则 Grid 的 Block 的数量最好是 16 的整数倍。这样在整个计算过程中，每个 SM 处理器负载都是一样的。\n2. 每个 SM 处理器同时可以处理 32 个线程，因此，Block 中的线程数量最好是 32 的倍数，使得 8 个 SP 核负载均衡。\n\n由上可知，应该按照16*N*32*M = 512*S的划分模式，也就是说，理想的数据量应该是 512 的整数倍。同时要注意，一个线程块线程数量不能多于1024！\n\n### 1.一维grid，一维block\n\n```cpp\nint nx = 1 << 14;\nint ny = 1 << 14;\nint dimx = 32;\ndim3 block(dimx);\ndim3 grid((nx + block.x - 1) / block.x);\n```\n\n核函数\n\n```cpp\n__global__ void kernel_function()\n{\n    unsigned int ix = threadIdx.x + blockIdx.x * blockDim.x;\n    if (ix < nx )\n   {\n        do_something();\n    }\n}\n```\n\n### 2.二维grid，一维block\n\n```cpp\nint nx = 1 << 14;\nint ny = 1 << 14;\nint dimx = 32;\ndim3 block(1, dimx);\ndim3 grid(nx, (ny + block.y - 1) / block.y);\n```\n\n核函数\n\n```cpp\n__global__ void kernel_function()\n{\n    int x = blockIdx.x;\n    int y = blockIdx.y*blockDim.y+threadIdx.y;\n}\n```\n\n### 3.二维grid，二维block\n\n```cpp\nint nx = 1 << 14;\nint ny = 1 << 14;\nint dimx = 32;\nint dimy = 32;\ndim3 block(dimx, dimy);\ndim3 grid((nx + block.x - 1) / block.x, (ny + block.y - 1) / block.y);\n```\n\n核函数\n\n```cpp\n__global__ void kernel_function()\n{\n    unsigned int x = threadIdx.x + blockIdx.x * blockDim.x;\n    unsigned int y = threadIdx.y + blockIdx.y * blockDim.y;\n    unsigned int tid = x*ny + y;\n    if (ix < nx && iy < ny)\n    {\n        do_something();\n    }\n}\n```\n\n![img](CUDA基础学习/1699272791683-3f21b828-d2bd-4311-b305-d7185839e59d.png)\n\n## 文档\n\nhttps://www.zhihu.com/tardis/bd/art/566538074\n\nhttps://zhuanlan.zhihu.com/p/573271688\n","tags":["超算"]},{"title":"MPI学习","url":"/2022/02/05/MPI学习/","content":"\n# 一、Hello world\n\n```cpp\n#include <iostream>\n#include <mpi.h>\nusing namespace std;\nint main(){\n\tMPI_Init(NULL,NULL);\n\tcout << \"hello world\" << endl;\n\tMPI_Finalize();\n\treturn 0;\n}\n```\n\n```bash\nmpicxx hello.cpp -o hello\n```\n\n```bash\nmpirun -np 10 ./hello\n```\n\n代码结构：\n\n- 头文件\n- 初始化MPI环境：MPI_Init()\n- 分布式代码\n- 终止MPI环境：MPI_Finalize()\n- 结束\n\n# 二、基本API\n\n## 2.1 初始化环境 MPI_Init\n\n```cpp\nint MPI_Init(int* argc,char* argv[]);\n//参数argc_p和argc_v是指向参数argc和argv的指针，当程序不使用这些参数时可直接写为NULL。\n//该函数的返回值一般为一个整型int，我们一般忽略。\n//所以一般最常见的用法为：\nMPI_Init(NULL,NULL);\n//除此之外，该函数一般表示MPI函数的开始，在此之前不应该有其他MPI函数\n```\n\n## 2.2 是否初始化：MPI_Initialized\n\n```cpp\nint MPI_Initialized(int *flag)\n```\n\n唯一可在MPI_Init前使用的函数，用来检测MPI系统是否已经初始化，**已经调用MPI_Init，返回flag=true，否则返回flag=false**。\n\n## 2.3 终止环境：MPI_Finalized\n\n```cpp\nint MPI_Finalize(void)\n```\n\n在一个进程执行完其全部MPI函数调用后，将调用函数MPI_Finalize，从而让系统释放分配给MPI的资源（例如内存等）\n\n## 2.4 获取进程数：MPI_Comm_size\n\n```cpp\nint MPI_Comm_size(MPI_Comm comm, int* size)\n```\n\n通过调用函数来确定一个通信域中的**进程总数**。\n\n如果comm是`MPI_COMM_WORLD`，那就是当前程序能用的所有进程数\n\n## 2.5 获取进程ID：MPI_Comm_rank\n\n```cpp\nint MPI_Comm_rank(MPI_Comm comm, int* rank)\n```\n\n**在一个有p个进程的通信域中，每一个进程有一个唯一的序号（ID号），取值为0~p-1**。\n\n当MPI初始化后，每一个活动进程变成了一个叫MPI_COMM_WORLD的通信域中的成员。\n\n## 2.6 获取程序运行的主机名\n\n```cpp\nint MPI_Get_processor_name(char* name, int* resultlen)\n```\n\n- name：返回名称\n- resultlen：返回名称所占用的字节\n\n应提供参数name不少于MPI_MAX_PROCESSOR_NAME个字节的存储空间。\n\n## 2.7 终止一个comm的所有进程：MPI_Abort\n\n```cpp\nint MPI_Abort(MPI_Comm comm, int errorcode)\n```\n\n异常终止MPI程序，在出现了致命错误而希望异常终止MPI程序时执行，MPI系统会设法终止comm通信器中的所有进程，输入整形参数errocode，将被作为进程的退出码返回给系统。\n\n## 2.8 同步栅栏函数 MPI_Barrier\n\n```cpp\nvoid MPI_Barrier(MPI_Comm communicator)\n```\n\n可以用二叉树、双回环等方式实现，依靠的是Send、Recv阻塞机制\n\n# 三、通信API\n\n- MPI提供了消息的缓存机制\n- 消息可以以阻塞或非阻塞的方式发送\n- 顺序性：MPI保证接收者收到消息的顺序和发送者的发送顺序一致\n- 公平性：MPI不保证调度公平性，程序员自己去防止进程饥饿\n\n## 3.1 MPI消息数据类型\n\n|    MPI 数据类型    |    C 语言数据类型    |   MPI 数据类型    |  C 语言数据类型   |\n| :----------------: | :------------------: | :---------------: | :---------------: |\n|      MPI_CHAR      |     signed char      |   MPI_UNSIGNED    |   unsigned int    |\n|     MPI_SHORT      |   signed short int   | MPI_UNSIGNED_LONG | unsigned long int |\n|      MPI_INT       |      signed int      |     MPI_FLOAT     |       float       |\n|      MPI_LONG      |   signed long int    |    MPI_DOUBLE     |      double       |\n|   MPI_LONG_LONG    | signed long long int |  MPI_LONG_DOUBLE  |    long double    |\n| MPI_UNSIGNED_CHAR  |    unsigned char     |     MPI_BYTE      |                   |\n| MPI_UNSIGNED_SHORT |  unsigned short int  |    MPI_PACKED     |                   |\n\n## 3.2 点对点通信\n\n`status`参数用于指出接收的消息的源和标记（status.MPI_SOURCE、status.MPI_TAG）如果不关心这些参数，可以用`MPI_STATUS_IGNORE`\n\n- 阻塞发送/接收：\n\n  ```cpp\n  int MPI_Send(void *buf, int count, MPI_Datatype datatype, int dest, int tag, MPI_Comm comm)\n  // buf: 发送缓冲区起始地址\n  // count: 发送消息的数据单元个数\n  // datatype: 发送消息的数据类型\n  // dest: 目标进程号\n  // tag: 发送消息的标签\n  // comm: 通信域\n  int MPI_Recv(void *buf, int count, MPI_Datatype datatype, int source, int tag, MPI_Comm comm, MPI_Status *status)\n  //status可以用MPI_STATUS_IGNORE忽略使用\n  ```\n\n  ```cpp\n  #include <stdio.h>\n  #include <string.h>\n  #include \"mpi.h\"\n  void main(int argc, char* argv[])\n  {\n      int numprocs, myid, source;\n      MPI_Status status;\n      char message[100];\n      MPI_Init(&argc, &argv);\n      MPI_Comm_rank(MPI_COMM_WORLD, &myid);\n      MPI_Comm_size(MPI_COMM_WORLD, &numprocs);\n      if (myid != 0) {  //非0号进程发送消息\n          strcpy(message, \"Hello World!\");\n          MPI_Send(message, strlen(message) + 1, MPI_CHAR, 0, 99,\n              MPI_COMM_WORLD);\n      }\n      else {   // myid == 0，即0号进程接收消息\n          for (source = 1; source < numprocs; source++) {\n              MPI_Recv(message, 100, MPI_CHAR, source, 99,\n                  MPI_COMM_WORLD, &status);\n              printf(\"接收到第%d号进程发送的消息：%s\\n\", source, message);\n          }\n      }\n      MPI_Finalize();\n  }\n  ```\n\n  \n\n- 非阻塞发送/接收：\n\n  ```cpp\n  int MPI_Isend(const void* buf, int count, MPI_Datatype datatype, int dest, int tag, MPI_Comm comm, MPI_Request* request)\n  // buf: 发送缓冲区起始地址\n  // count: 发送消息的数据单元个数\n  // datatype: 发送消息的数据类型\n  // dest: 目标进程号\n  // tag: 发送消息的标签\n  // comm: 通信域\n  // request: 非阻塞发送请求对象\n  int MPI_Irecv(void *buf, int count, MPI_Datatype datatype, int source, int tag, MPI_Comm comm, MPI_Request *request)\n  //通过request可以知道Isend或Irecv的状态（是否完成）\n  ```\n\n  `MPI_Wait`用于等待某一个通信的完成，`MPI_Waitall`等待一组通信的完成\n\n  ```cpp\n  int MPI_Wait(MPI_Request *request, MPI_Status *status)\n  //status可用`MPI_STATUS_IGNORE`代替\n  ```\n\n  ```cpp\n  #include <mpi.h>\n  #include <iostream>\n  #include <vector>\n  int main(int argc, char** argv) {\n      MPI_Init(&argc, &argv);\n      int rank, size;\n      MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n      MPI_Comm_size(MPI_COMM_WORLD, &size);\n      if (size != 2) {\n          std::cerr << \"This program requires exactly 2 MPI processes.\" << std::endl;\n          MPI_Abort(MPI_COMM_WORLD, 1);\n      }\n      const int N = 10;\n      std::vector<int> data(N);\n      MPI_Request request;\n      MPI_Status status;\n  \n      if (rank == 0) {\n          for (int i = 0; i < N; ++i) {\n              data[i] = i;\n          }\n          MPI_Isend(data.data(), N, MPI_INT, 1, 0, MPI_COMM_WORLD, &request);\n          MPI_Wait(&request, &status);\n      } else if (rank == 1) {\n          MPI_Irecv(data.data(), N, MPI_INT, 0, 0, MPI_COMM_WORLD, &request);\n          MPI_Wait(&request, &status);\n          std::cout << \"Process 1: Data received.\" << std::endl;\n          std::cout << \"Process 1: Received data = \";\n          for (int i = 0; i < N; ++i) {\n              std::cout << data[i] << \" \";\n          }\n          std::cout << std::endl;\n      }\n      MPI_Finalize();\n      return 0;\n  }\n  \n  ```\n\n## 3.3 集合通信\n\n### 3.3.1 广播 Bcast\n\n从指定的一个根进程中把**相同的数据**广播发送给组中的所有其他进程\n\n![img](MPI学习/793e4b95df5f473ab6a917b3351d5c2c.png)\n\n```cpp\nMPI_Bcast(\n    void *buffer,\n    int count,\n    MPI_Datatype datatype,\n    int root,\n    MPI_Comm comm)\n```\n\nfor循环调用MPI_Send和MPI_Recv也能实现广播的效果，但是**时间复杂度**有很大的区别，for循环实现时间复杂度为**O(n)**，Bcast实现时间复杂度为**O(logn)**\n\n**Bcast的实现示意图：**\n\n![MPI_Bcast tree](MPI学习/broadcast_tree.png)\n\n- **T0时刻：**0号进程将数据传递给1号进程\n- **T1时刻：**0号进程和1号进程都有了数据，0号进程将数据发送给2号进程，1号进程发送给3号进程\n- **T2时刻：**0->4，1->5，2->6，3->7\n\n### 3.3.2 分发 Scatter\n\n把指定的根进程中的数据**分散**发送给组中的所有进程（**包括自己**）\n\n![img](MPI学习/5b0f095e18a74d38b739034c496a1e15.png)\n\n```cpp\nMPI_Scatter(\n    void* send_data,int send_count,MPI_Datatype send_datatype,\n    void* recv_data,int recv count,MPI_Datatype recv_datatype,\n    int root,MPI_Comm communicator)\n```\n\n### 3.3.3 收集 Gather\n\n在组中指定一个进程收集组中进程发来的消息，这个函数操作与MPI_Scatter函数操作相反\n所有进程调用该函数，把指定位置的数据发送给根进程的指定位置\n\n![img](MPI学习/b5d9b251e1c643ce83ae9db8440eab5c.png)\n\n```cpp\nMPI_Gather(\n    void *sendbuf,int sent_count,MPI_Datatype send_datatype,\n    void *recv_data,int recv_count,MPI_Datatype recv_datatype,\n    int root,MPI_Comm communicator)\n```\n\n### 3.3.4 全收集 Allgather\n\n将所有的数据聚合到每个进程中。\n\n![image-20240526132009884](MPI学习/image-20240526132009884.png)\n\n```cpp\nMPI_Allgather(\n    void* send_data,int send_count,MPI_Datatype send_datatype,\n    void* recv_data,int recv_count,MPI_Datatype recv_datatype,\n    MPI_Comm communicator)\n```\n\n与gather的区别就是没有`root`参数\n\n### 3.3.5 规约 Reduce\n\n将每个进程中的数据按给定的操作op进行运算，并将其结果返回到序列号为root的进程。\n\n![image-20240526132613368](MPI学习/image-20240526132613368.png)\n\n可以处理多个值\n\n![img](MPI学习/modb_20211208_35345a7a-580d-11ec-bc47-fa163eb4f6be.png)\n\n```cpp\nMPI_Reduce(\n\tvoid *send_data,\n\tvoid *recv_data, \n\tint count,\n\tMPI_Datatype datatype,\n\tMPI_Op operator,/*操作*/\n\tint root,\n\tMPI_Comm comm);\n```\n\n![opration](MPI学习/20151125101509006.png)\n\n### 3.3.6 全规约 Allreduce\n\n![MPI，OpenMPI与深度学习-有驾](MPI学习/u=1777912551,215306698&fm=30&app=106&f=JPEG.jpeg)\n\n```cpp\nMPI_Allreduce(\n    void* send_data,\n    void* recv_data,\n    int count,\n    MPI_Datatype datatype,\n    MPI_Op op,\n    MPI_Comm communicator)\n```\n\n## 3.4 通信域和进程组\n\n**进程组**就是一组并行运行的MPI进程的集合，同一进程可以属于不同的进程组\n\n一个进程组可以包含任意数量的进程，而一个通信域由一个进程组构成，但一个进程组可以用于创建多个不同的通信域。\n\n在之前的MPI学习中一直使用的通信域MPI_COMM_WORLD**所对应的**进程组就是全体进程的集合\n\n```cpp\n#include <mpi.h>\n#include <stdio.h>\n\nint main(int argc, char *argv[]) {\n    MPI_Init(&argc, &argv);\n\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    // 获取默认通信域的进程组\n    MPI_Group world_group;\n    MPI_Comm_group(MPI_COMM_WORLD, &world_group);\n\n    // 创建包含前半部分进程的新进程组\n    int half_size = size / 2;\n    int *ranks = (int *)malloc(half_size * sizeof(int));\n    for (int i = 0; i < half_size; i++) {\n        ranks[i] = i;\n    }\n\n    MPI_Group new_group;\n    MPI_Group_incl(world_group, half_size, ranks, &new_group);\n\n    // 使用新进程组创建新的通信域\n    MPI_Comm new_comm;\n    MPI_Comm_create(MPI_COMM_WORLD, new_group, &new_comm);\n\n    // 在新通信域中进行操作\n    if (new_comm != MPI_COMM_NULL) {\n        int new_rank, new_size;\n        MPI_Comm_rank(new_comm, &new_rank);\n        MPI_Comm_size(new_comm, &new_size);\n\n        int data = new_rank;\n        // 广播数据\n        MPI_Bcast(&data, 1, MPI_INT, 0, new_comm);\n        printf(\"Process %d in new_comm received data %d\\n\", new_rank, data);\n\n        // 规约操作\n        int sum;\n        MPI_Reduce(&data, &sum, 1, MPI_INT, MPI_SUM, 0, new_comm);\n        if (new_rank == 0) {\n            printf(\"Sum of ranks in new_comm: %d\\n\", sum);\n        }\n    }\n\n    // 释放通信域\n    MPI_Comm_free(&new_comm);\n\n    // 释放进程组\n    MPI_Group_free(&world_group);\n    MPI_Group_free(&new_group);\n\n    MPI_Finalize();\n    return 0;\n}\n\n```\n\n","tags":["超算"]},{"title":"OpenMP学习","url":"/2022/02/05/OpenMP学习/","content":"\n![image-20240524114515105](OpenMP学习/image-20240524114515105.png)\n\n编译时需要加上`-fopenmp`标志：\n\n```bash\ngcc -fopenmp -o my_program my_program.c\n```\n\n|            函数             |               概念               |\n| :-------------------------: | :------------------------------: |\n|  `int omp_get_num_procs()`  | 返回本线程的多处理机的处理器个数 |\n| `int omp_get_num_threads()` |    返回当前并行区域的线程个数    |\n| `int omp_get_thread_num()`  |          返回当前线程号          |\n| `int omp_set_num_threads()` |    设置并行代码执行时线程个数    |\n|  `double omp_get_wtime()`   |     返回以秒为单位的当前时间     |\n\n# 一、openMP语句模式\n\n```\n#pragma omp 指令 子句 子句 子句........\n```\n\n# 二、parallel 制导命令\n\n表示接下来由花括号括起来的区域将创建多个线程并行执行\n\n可以用`num_threads`来控制使用的线程数目。\n\n```\n#pragma omp parallel num_threads(5)\n```\n\n**函数实现线程数目控制**：`omp_set_num_threads(5)`\n\n获取线程ID：`int tid = omp_get_thread_num();`\n\n# 三、for 循环语句\n\n每一个要**循环的语句**将被分配给不同的线程去执行。\n\n```\n#pragma omp for\n```\n\n**tips**:循环体要按照`for(int i=0;i<n;i++)`的形式，注意int！要在for初始化\n\n```cpp\n#pragma omp parallel\n{\n    #pragma omp for\n    for(int i=0;i<n;i++)\n        {\n            // 执行语句\n        }\n}\n```\n\nparallel 和 for 可以写成一个整体，即：\n\n```cpp\n#pragma omp parallel for\nfor(int i=0;i<n;i++)\n{\n    // 执行语句\n}\n```\n\n# 四、schedule调度指令\n\n**schedule子句**：`schedule(type,size)`\n\n- type：**①static ②dynamic ③guided ④runtime**\n- size：整数型，表示**循环迭代次数划分单位**\n\n## 1、static参数：静态调度\n\n- 不用size参数时，分配给每个程序的都是n/t次连续迭代（n为迭代次数，t为并行的线程数目）\n- 使用size参数，表示每次分配给线程size个连续迭代。\n\n```cpp\n#pragma omp parallel for schedule(static) num_threads(3)\n{\n\tfor(int i=0;i<12;i++)\n\t{\n\t\t//一系列操作\n\t}\n}\n迭代情况：\n\tThread 0: 0、3、6、9\n\tThread 1: 1、4、7、10\n\tThread 2: 2、5、8、11\n\t\n#pragma omp parallel for schedule(static,2) num_threads(3)\n{\n\tfor(int i=0;i<12;i++)\n\t{\n\t\t//一系列操作\n\t}\n}\n迭代情况：\n\tThread 0: 0、1 | 6、7\n\tThread 1: 2、3 | 8、9\n\tThread 2: 4、5 | 10、11\n\n```\n\n## 2、dynamic参数：动态调度\n\n先到先得的方式进行任务分配\n\n- 不使用size参数时，空闲线程取**一个任务**\n- 使用size参数时候，空闲线程取**size个任务**\n\n## 3、guided参数：\n\n`guided`开始时每个线程会分配到较大的迭代块，之后分配到的迭代块会逐渐递减。\n\n迭代块的大小会按指数级下降到指定的`chunksize`大小，如果没有指定`chunksize`参数，那么迭代块大小最小会降到1。\n\n**代码示例：**\n\n```cpp\n#include<omp.h>\n#include<iostream>\nusing namespace std;\nint main()\n{\n\tomp_set_num_threads(2);\n#pragma omp parallel for schedule(static)\n\t\tfor(int i=0;i<8;i++)\n\t\t cout << omp_get_thread_num() << endl;\n}\n```\n\n# 五、sections制导指令\n\n用sections把**不同的区域交给不同的线程**去执行\n\n**代码示例：**\n\n```cpp\n#include <bits/stdc++.h>\n#include <omp.h>\nusing namespace std;\nint main()\n{\n    #pragma omp parallel sections\n    {\n        #pragma omp section\n        {\n            // 句段1\n        }\n        #pragma omp section\n        {\n            // 句段2\n        }\n    }\n}\n```\n\n# 六、变量管理\n\n在没有private指令的时候，默认变量都是各线程之间**共享**的\n\n## private\n\n用`#pragma omp private(n)`声明可声明**一个或多个**变量为线程私有副本。\n\n```cpp\nint n = 1 , m = 100;\n#pragma omp private(n,m)\n{\n\tprintf(\"%d %d\",n,m);//此时的n、m为各线程私有，n=0,m=0;\n}\n```\n\n## firstprivate\n\nprivate指令只是声明变量私有，但不能继承在主线程中的值，这时就需要用`firstprivate`了\n例如：\n\n```cpp\nint n = 1;\n#pragma omp firstprivate(n)\n{\n\tprintf(\"%d\",n);//此时每个线程中的n都为1\n}\n```\n\n## lastprivate\n\n将经过线程处理的数据重新赋值给主线程的变量\n**注意：**\n最终主线程变量的值由最后执行完成的那个线程决定。\n\n```cpp\nint n = 1;\n#pragma omp lastprivate(n) \n{\n\tn += omp_get_thread_num();//最终的n的值由最后一个执行完的线程决定\n}\nprintf(\"%d\",n);\n```\n\n## defualt\n\ndefault可以设置并行区域的变量使用方式\n`default(shared)`为共享\n`default(none)`为私有\n\n# 七、single制导语句\n\nsingle制导指令所包含的代码段只有一个线程执行，别的线程跳过。\n\n如果没有`nowait`子句，那么其他线程将会在single制导指令结束的隐式同步点等待。\n\n有`nowait`子句其他线程将跳过等待往下执行。\n\n```\n#pragma omp single\n#pragma omp single nowait\n```\n\n![image-20240524114221718](OpenMP学习/image-20240524114221718.png)\n\n# 八、互斥\n\n`critical`、`Lock`、`atomic`三者的耗时比约为 7 : 3.5 ：1\n\n## 1、critical\n\nCritical区域是一段代码，在同一时刻只能被一个线程执行。当一个线程进入Critical区域时，其他线程就需要等待该线程执行完毕后才能进入这个区域。使用`#pragma omp critical`指令来创建Critical区域。\n\n```cpp\nint x=0;\n#pragma omp parallel for\n{\n\t#pragma omp critical\n\t{\n\t\tx+=1;//此时只能有一个线程进行这个x+1的操作，其他线程在等待\n\t}\n\tprintf(\"%d\",x);\n}\n```\n\n## 2、atomic\n\natomic是原子操作，**速度最快**，但是<u>只能保护一条C语言赋值语句形成的临界区</u>\n语句必须按照：x {op} = {expression}的形式\n如：x++、x--、--x、++x\n\nop可以是以下任意的二元操作符：+、-、*、/、&、^、|、<<、>>\n\n**注意：**expression不能引用x，如：x+=x，这是不允许的\n\n```cpp\nint x = 0;\n#pragma omp parallel\n{\n\t#pragma omp atomic\n\t\tx++;\n}\n```\n\n## 3、锁\n\n一种显式的同步机制，可以用于保护共享资源，也可以用于控制线程执行的顺序\n\n在OpenMP中，我们可以使用omp_lock_t类型的变量\n\n`omp_init_lock(&omp_lock)`初始化锁\n`omp_set_lock(omp_lock)`上锁\n`omp_unset_lock(&omp_lock)`解锁\n`omp_test_lock(&omp_lock)`测试锁，上锁状态返回0，否则为1，当前线程不会发生阻塞\n`omp_destroy_lock(&omp_lock)`撤销锁\n\n```cpp\nomp_lock_t lock;\nomp_init_lock(&lock);\n#pragma omp parallel\n{\n    // 临界区\n    omp_set_lock(&lock);\n    // 这里是需要保护的代码块\n    omp_unset_lock(&lock);\n}\nomp_destroy_lock(&lock);\n```\n\n# 九、规约子句\n\n使用规约子句将并行区域末尾计算出的结果与原始值合并\n\n使用：`reduction(op:list)`\n\n| 运算符 |           初始值           |\n| :----: | :------------------------: |\n|   +    |             0              |\n|   *    |             1              |\n|   -    |             0              |\n|  min   | 规约列表类型中最大可表示数 |\n|  max   | 规约列表类型中最小可表示数 |\n\n```cpp\n#pragma omp parallel for reduction(+:sum)\nfor(int i = 0; i < 100; i++){\n\tsum += i;\n}\n```\n\n","tags":["超算"]},{"title":"web前端开发","url":"/2022/02/05/web前端开发/","content":"\n# HTML\n\n## 一、基础标签\n\n#### 1、<hr>分割线标签\n\n```html\n<!DOCTYPE html>\n<html>\n\t<head>\n\t\t<meta charset=\"utf-8\" />\n\t\t<title></title>\n\t</head>\n\t<body>\n\t\t<hr color=\"red\" />\n\t\t<hr color=\"green\" width=\"200\"/>\n\t\t<hr color=\"blue\" align=\"right\" width=\"100\"/>\n\t\t<hr />\n\t\t<hr noshade=\"noshade\"/> <!--无阴影-->\n\t</body>\n</html>\n```\n\n![img](web前端开发/1695631951027-f9965548-67e1-4eab-8cd5-eb0f942e0f66.png)\n\n#### 2、特殊符号\n\n![img](web前端开发/1695632165459-ed017fbb-bb0c-4d34-8033-989aa2baa0c6.png)\n\n#### 3、<div>和<span>标签\n\n**div标签：**无具体含义，用来划分区域，独占一行\n\n**span标签：**没有实际意义，主要用于文本的独立修饰，内容原来有多宽就占用多宽\n\n```html\n\t\t<h3>体育sports</h3>\n\t\t<h3>体育<span style=\"color: red;\">sports</span></h3>\n```\n\n![img](web前端开发/1695632731353-81a36c73-b073-4d9c-8878-06a570d49c8b.png)\n\n#### 4、<ul>、<ol>列表以及自定义列表\n\n![img](web前端开发/1695633169978-e673c111-5d9b-419b-be46-8614c153f976.png)\n\n```html\n<ol type=\"I\" start=\"3\">\n  <li>III</li>\n  <li>IV</li>\n  <li>V</li>\n</ol>\ntype：1,a,A,I,i\nstart：取值只能是一个数字\n<ul type=\"square\">\n  <li>1111</li>\n  <li>2222</li>\n</ul>\ntype: disc,circle,square,none\n<dl>\n  <dt>我是图片</dt>\n  <dd>我是文字</dd>\n</dl>\n```\n\n#### 5、<img>图片标签\n\n支持jpeg/png/gif三种格式\n\n```html\n同级目录：<img src=\"1.jpg\">\n上级目录：<img src=\"../1.jpg\">\n绝对路径\n<img src=\"图片路径\" \n  \ttitle=\"鼠标悬停上去后的文字提示\"\n  \talt=\"图片加载失败的文字提示\"\n    width=\"宽度\"\n\t\theight=\"高度\" />\n```\n\n#### 6、<a>超链接标签\n\n```html\n<a href=\"跳转路径\"\n  \ttitle=“鼠标悬停文字”\n    target=\"规定在何处打开\">\n  可视内容\n</a>\ntarget属性：规定在何处打开\n\ttarget=\"_self\" 默认值，本窗口打开\n\ttarget=\"_blank\" 新窗口打开\n\n<a href=\"www.baidu.com\" title=\"点击一下，了解更多\" target=\"_blank\">\n\t<img src=\"baidu.png\" />\n</a>\n\n<a href=\"#link_to_this\">点击到达</a>\n<p name=\"link_to_this\"></p>\n\n<a href=\"mailto:vicczyq@qq.com\">发送邮件</a>\n```\n\n![img](web前端开发/1695635303035-80966f86-af1c-4ec3-9c01-6665955ef326.png)\n\n#### 7、<table>表格标签\n\n<table>表格属性：\n\n1. width 宽度\n2. height 高度\n3. border 边框\n4. bordercolor 边框颜色\n5. bgcolor 背景颜色\n6. align 对齐：right、left、center\n7. cellspacing 单元格与单元格之间的间距\n8. cellpadding 单元格和内容之间的空隙\n\n**<tr>行属性：（没有width宽度属性）**\n\n1. height 高度\n2. bgcolor 背景颜色\n3. align 文字水平对齐left、right、center\n4. valign 文字垂直对齐top、middle、bottom\n\n**<td>单元格属性：**\n\n1. width 宽度（影响一列的宽度）\n2. height 高度（影响一行的高度）\n3. bgcolor 背景颜色\n4. align 文字水平对齐\n5. valign 文字垂直对齐\n\n```html\n\t\t<table>表\n\t\t\t<tr>行\n\t\t\t\t<td>1</td>单元格\n\t\t\t\t<td>2</td>\n\t\t\t</tr>\n\t\t\t<tr>\n\t\t\t\t<td>3</td>\n\t\t\t\t<td>4</td>\t\t\t\t\n\t\t\t</tr>\n\t\t</table>\n```\n\n**表格的合并：colspan合并列、rowspan合并行**\n\n#### 8、form表单标签\n\n```html\n<form method=\"get/post\" action=\"表单数据发送URL\">\n\t<input type=\"...\" />\n  <\n      A. 属性type定义输入框的类型\n        \ta) 文本框、密码框 <input type=\"text|password\" />\n          b) 提交框 <input type=\"submit\" />\n          c) 按钮框 <input type=\"button\" /> 单纯的按钮\n          d) 重置框 <input type=\"reset\" />清空表单内容\n          e) 单选框 <input type=\"radio\" name=\"sex\" value=\"male\"/>男\n                    <input type=\"radio\" name=\"sex\" value=\"female\"/>女\n          f) 多选框 <input type=\"checkbox\" name=\"transport\" value=\"bike\" />自行车\n                    <input type=\"checkbox\" name=\"transport\" value=\"bus\" />公共汽车\n          g) 文件上传<input type=\"file\" />\n          h) 下拉菜单 <select size=\"3\" name=\"xxx\">//视角大小为3\n                        <option disabled selected>==请选择===</option>\n                        <option value=\"1\">1</option>\n                        <option value=\"2\">2</option>\n                        <option value=\"3\">3</option>\n          \t\t\t\t\t\t</select>\n          i) 多行文本 <textarea name=\"xxx\" rows=2 cols=1>…</textarea>\n    \n      B. 属性placeholder描述输入字段预期值的简短信息提示\n      C. 属性name必须设置，否则在提交的时候输入的数据不会发送\n      D. 属性value,输入框默认输入内容，加在按钮上为标题\n\t\t      如：<input type=\"submit\" value=\"上传\" />\n              <input type=\"reset\" value=\"重置\" />\n>\n</form>\n```\n\ndisabled属性可以禁用\n\n**<filedset>...</filedset>**可以设置分组，中间加**<legend>**标签可以设置主题\n\n![img](web前端开发/1695822025377-d717d6d5-d7d8-4159-97e0-4bce7640e258.png)\n\n#### 9、锚点\n\n```html\n<div id=\"#aaa\"></div>\n<!-- 锚点aaa -->\n<a herf=\"#aaa\">点击定位到a</a>\n```\n\n# CSS\n\n```html\n<head>\n    <style >\n      *{\t\t\t\t\t\t\t\t通用选择器\n        margin:0px\t\t\n      }\n      h1{\t\t\t\t\t\t\t\t标签选择器\n        color:red;\n      }\n      #name{\t\t\t\t\t\t类选择器class\n        color:green;\n      }\n      .id {\t\t\t\t\t\t\tid选择器\n        color:blue\n      }\n    </style>\n</head>\n方法一：\n<style type=\"text/css\">\n  @import url(\"CSS文件路径\")\n</style>\n方法二：\n<link rel=\"stylesheet\" type=\"text/css\" href=\"css文件路径\">\n<div style=\"width:200px\"></div>\n```\n\n\n\n**CSS样式表的****优先级****：行内>内部>外部**\n\n```html\na:link{属性:属性值}\t超链接的初始状态\na:visited{属性:属性值} 超链接被访问后的状态\na:hover{属性:属性值} 鼠标悬停时的状态\na:active{属性:属性值} 鼠标按下超链接的状态\n```\n\nlink--visited--hover--active\n\n### 1、文本属性\n\n![img](web前端开发/1695639480688-c5abcf44-95c5-4ace-a1f2-ccd3cf40a9f9.png)![img](web前端开发/1695799466350-aec44770-7a22-49dc-aef3-65d8fb270f69.png)\n\n```html\n文本首字母大写：text-transform:capitalize\n文本转小写：text-transform:lowercase\n文字转大写：text-transform:uppercase\n```\n\n### 2、列表属性\n\n![img](web前端开发/1695800346011-6fc94c4d-a49d-46e1-ad79-df04b295c891.png)\n\n### 3、背景属性\n\n![img](web前端开发/1695800590244-632d630f-cc2e-47ce-bb7b-27304356b5bf.png)\n\n```html\nbackground-size:cover\nbackground-size:100% 100%\nbackground-size:100px 100px\n```\n\n### 4、浮动float属性\n\n![img](web前端开发/1695802285408-dd289a7f-fdf1-4364-90c7-1c361591aa3d.png)![img](web前端开发/1695802457654-cd1a1173-e0bb-41c7-b60f-eb997cc869d7.png)\n\n### 5、盒子模型\n\n![img](web前端开发/1695802939375-75259be5-d93f-42a4-96fd-3d566c0e35c2.png)\n\n#### 内边距 padding、外边距 margin\n\n- 1个值，4个方向一样\n- 2个值，上下，左右\n- 3个值，上，左右，下\n- 4个值，上，右，下，左\n\n\n\n#### 边框 border（width style color）\n\n```\nborder:1px solid red\n```\n\n**样式：**\n\n1. none：没有边框，也即忽略边框的宽度；\n2. dotted：点线；\n3. dashed：虚线；\n4. solid：实线；\n5. double：双线；\n6. groove：3D凹槽；\n7. ridge：菱形边框；\n8. inset：3D凹边；\n9. outset：3D凸边；\n\n#### 屏幕横向居中\n\n```\nmargin:0 auto\n```\n\n#### 注意：margin垂直方向外边距取最大值，水平方向取和\n\n### 6、溢出属性\n\n#### (1)overflow:\n\n![img](web前端开发/1695804858012-6f571f7d-f009-4618-b32a-bc3f4902de4e.png)\n\n#### (2)white-space\n\n![img](web前端开发/1695805168006-c97b87c7-7866-464a-bb8a-eadf9eec1759.png)\n\n#### (3)text-overflow（必须有宽度width！！！！）\n\n```\ntext-overflow:ellipsis\n```\n\n![img](web前端开发/1695805461984-30bbe8ad-0988-45ab-8b92-9f90741aa36f.png)\n\n### 7、元素显示类型\n\n![img](web前端开发/1695805704515-66885476-500c-470c-8b4e-5ced19fd7dee.png)\n\n可以用`display`进行相互转换\n\n### 8、定位\n\n![img](web前端开发/1695816702982-0509abbb-132a-4d4c-9dce-48f21c6f019a.png)\n\n父子关系如果想让父盒子显示在上面：在子盒子中设置z-index为负值即可\n\n### 9、三角形案例\n\n![img](web前端开发/1695817864798-a6945562-adac-47f4-af09-5b7c1f8d3f0a.png)\n\n```html\n\t\t<style type=\"text/css\">\n\t\t\tdiv{\n\t\t\t\theight: 0px;\n\t\t\t\twidth: 0px;\n\t\t\t\tborder-top: 20px solid red;\n\t\t\t\tborder-right: 20px solid transparent;\n\t\t\t\tborder-bottom: 20px solid transparent;\n\t\t\t\tborder-left: 20px solid transparent;\n\t\t\t}\n\t\t</style>\n```\n\n### 10、水平垂直居中\n\n```html\n\t\t<style type=\"text/css\">\n\t\t\t*{\n\t\t\t\tmargin: 0;\n\t\t\t\tpadding: 0;\n\t\t\t}\n\t\t\tdiv{\n\t\t\t\theight: 200px;\n\t\t\t\twidth: 200px;\n\t\t\t\tbackground-color: red;\n\t\t\t\tposition: absolute;\n\t\t\t\ttop: 50%;\n\t\t\t\tleft: 50%;\n\t\t\t\tmargin-left: -100px;\n\t\t\t\tmargin-top: -100px;\n\t\t\t}\n\t\t</style>\n```\n\n![img](web前端开发/1695818652162-9b170132-d822-4063-b482-e0742762bbde.png)\n\n### 11、浮动和绝对定位的区别\n\n浮动是半脱离状态，文字是环绕效果\n\n![img](web前端开发/1695818906440-c1c0d98c-7967-4cc3-ab02-d23ddcb46750.png)\n\n定位是全脱离状态，不会出现文字环绕效果\n\n![img](web前端开发/1695818881031-d284e957-f409-4ec3-890a-36d736018a4a.png)\n\n### 12、calc计算函数\n\n```\nwidth: calc(100% - 200px)\n```\n\n### 13、圆角属性\n\n```\nborder-radius: 2px\n```\n\n等价于：\n\n![img](web前端开发/1698233180004-a75117ef-636f-4f39-9145-9c6ae82f184c.png)\n\n### 14、方框阴影属性\n\n```\nbox-shadow: <h-shadow> <v-shadow> [blur] [spread] [color] [inset]\n```\n\n![img](web前端开发/1698233434344-7616929e-0211-468f-ba84-dcee322cc129.png)\n\n# JavaScript\n\n```html\n嵌入网页\n<script type=\"text/javascript\">\n    //JavaScript程序\n</script>\n\n单独.js文件调用\n<script type=\"text/javascript\" src=\"xxx/xx.js\">\n</script>\n```\n\n**变量声明：**\n\n`**var**`要求不严格，可以在作用范围内重复\n\n`**let**`要求严格，在相同的作用域内不能重复声明同一个变量\n\n**常量声明：**\n\n`**const**`不能与let声明的变量重复，一旦声明就必须初始化，值不能改变\n\n```\nconst a = 3.1415\n```\n\n## 类型转换\n\n- parseInt(String)\n- parseFloat(String)\n- Number(String) 将字符串转化为数值型\n- toFixed(String) 按照指定的小数位返回数字的字符串表示\n\n## 注释\n\n单行注释用// 多行用/**/\n\n```javascript\n//单行注释内容\n\n/*多行注释\nHello\nworld!\n*/\n```\n\n## typeof\n\n操作数的类型\n\n## 数组\n\n1. 新建长度为0的数组：`var myArray = new Array();`\n2. 新建长度为n的数组：`var myArray = new Array(n);`\n3. 新建一个指定内容的数组：`var myArray = new Array(1,2,3);`\n4. 简介定义：`var myArray = [1,2,3];`\n5. 获取数组长度 `myArray.length;`\n6. `push()/pop()栈方法`\n\n内容可以用alert输出（提示框）\n\n### 数组相关方法：\n\n#### （1）concat方法\n\n```javascript\nvar a=[1,2,3];\nvar b=[4,5,6];\nalert(a.concat(b));//输出1,2,3,4,5,6\nalert(a.length);//长度仍为3\n可以直接连接数值\n如：a.concat(4,5,6);\n```\n\n#### （2）join方法\n\n```javascript\nvar a=[1,2,3];\nalert(a.join());//输出1,2,3,\nalert(a.join(\":\"));//输出1:2:3\n```\n\n#### （3）shift方法\n\n```javascript\nvar a=[1,2,3];\nalert(a.shift());输出1\nalert(a.shift());输出2\nalert(a.length);输出长度1\n```\n\n#### （4）unshift方法\n\n```javascript\nvar a=[1,2,3];\na.unshift(4,5,6);\nalert(a);//输出4,5,6,1,2,3\n```\n\n#### （5）slice方法\n\n```javascript\nvar a1=[1,2,3,4,5];\nalert(a1.slice(1,3)); //输出2,3\nalert(a1.slice(1));   //输出2,3,4,5\nalert(a1.slice(1,-1)); //输出2,3,4\nalert(a1.slice(-3,-2)); //输出3\n```\n\n#### （6）sort方法\n\n```javascript\nvar a1=[1,4,2,3,5];\nalert(a1.sort());  //输出1,2,3,4,5\n```\n\n#### （7）reverse方法\n\n## JavaScript函数\n\n```javascript\nfunction 函数名(参数1,参数2...)\n{\n    // 函数内容\n    // [return <返回值>]\n}\n<input type=\"Submit\" value=\"显示\" onClick=\"函数名()\">\n```\n\n### 常见事件：\n\n| **事件**     | **动作**                     | **事件**      | **动作**                           |\n| ------------ | ---------------------------- | ------------- | ---------------------------------- |\n| **Abort**    | **中止正在加载的对象**       | **Load**      | **浏览器读入文件时**               |\n| **Blur**     | **失去焦点**                 | **Unload**    | **关闭当前网页**                   |\n| **Focus**    | **获取焦点**                 | **MouseDown** | **按下鼠标左键**                   |\n| **Change**   | **改变对象的值**             | **MouseMove** | **移动鼠标指针**                   |\n| **Click**    | **在对象上单击鼠标**         | **MouseOut**  | **鼠标指针离开某对象**             |\n| **DblClick** | **在对象上双击鼠标**         | **MouseOver** | **鼠标指针悬停于某对象之上**       |\n| **DrogDrop** | **拖拽对象**                 | **MouseUp**   | **放开鼠标左键**                   |\n| **Error**    | **加载文件或图形时发生错误** | **Move**      | **窗口被移动时**                   |\n| **KeyDown**  | **按下键盘上的任意键的瞬间** | **Resize**    | **窗口大小被改变**                 |\n| **KeyPress** | **按下键盘上的任意键时**     | **Select**    | **选择某对象**                     |\n| **KeyUp**    | **某键被按下后弹起来的瞬间** | **Submit**    | **单击表单上的****Submit****按钮** |\n|              |                              | **Reset**     | **单击表单上的****Reset****按钮**  |\n\n### document对象及操作\n\ndocument表示整个页面文档\n\n#### （1）documen.getElementById(id)\n\n```\nvar a = document.getElementById(\"name\").value;\n```\n\n#### （2） document.getElementsByName(name)\n\n```javascript\nvar userNameInput=document.getElementsByName(\"userName\");\nvar userName = userNmaeInput[0].value;\n返回值为数组对象；如果无符合条件的对象，则返回空数组\n由于该方法的返回值是一个数组，所以可以通过位置下标来获得页面元素\n```\n\n#### （3）document.getElementsByTagName(tagname)\n\n```javascript\n返回值：数组对象; 如果无符合条件的对象，则返回空数组\n例如：\nvar inputs=document.getElementsByTagName(“input”);\nalert(input.length);   //显示为4\n```\n\n#### （4）document.forms\n\n```javascript\n返回值：数组对象。如果无符合条件的对象(Form对象)，则返回空数组\n例如：\nvar frms=document.forms;  //先获得数组对象，注意不是方法，是属性\nvar loginfrm=frms[0]; //获得数组中的第一个form对象，如果存在的话\n```\n\n### document属性\n\n#### (1)innerHTML属性\n\n```javascript\n<p id=\"p1\">Hello World!</p>\n<script>\ndocument.getElementById(\"p1\").innerHTML=\"New text!\";\n</script>\n\n<script>\ndocument.getElementById(\"p2\").style.color=\"blue\";\n</script>\n```\n\n#### (2)操作HTML\n\n```javascript\nvar para = document.createElement(\"p\");\nvar node = document.createTextNode(\"新段落\");\npara.appendChild(node);\nvar element=document.getElementById(\"div1\");\nelement.appendChild(para);\n```\n\n#### (3)改变元素属性\n\n```javascript\nobj.getAttribute(attribute);\nobj.setAttribute(attribute,value);\n//getAttribute方法就是专门用来获取元素属性的\n//相应的我们也可以使用setAttribute方法来更改元素节点的值\n例如：\ndocument.getElementById(\"div1\").getAttribute(\"name\");\n```\n\n#### (4)删除元素\n\n```javascript\nvar child=document.getElementById(\"p1\");\nvar parent=document.getElementById(\"div1\");\nparent.removeChild(child);//从父元素中删除该元素\n    <script>\n        const loginForm = document.getElementById('loginForm');\n        const usernameInput = document.getElementById('username');\n        const passwordInput = document.getElementById('password');\n        const usernameMessage = document.getElementById('username-message');\n\t\t\t\tconst passwordMessage = document.getElementById('password-message');\n\n        loginForm.addEventListener('submit', function (event) {\n            event.preventDefault(); \n            const username = usernameInput.value;\n            const password = passwordInput.value;\n      \t\t\tshowMessage(passwordMessage,'');\n      \t\t\tshowMessage(usernameMessage,'');\n      \t\t\tvar user_flag = false;\n      \t\t\tvar pass_flag = false;\n            if (username.length === 0)showMessage(usernameMessage,'请输入用户名');\n            else if (!isEnglishCharacter(username))showMessage(usernameMessage,'用户名必须以英文字母开头！');  \n            else if(username.length < 6||username.length>18)showMessage(usernameMessage,\"用户名必须在6到18位\");\n\t\t\t\t\t\telse user_flag = true;\n  \n            if (password.length < 6)showMessage(passwordMessage,\"密码不能小于6位！\"); \n            else pass_flag=true; \n            if(pass_flag && user_flag)\n            {\n            \talert(\"注册成功！！\");\n            }\n        });\n      \n        function isEnglishCharacter(input) {\n            const firstChar = input.charAt(0);\n            // const firstCharCode = firstChar.charCodeAt(0);\n            return (firstChar >='a' && firstChar <='z') || (firstChar >='A' && firstChar <='Z');\n            // return (firstCharCode >= 65 && firstCharCode <= 90) || (firstCharCode >= 97 && firstCharCode <= 122);\n        }\n\n        function showMessage(element,message) {\n           element.textContent = message;\n        }\n    </script>\n```\n\n# JQurey\n\n```html\n\t\t<script>\n\t\t\t$(document).ready(\n\t\t\t\tfunction(){\n\t\t\t\t\tfunction loadStuInfo(){\n\t\t\t\t\t\t$.ajax({\n\t\t\t\t\t\t\ttype:\"get\",\n\t\t\t\t\t\t\turl:\"http://114.67.241.121:8123/stu/list\",\n\t\t\t\t\t\t\tasync:true,\n\t\t\t\t\t\t\tsuccess: function(e){\n\t\t\t\t\t\t\t\t$(\"#info\").find(\"tr:gt(0)\").remove();\n\t\t\t\t\t\t\t\tfor(var i=0; i<e.data.length;i++)\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t$(\"#info\").append(\n\t\t\t\t\t\t\t\t\t\t\"<tr>\"+\n\t\t\t\t\t\t\t\t\t\t\t\"<td>\"+e.data[i].stuid+\"</td>\"+\n\t\t\t\t\t\t\t\t\t\t\t\"<td>\"+e.data[i].stuno+\"</td>\"+\n\t\t\t\t\t\t\t\t\t\t\t\"<td>\"+e.data[i].stuname+\"</td>\"+\n\t\t\t\t\t\t\t\t\t\t\t\"<td>\"+e.data[i].stumajor+\"</td>\"+\n\t\t\t\t\t\t\t\t\t\t\t\"<td>\"+e.data[i].stugender+\"</td>\"+\n\t\t\t\t\t\t\t\t\t\t\t\"<td>\"+e.data[i].stugrade+\"</td>\"+\n\t\t\t\t\t\t\t\t\t\t\t\"<td>\"+e.data[i].stuphone+\"</td>\"+\n\t\t\t\t\t\t\t\t\t\t\t\"<td>\"+e.data[i].stuaddess+\"</td>\"+\n\t\t\t\t\t\t\t\t\t\t\t\"<td>\"+e.data[i].stunative+\"</td>\"+\n\t\t\t\t\t\t\t\t\t\t\t\"<td><a href='' class='delete'>删除</a>\"+\n\t\t\t\t\t\t\t\t\t\t\"</tr>\"\n\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tloadStuInfo();//初始化数据\n\t\t\t\t\t\n\t\t\t\t\t$(\"#submit\").click(\n\t\t\t\t\t\tfunction(){\n\t\t\t\t\t\t\t$.ajax({\n\t\t\t\t\t\t\t\ttype:\"post\",\n\t\t\t\t\t\t\t\tdataType: 'json',\n\t            \t\t\t\tcontentType: 'application/json',\n\t\t\t\t\t\t\t\turl:\"http://114.67.241.121:8123/stu/add\",\n\t\t\t\t\t\t\t\tdata:JSON.stringify(\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t  stuaddess: $(\"#stuaddress\").val(),\n\t\t\t\t\t\t\t\t\t  stugender: $(\"#stugender\").val(),\n\t\t\t\t\t\t\t\t\t  stugrade: $(\"#stugrade\").val(),\n\t\t\t\t\t\t\t\t\t  stuid: 0,\n\t\t\t\t\t\t\t\t\t  stumajor: $(\"#stumajor\").val(),\n\t\t\t\t\t\t\t\t\t  stuname: $(\"#stuname\").val(),\n\t\t\t\t\t\t\t\t\t  stunative: $(\"#stunative\").val(),\n\t\t\t\t\t\t\t\t\t  stuno: $(\"#stuno\").val(),\n\t\t\t\t\t\t\t\t\t  stuphone: $(\"#stuphone\").val()\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t),\n\t\t\t\t\t\t\t\tsuccess:function(e){\n\t\t\t\t\t\t\t\t\tconsole.log(JSON.stringify(e));\n\t\t\t\t\t\t\t\t\tloadStuInfo();\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t}\n\t\t\t\t\t);\n\t\t\t\t\n\t\t\t\t\t$(\"#info\").on(\"click\",\"a\",function(event)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tevent.preventDefault();\n\t\t\t\t\t\t\tvar stuid = $(this).closest(\"tr\").children(\":eq(0)\").text();\n\t\t\t\t\t\t\t//let stuid = $(this).closest(\"tr\").children().first().text();\n\t\t\t\t\t\t\t$.ajax({\n\t\t\t\t\t\t\t\ttype:\"post\",\n\t\t\t\t\t\t\t\turl:\"http://114.67.241.121:8123/stu/del\",\n\t\t\t\t\t\t\t\tdata: \"stuId=\" + stuid,\n\t\t\t\t\t\t\t\tsuccess:function(e){\n\t\t\t\t\t\t\t\t\tconsole.log(JSON.stringify(e));\n\t\t\t\t\t\t\t\t\tloadStuInfo();\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t}\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t);\n\t\t</script>\n```\n\n![img](web前端开发/1698476517302-c078f5c0-030c-48ee-ad49-7db744722890.png)\n"},{"title":"一刻","url":"/2018/01/01/一刻/","content":"\n## 生日\n\n高思雨：正月初八\n\n阿姨：正月十四\n\n姐姐：七月十四\n\n余泓材：七月廿二\n\n爸爸：八月初六\n\n爷爷：八月十四\n\n奶奶：腊月初二\n\n妈妈：腊月初三\n\n陈臣：腊月初八\n\n## 纪念日\n\n周年：21年11月9日\n\n1th约会：22年1月21日\n","tags":["重要"]}]